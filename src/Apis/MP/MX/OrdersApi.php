<?php

/**
 * OrdersApi
 * PHP version 7.4
 *
 * @category Class
 * @package  Walmart
 * @author   Jesse Evers
 * @link     https://highsidelabs.co
 */

/**
 * Order Management
 *
 * This class is auto-generated by the OpenAPI generator v6.6.0 (https://openapi-generator.tech).
 * Do not edit the class manually.
 */

namespace Walmart\Apis\MP\MX;

use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Promise\PromiseInterface;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use Walmart\Apis\BaseApi;
use Walmart\ApiException;
use Walmart\ObjectSerializer;

/**
 * OrdersApi Class Doc Comment
 *
 * @category Class
 * @package  Walmart
 * @author   Jesse Evers
 * @link     https://highsidelabs.co
 * @email    jesse@highsidelabs.co
 */
class OrdersApi extends BaseApi
{
    /**
     * @var string[] $contentTypes
     */
    public const contentTypes = [
        'acknowledgeOrders' => 'application/json',
        'cancelOrderLines' => 'application/json',
        'deliveryUpdates' => 'application/json',
        'getAllOrders' => 'application/json',
        'getAllOrdersUsingCursor' => 'application/json',
        'getAllWFSOrders' => 'application/json',
        'getShippingLabel' => 'application/json',
        'postBulkShippingLabel' => 'application/json',
        'shippingUpdates' => 'application/json',
    ];

    /**
     * Operation acknowledgeOrders
     *
     * Acknowledge Orders
     *
     * @param  string $purchaseOrderId purchaseOrderId (required)
     * @param  \Walmart\Models\MP\MX\Orders\OrderAckRequest $orderAckRequest (required)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string|\Walmart\Models\MP\MX\Orders\ErrorResponse|\Walmart\Models\MP\MX\Orders\ErrorResponse
     */
    public function acknowledgeOrders(
        string $purchaseOrderId,
        \Walmart\Models\MP\MX\Orders\OrderAckRequest $orderAckRequest
    ): string {
        return $this->acknowledgeOrdersWithHttpInfo($purchaseOrderId, $orderAckRequest);
    }

    /**
     * Operation acknowledgeOrdersWithHttpInfo
     *
     * Acknowledge Orders
     *
     * @param  string $purchaseOrderId purchaseOrderId (required)
     * @param  \Walmart\Models\MP\MX\Orders\OrderAckRequest $orderAckRequest (required)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string|\Walmart\Models\MP\MX\Orders\ErrorResponse|\Walmart\Models\MP\MX\Orders\ErrorResponse
     */
    protected function acknowledgeOrdersWithHttpInfo(
        string $purchaseOrderId,
        \Walmart\Models\MP\MX\Orders\OrderAckRequest $orderAckRequest,
    ): string {
        $request = $this->acknowledgeOrdersRequest($purchaseOrderId, $orderAckRequest);
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
                $this->writeDebug($response);
                $this->writeDebug((string) $response->getBody());
            } catch (RequestException $e) {
                $hasResponse = !empty($e->hasResponse());
                $body = (string) ($hasResponse ? $e->getResponse()->getBody() : '[NULL response]');
                $this->writeDebug($e->getResponse());
                $this->writeDebug($body);

                throw new ApiException(
                    "[{$e->getCode()}] {$body}",
                    (int) $e->getCode(),
                    $hasResponse ? $e->getResponse()->getHeaders() : null,
                    $body
                );
            } catch (ConnectException $e) {
                $this->writeDebug($e->getMessage());

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }
            switch ($statusCode) {
                case 202:
                    if ('string' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        $contentType = $response->getHeader('Content-Type')[0] ?? '';
                        if ('string' !== 'string') {
                            $content = $contentType === 'application/xml' ? simplexml_load_string($content) : json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, 'string', $response->getHeaders());
                case 400:
                    if ('\Walmart\Models\MP\MX\Orders\ErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        $contentType = $response->getHeader('Content-Type')[0] ?? '';
                        if ('\Walmart\Models\MP\MX\Orders\ErrorResponse' !== 'string') {
                            $content = $contentType === 'application/xml' ? simplexml_load_string($content) : json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, '\Walmart\Models\MP\MX\Orders\ErrorResponse', $response->getHeaders());
                case 500:
                    if ('\Walmart\Models\MP\MX\Orders\ErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        $contentType = $response->getHeader('Content-Type')[0] ?? '';
                        if ('\Walmart\Models\MP\MX\Orders\ErrorResponse' !== 'string') {
                            $content = $contentType === 'application/xml' ? simplexml_load_string($content) : json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, '\Walmart\Models\MP\MX\Orders\ErrorResponse', $response->getHeaders());
            }

            $returnType = 'string';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                $contentType = $response->getHeader('Content-Type')[0] ?? '';
                if ($returnType !== 'string') {
                    $content = $contentType === 'application/xml' ? simplexml_load_string($content) : json_decode($content);
                }
            }

            return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 202:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Walmart\Models\MP\MX\Orders\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Walmart\Models\MP\MX\Orders\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }

            $this->writeDebug($e);
            throw $e;
        }
    }

    /**
     * Operation acknowledgeOrdersAsync
     *
     * Acknowledge Orders
     *
     * @param  string $purchaseOrderId purchaseOrderId (required)
     * @param  \Walmart\Models\MP\MX\Orders\OrderAckRequest $orderAckRequest (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function acknowledgeOrdersAsync(
        string $purchaseOrderId,
        \Walmart\Models\MP\MX\Orders\OrderAckRequest $orderAckRequest
    ): PromiseInterface {
        return $this->acknowledgeOrdersAsyncWithHttpInfo($purchaseOrderId, $orderAckRequest)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation acknowledgeOrdersAsyncWithHttpInfo
     *
     * Acknowledge Orders
     *
     * @param  string $purchaseOrderId purchaseOrderId (required)
     * @param  \Walmart\Models\MP\MX\Orders\OrderAckRequest $orderAckRequest (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    protected function acknowledgeOrdersAsyncWithHttpInfo(
        string $purchaseOrderId,
        \Walmart\Models\MP\MX\Orders\OrderAckRequest $orderAckRequest,
    ): PromiseInterface {
        $returnType = 'string';
        $request = $this->acknowledgeOrdersRequest($purchaseOrderId, $orderAckRequest);
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $this->writeDebug($response);
                    $this->writeDebug((string) $response->getBody());
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $hasResponse = !empty($response);
                    $body = (string) ($hasResponse ? $response->getBody() : '[NULL response]');
                    $this->writeDebug($response);
                    $statusCode = $hasResponse ? $response->getStatusCode() : $exception->getCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $body,
                    );
                }
            );
    }

    /**
     * Create request for operation 'acknowledgeOrders'
     *
     * @param  string $purchaseOrderId purchaseOrderId (required)
     * @param  \Walmart\Models\MP\MX\Orders\OrderAckRequest $orderAckRequest (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function acknowledgeOrdersRequest(
        string $purchaseOrderId,
        \Walmart\Models\MP\MX\Orders\OrderAckRequest $orderAckRequest,
    ): Request {
        $contentType = self::contentTypes['acknowledgeOrders'];

        // verify the required parameter 'purchaseOrderId' is set
        if ($purchaseOrderId === null || (is_array($purchaseOrderId) && count($purchaseOrderId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $purchaseOrderId when calling acknowledgeOrders'
            );
        }
        // verify the required parameter 'orderAckRequest' is set
        if ($orderAckRequest === null || (is_array($orderAckRequest) && count($orderAckRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $orderAckRequest when calling acknowledgeOrders'
            );
        }
        $resourcePath = '/v3/orders/{purchaseOrderId}/acknowledge';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $method = 'POST';

        // path params
        if ($purchaseOrderId !== null) {
            $resourcePath = str_replace(
                '{' . 'purchaseOrderId' . '}',
                ObjectSerializer::toPathValue($purchaseOrderId),
                $resourcePath
            );
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = parent::getDefaultHeaders();
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        // for model (json/xml)
        if (isset($orderAckRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($orderAckRequest));
            } else {
                $httpBody = $orderAckRequest;
            }
        } else if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        $query = ObjectSerializer::buildQuery($queryParams);
        $requestInfo = [
            'path' => $resourcePath,
            'method' => $method,
            'timestamp' => $defaultHeaders['WM_SEC.TIMESTAMP'],
            'query' => $query,
        ];

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getClientId()) || !(empty($this->config->getClientSecret()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getClientId() . ":" . $this->config->getClientSecret());
        }

        // this endpoint requires Bearer authentication (access token)
        $token = $this->config->getAccessToken();
        if ($token) {
            $headers['WM_SEC.ACCESS_TOKEN'] = $token->accessToken;
        }

        $operationHost = $this->config->getHost();
        return new Request(
            $method,
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cancelOrderLines
     *
     * Cancel Order Lines
     *
     * @param  string $purchaseOrderId purchaseOrderId (required)
     * @param  \Walmart\Models\MP\MX\Orders\OrderCancellationRequest $orderCancellationRequest File fields (required)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string|\Walmart\Models\MP\MX\Orders\ErrorResponse|\Walmart\Models\MP\MX\Orders\ErrorResponse
     */
    public function cancelOrderLines(
        string $purchaseOrderId,
        \Walmart\Models\MP\MX\Orders\OrderCancellationRequest $orderCancellationRequest
    ): string {
        return $this->cancelOrderLinesWithHttpInfo($purchaseOrderId, $orderCancellationRequest);
    }

    /**
     * Operation cancelOrderLinesWithHttpInfo
     *
     * Cancel Order Lines
     *
     * @param  string $purchaseOrderId purchaseOrderId (required)
     * @param  \Walmart\Models\MP\MX\Orders\OrderCancellationRequest $orderCancellationRequest File fields (required)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string|\Walmart\Models\MP\MX\Orders\ErrorResponse|\Walmart\Models\MP\MX\Orders\ErrorResponse
     */
    protected function cancelOrderLinesWithHttpInfo(
        string $purchaseOrderId,
        \Walmart\Models\MP\MX\Orders\OrderCancellationRequest $orderCancellationRequest,
    ): string {
        $request = $this->cancelOrderLinesRequest($purchaseOrderId, $orderCancellationRequest);
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
                $this->writeDebug($response);
                $this->writeDebug((string) $response->getBody());
            } catch (RequestException $e) {
                $hasResponse = !empty($e->hasResponse());
                $body = (string) ($hasResponse ? $e->getResponse()->getBody() : '[NULL response]');
                $this->writeDebug($e->getResponse());
                $this->writeDebug($body);

                throw new ApiException(
                    "[{$e->getCode()}] {$body}",
                    (int) $e->getCode(),
                    $hasResponse ? $e->getResponse()->getHeaders() : null,
                    $body
                );
            } catch (ConnectException $e) {
                $this->writeDebug($e->getMessage());

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }
            switch ($statusCode) {
                case 202:
                    if ('string' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        $contentType = $response->getHeader('Content-Type')[0] ?? '';
                        if ('string' !== 'string') {
                            $content = $contentType === 'application/xml' ? simplexml_load_string($content) : json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, 'string', $response->getHeaders());
                case 400:
                    if ('\Walmart\Models\MP\MX\Orders\ErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        $contentType = $response->getHeader('Content-Type')[0] ?? '';
                        if ('\Walmart\Models\MP\MX\Orders\ErrorResponse' !== 'string') {
                            $content = $contentType === 'application/xml' ? simplexml_load_string($content) : json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, '\Walmart\Models\MP\MX\Orders\ErrorResponse', $response->getHeaders());
                case 500:
                    if ('\Walmart\Models\MP\MX\Orders\ErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        $contentType = $response->getHeader('Content-Type')[0] ?? '';
                        if ('\Walmart\Models\MP\MX\Orders\ErrorResponse' !== 'string') {
                            $content = $contentType === 'application/xml' ? simplexml_load_string($content) : json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, '\Walmart\Models\MP\MX\Orders\ErrorResponse', $response->getHeaders());
            }

            $returnType = 'string';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                $contentType = $response->getHeader('Content-Type')[0] ?? '';
                if ($returnType !== 'string') {
                    $content = $contentType === 'application/xml' ? simplexml_load_string($content) : json_decode($content);
                }
            }

            return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 202:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Walmart\Models\MP\MX\Orders\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Walmart\Models\MP\MX\Orders\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }

            $this->writeDebug($e);
            throw $e;
        }
    }

    /**
     * Operation cancelOrderLinesAsync
     *
     * Cancel Order Lines
     *
     * @param  string $purchaseOrderId purchaseOrderId (required)
     * @param  \Walmart\Models\MP\MX\Orders\OrderCancellationRequest $orderCancellationRequest File fields (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cancelOrderLinesAsync(
        string $purchaseOrderId,
        \Walmart\Models\MP\MX\Orders\OrderCancellationRequest $orderCancellationRequest
    ): PromiseInterface {
        return $this->cancelOrderLinesAsyncWithHttpInfo($purchaseOrderId, $orderCancellationRequest)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cancelOrderLinesAsyncWithHttpInfo
     *
     * Cancel Order Lines
     *
     * @param  string $purchaseOrderId purchaseOrderId (required)
     * @param  \Walmart\Models\MP\MX\Orders\OrderCancellationRequest $orderCancellationRequest File fields (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    protected function cancelOrderLinesAsyncWithHttpInfo(
        string $purchaseOrderId,
        \Walmart\Models\MP\MX\Orders\OrderCancellationRequest $orderCancellationRequest,
    ): PromiseInterface {
        $returnType = 'string';
        $request = $this->cancelOrderLinesRequest($purchaseOrderId, $orderCancellationRequest);
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $this->writeDebug($response);
                    $this->writeDebug((string) $response->getBody());
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $hasResponse = !empty($response);
                    $body = (string) ($hasResponse ? $response->getBody() : '[NULL response]');
                    $this->writeDebug($response);
                    $statusCode = $hasResponse ? $response->getStatusCode() : $exception->getCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $body,
                    );
                }
            );
    }

    /**
     * Create request for operation 'cancelOrderLines'
     *
     * @param  string $purchaseOrderId purchaseOrderId (required)
     * @param  \Walmart\Models\MP\MX\Orders\OrderCancellationRequest $orderCancellationRequest File fields (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function cancelOrderLinesRequest(
        string $purchaseOrderId,
        \Walmart\Models\MP\MX\Orders\OrderCancellationRequest $orderCancellationRequest,
    ): Request {
        $contentType = self::contentTypes['cancelOrderLines'];

        // verify the required parameter 'purchaseOrderId' is set
        if ($purchaseOrderId === null || (is_array($purchaseOrderId) && count($purchaseOrderId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $purchaseOrderId when calling cancelOrderLines'
            );
        }
        // verify the required parameter 'orderCancellationRequest' is set
        if ($orderCancellationRequest === null || (is_array($orderCancellationRequest) && count($orderCancellationRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $orderCancellationRequest when calling cancelOrderLines'
            );
        }
        $resourcePath = '/v3/orders/{purchaseOrderId}/cancel';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $method = 'POST';

        // path params
        if ($purchaseOrderId !== null) {
            $resourcePath = str_replace(
                '{' . 'purchaseOrderId' . '}',
                ObjectSerializer::toPathValue($purchaseOrderId),
                $resourcePath
            );
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = parent::getDefaultHeaders();
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        // for model (json/xml)
        if (isset($orderCancellationRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($orderCancellationRequest));
            } else {
                $httpBody = $orderCancellationRequest;
            }
        } else if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        $query = ObjectSerializer::buildQuery($queryParams);
        $requestInfo = [
            'path' => $resourcePath,
            'method' => $method,
            'timestamp' => $defaultHeaders['WM_SEC.TIMESTAMP'],
            'query' => $query,
        ];

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getClientId()) || !(empty($this->config->getClientSecret()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getClientId() . ":" . $this->config->getClientSecret());
        }

        // this endpoint requires Bearer authentication (access token)
        $token = $this->config->getAccessToken();
        if ($token) {
            $headers['WM_SEC.ACCESS_TOKEN'] = $token->accessToken;
        }

        $operationHost = $this->config->getHost();
        return new Request(
            $method,
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deliveryUpdates
     *
     * Delivery Updates
     *
     * @param  string $purchaseOrderId purchaseOrderId (required)
     * @param  \Walmart\Models\MP\MX\Orders\Deliver $deliver File fields (required)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string|\Walmart\Models\MP\MX\Orders\ErrorResponse|\Walmart\Models\MP\MX\Orders\ErrorResponse
     */
    public function deliveryUpdates(
        string $purchaseOrderId,
        \Walmart\Models\MP\MX\Orders\Deliver $deliver
    ): string {
        return $this->deliveryUpdatesWithHttpInfo($purchaseOrderId, $deliver);
    }

    /**
     * Operation deliveryUpdatesWithHttpInfo
     *
     * Delivery Updates
     *
     * @param  string $purchaseOrderId purchaseOrderId (required)
     * @param  \Walmart\Models\MP\MX\Orders\Deliver $deliver File fields (required)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string|\Walmart\Models\MP\MX\Orders\ErrorResponse|\Walmart\Models\MP\MX\Orders\ErrorResponse
     */
    protected function deliveryUpdatesWithHttpInfo(
        string $purchaseOrderId,
        \Walmart\Models\MP\MX\Orders\Deliver $deliver,
    ): string {
        $request = $this->deliveryUpdatesRequest($purchaseOrderId, $deliver);
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
                $this->writeDebug($response);
                $this->writeDebug((string) $response->getBody());
            } catch (RequestException $e) {
                $hasResponse = !empty($e->hasResponse());
                $body = (string) ($hasResponse ? $e->getResponse()->getBody() : '[NULL response]');
                $this->writeDebug($e->getResponse());
                $this->writeDebug($body);

                throw new ApiException(
                    "[{$e->getCode()}] {$body}",
                    (int) $e->getCode(),
                    $hasResponse ? $e->getResponse()->getHeaders() : null,
                    $body
                );
            } catch (ConnectException $e) {
                $this->writeDebug($e->getMessage());

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }
            switch ($statusCode) {
                case 202:
                    if ('string' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        $contentType = $response->getHeader('Content-Type')[0] ?? '';
                        if ('string' !== 'string') {
                            $content = $contentType === 'application/xml' ? simplexml_load_string($content) : json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, 'string', $response->getHeaders());
                case 400:
                    if ('\Walmart\Models\MP\MX\Orders\ErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        $contentType = $response->getHeader('Content-Type')[0] ?? '';
                        if ('\Walmart\Models\MP\MX\Orders\ErrorResponse' !== 'string') {
                            $content = $contentType === 'application/xml' ? simplexml_load_string($content) : json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, '\Walmart\Models\MP\MX\Orders\ErrorResponse', $response->getHeaders());
                case 500:
                    if ('\Walmart\Models\MP\MX\Orders\ErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        $contentType = $response->getHeader('Content-Type')[0] ?? '';
                        if ('\Walmart\Models\MP\MX\Orders\ErrorResponse' !== 'string') {
                            $content = $contentType === 'application/xml' ? simplexml_load_string($content) : json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, '\Walmart\Models\MP\MX\Orders\ErrorResponse', $response->getHeaders());
            }

            $returnType = 'string';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                $contentType = $response->getHeader('Content-Type')[0] ?? '';
                if ($returnType !== 'string') {
                    $content = $contentType === 'application/xml' ? simplexml_load_string($content) : json_decode($content);
                }
            }

            return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 202:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Walmart\Models\MP\MX\Orders\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Walmart\Models\MP\MX\Orders\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }

            $this->writeDebug($e);
            throw $e;
        }
    }

    /**
     * Operation deliveryUpdatesAsync
     *
     * Delivery Updates
     *
     * @param  string $purchaseOrderId purchaseOrderId (required)
     * @param  \Walmart\Models\MP\MX\Orders\Deliver $deliver File fields (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deliveryUpdatesAsync(
        string $purchaseOrderId,
        \Walmart\Models\MP\MX\Orders\Deliver $deliver
    ): PromiseInterface {
        return $this->deliveryUpdatesAsyncWithHttpInfo($purchaseOrderId, $deliver)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deliveryUpdatesAsyncWithHttpInfo
     *
     * Delivery Updates
     *
     * @param  string $purchaseOrderId purchaseOrderId (required)
     * @param  \Walmart\Models\MP\MX\Orders\Deliver $deliver File fields (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    protected function deliveryUpdatesAsyncWithHttpInfo(
        string $purchaseOrderId,
        \Walmart\Models\MP\MX\Orders\Deliver $deliver,
    ): PromiseInterface {
        $returnType = 'string';
        $request = $this->deliveryUpdatesRequest($purchaseOrderId, $deliver);
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $this->writeDebug($response);
                    $this->writeDebug((string) $response->getBody());
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $hasResponse = !empty($response);
                    $body = (string) ($hasResponse ? $response->getBody() : '[NULL response]');
                    $this->writeDebug($response);
                    $statusCode = $hasResponse ? $response->getStatusCode() : $exception->getCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $body,
                    );
                }
            );
    }

    /**
     * Create request for operation 'deliveryUpdates'
     *
     * @param  string $purchaseOrderId purchaseOrderId (required)
     * @param  \Walmart\Models\MP\MX\Orders\Deliver $deliver File fields (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deliveryUpdatesRequest(
        string $purchaseOrderId,
        \Walmart\Models\MP\MX\Orders\Deliver $deliver,
    ): Request {
        $contentType = self::contentTypes['deliveryUpdates'];

        // verify the required parameter 'purchaseOrderId' is set
        if ($purchaseOrderId === null || (is_array($purchaseOrderId) && count($purchaseOrderId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $purchaseOrderId when calling deliveryUpdates'
            );
        }
        // verify the required parameter 'deliver' is set
        if ($deliver === null || (is_array($deliver) && count($deliver) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $deliver when calling deliveryUpdates'
            );
        }
        $resourcePath = '/v3/orders/{purchaseOrderId}/deliver';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $method = 'POST';

        // path params
        if ($purchaseOrderId !== null) {
            $resourcePath = str_replace(
                '{' . 'purchaseOrderId' . '}',
                ObjectSerializer::toPathValue($purchaseOrderId),
                $resourcePath
            );
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = parent::getDefaultHeaders();
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        // for model (json/xml)
        if (isset($deliver)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($deliver));
            } else {
                $httpBody = $deliver;
            }
        } else if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        $query = ObjectSerializer::buildQuery($queryParams);
        $requestInfo = [
            'path' => $resourcePath,
            'method' => $method,
            'timestamp' => $defaultHeaders['WM_SEC.TIMESTAMP'],
            'query' => $query,
        ];

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getClientId()) || !(empty($this->config->getClientSecret()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getClientId() . ":" . $this->config->getClientSecret());
        }

        // this endpoint requires Bearer authentication (access token)
        $token = $this->config->getAccessToken();
        if ($token) {
            $headers['WM_SEC.ACCESS_TOKEN'] = $token->accessToken;
        }

        $operationHost = $this->config->getHost();
        return new Request(
            $method,
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAllOrders
     *
     * Get all orders
     *
     * @param  string $createdStartDate Start Date for querying all purchase orders after this date. Use epoch time format in seconds. (optional, default to 'NOW-180DAYS')
     * @param  string $createdEndDate End Date for querying all purchase orders after this date. Use epoch time format in seconds. (optional, default to 'NOW')
     * @param  string $limit The number of orders to be returned. Cannot be greater than 100. (optional, default to '10')
     * @param  string $offset The starting offset of the first order required in the response. Cannot be greater than 1000 (optional, default to '0')
     * @param  string $customerOrderId The customer order ID. (optional)
     * @param  string $purchaseOrderId The purchase order ID. (optional)
     * @param  string $statusCodeFilter The status code filter to apply. Valid values will be Created, Acknowledged, Shipped, Cancelled, OnHold, Delivered. (optional)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Walmart\Models\MP\MX\Orders\WFSOrderResponse|\Walmart\Models\MP\MX\Orders\ErrorResponse|\Walmart\Models\MP\MX\Orders\ErrorResponse
     */
    public function getAllOrders(
        ?string $createdStartDate = 'NOW-180DAYS',
        ?string $createdEndDate = 'NOW',
        ?string $limit = '10',
        ?string $offset = '0',
        ?string $customerOrderId = null,
        ?string $purchaseOrderId = null,
        ?string $statusCodeFilter = null
    ): \Walmart\Models\MP\MX\Orders\WFSOrderResponse {
        return $this->getAllOrdersWithHttpInfo($createdStartDate, $createdEndDate, $limit, $offset, $customerOrderId, $purchaseOrderId, $statusCodeFilter);
    }

    /**
     * Operation getAllOrdersWithHttpInfo
     *
     * Get all orders
     *
     * @param  string $createdStartDate Start Date for querying all purchase orders after this date. Use epoch time format in seconds. (optional, default to 'NOW-180DAYS')
     * @param  string $createdEndDate End Date for querying all purchase orders after this date. Use epoch time format in seconds. (optional, default to 'NOW')
     * @param  string $limit The number of orders to be returned. Cannot be greater than 100. (optional, default to '10')
     * @param  string $offset The starting offset of the first order required in the response. Cannot be greater than 1000 (optional, default to '0')
     * @param  string $customerOrderId The customer order ID. (optional)
     * @param  string $purchaseOrderId The purchase order ID. (optional)
     * @param  string $statusCodeFilter The status code filter to apply. Valid values will be Created, Acknowledged, Shipped, Cancelled, OnHold, Delivered. (optional)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Walmart\Models\MP\MX\Orders\WFSOrderResponse|\Walmart\Models\MP\MX\Orders\ErrorResponse|\Walmart\Models\MP\MX\Orders\ErrorResponse
     */
    protected function getAllOrdersWithHttpInfo(
        ?string $createdStartDate = 'NOW-180DAYS',
        ?string $createdEndDate = 'NOW',
        ?string $limit = '10',
        ?string $offset = '0',
        ?string $customerOrderId = null,
        ?string $purchaseOrderId = null,
        ?string $statusCodeFilter = null,
    ): \Walmart\Models\MP\MX\Orders\WFSOrderResponse {
        $request = $this->getAllOrdersRequest($createdStartDate, $createdEndDate, $limit, $offset, $customerOrderId, $purchaseOrderId, $statusCodeFilter);
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
                $this->writeDebug($response);
                $this->writeDebug((string) $response->getBody());
            } catch (RequestException $e) {
                $hasResponse = !empty($e->hasResponse());
                $body = (string) ($hasResponse ? $e->getResponse()->getBody() : '[NULL response]');
                $this->writeDebug($e->getResponse());
                $this->writeDebug($body);

                throw new ApiException(
                    "[{$e->getCode()}] {$body}",
                    (int) $e->getCode(),
                    $hasResponse ? $e->getResponse()->getHeaders() : null,
                    $body
                );
            } catch (ConnectException $e) {
                $this->writeDebug($e->getMessage());

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }
            switch ($statusCode) {
                case 200:
                    if ('\Walmart\Models\MP\MX\Orders\WFSOrderResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        $contentType = $response->getHeader('Content-Type')[0] ?? '';
                        if ('\Walmart\Models\MP\MX\Orders\WFSOrderResponse' !== 'string') {
                            $content = $contentType === 'application/xml' ? simplexml_load_string($content) : json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, '\Walmart\Models\MP\MX\Orders\WFSOrderResponse', $response->getHeaders());
                case 400:
                    if ('\Walmart\Models\MP\MX\Orders\ErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        $contentType = $response->getHeader('Content-Type')[0] ?? '';
                        if ('\Walmart\Models\MP\MX\Orders\ErrorResponse' !== 'string') {
                            $content = $contentType === 'application/xml' ? simplexml_load_string($content) : json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, '\Walmart\Models\MP\MX\Orders\ErrorResponse', $response->getHeaders());
                case 500:
                    if ('\Walmart\Models\MP\MX\Orders\ErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        $contentType = $response->getHeader('Content-Type')[0] ?? '';
                        if ('\Walmart\Models\MP\MX\Orders\ErrorResponse' !== 'string') {
                            $content = $contentType === 'application/xml' ? simplexml_load_string($content) : json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, '\Walmart\Models\MP\MX\Orders\ErrorResponse', $response->getHeaders());
            }

            $returnType = '\Walmart\Models\MP\MX\Orders\WFSOrderResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                $contentType = $response->getHeader('Content-Type')[0] ?? '';
                if ($returnType !== 'string') {
                    $content = $contentType === 'application/xml' ? simplexml_load_string($content) : json_decode($content);
                }
            }

            return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Walmart\Models\MP\MX\Orders\WFSOrderResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Walmart\Models\MP\MX\Orders\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Walmart\Models\MP\MX\Orders\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }

            $this->writeDebug($e);
            throw $e;
        }
    }

    /**
     * Operation getAllOrdersAsync
     *
     * Get all orders
     *
     * @param  string $createdStartDate Start Date for querying all purchase orders after this date. Use epoch time format in seconds. (optional, default to 'NOW-180DAYS')
     * @param  string $createdEndDate End Date for querying all purchase orders after this date. Use epoch time format in seconds. (optional, default to 'NOW')
     * @param  string $limit The number of orders to be returned. Cannot be greater than 100. (optional, default to '10')
     * @param  string $offset The starting offset of the first order required in the response. Cannot be greater than 1000 (optional, default to '0')
     * @param  string $customerOrderId The customer order ID. (optional)
     * @param  string $purchaseOrderId The purchase order ID. (optional)
     * @param  string $statusCodeFilter The status code filter to apply. Valid values will be Created, Acknowledged, Shipped, Cancelled, OnHold, Delivered. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAllOrdersAsync(
        ?string $createdStartDate = 'NOW-180DAYS',
        ?string $createdEndDate = 'NOW',
        ?string $limit = '10',
        ?string $offset = '0',
        ?string $customerOrderId = null,
        ?string $purchaseOrderId = null,
        ?string $statusCodeFilter = null
    ): PromiseInterface {
        return $this->getAllOrdersAsyncWithHttpInfo($createdStartDate, $createdEndDate, $limit, $offset, $customerOrderId, $purchaseOrderId, $statusCodeFilter)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAllOrdersAsyncWithHttpInfo
     *
     * Get all orders
     *
     * @param  string $createdStartDate Start Date for querying all purchase orders after this date. Use epoch time format in seconds. (optional, default to 'NOW-180DAYS')
     * @param  string $createdEndDate End Date for querying all purchase orders after this date. Use epoch time format in seconds. (optional, default to 'NOW')
     * @param  string $limit The number of orders to be returned. Cannot be greater than 100. (optional, default to '10')
     * @param  string $offset The starting offset of the first order required in the response. Cannot be greater than 1000 (optional, default to '0')
     * @param  string $customerOrderId The customer order ID. (optional)
     * @param  string $purchaseOrderId The purchase order ID. (optional)
     * @param  string $statusCodeFilter The status code filter to apply. Valid values will be Created, Acknowledged, Shipped, Cancelled, OnHold, Delivered. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    protected function getAllOrdersAsyncWithHttpInfo(
        ?string $createdStartDate = 'NOW-180DAYS',
        ?string $createdEndDate = 'NOW',
        ?string $limit = '10',
        ?string $offset = '0',
        ?string $customerOrderId = null,
        ?string $purchaseOrderId = null,
        ?string $statusCodeFilter = null,
    ): PromiseInterface {
        $returnType = '\Walmart\Models\MP\MX\Orders\WFSOrderResponse';
        $request = $this->getAllOrdersRequest($createdStartDate, $createdEndDate, $limit, $offset, $customerOrderId, $purchaseOrderId, $statusCodeFilter);
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $this->writeDebug($response);
                    $this->writeDebug((string) $response->getBody());
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $hasResponse = !empty($response);
                    $body = (string) ($hasResponse ? $response->getBody() : '[NULL response]');
                    $this->writeDebug($response);
                    $statusCode = $hasResponse ? $response->getStatusCode() : $exception->getCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $body,
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAllOrders'
     *
     * @param  string $createdStartDate Start Date for querying all purchase orders after this date. Use epoch time format in seconds. (optional, default to 'NOW-180DAYS')
     * @param  string $createdEndDate End Date for querying all purchase orders after this date. Use epoch time format in seconds. (optional, default to 'NOW')
     * @param  string $limit The number of orders to be returned. Cannot be greater than 100. (optional, default to '10')
     * @param  string $offset The starting offset of the first order required in the response. Cannot be greater than 1000 (optional, default to '0')
     * @param  string $customerOrderId The customer order ID. (optional)
     * @param  string $purchaseOrderId The purchase order ID. (optional)
     * @param  string $statusCodeFilter The status code filter to apply. Valid values will be Created, Acknowledged, Shipped, Cancelled, OnHold, Delivered. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getAllOrdersRequest(
        ?string $createdStartDate = 'NOW-180DAYS',
        ?string $createdEndDate = 'NOW',
        ?string $limit = '10',
        ?string $offset = '0',
        ?string $customerOrderId = null,
        ?string $purchaseOrderId = null,
        ?string $statusCodeFilter = null,
    ): Request {
        $contentType = self::contentTypes['getAllOrders'];

        $resourcePath = '/v3/orders';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $method = 'GET';

        // query params
        $queryParams = array_merge(
            ObjectSerializer::toQueryValue(
                $createdStartDate,
                'createdStartDate', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? [],
            ObjectSerializer::toQueryValue(
                $createdEndDate,
                'createdEndDate', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? [],
            ObjectSerializer::toQueryValue(
                $limit,
                'limit', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? [],
            ObjectSerializer::toQueryValue(
                $offset,
                'offset', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? [],
            ObjectSerializer::toQueryValue(
                $customerOrderId,
                'customerOrderId', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? [],
            ObjectSerializer::toQueryValue(
                $purchaseOrderId,
                'purchaseOrderId', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? [],
            ObjectSerializer::toQueryValue(
                $statusCodeFilter,
                'statusCodeFilter', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? [],
        );

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = parent::getDefaultHeaders();
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        $query = ObjectSerializer::buildQuery($queryParams);
        $requestInfo = [
            'path' => $resourcePath,
            'method' => $method,
            'timestamp' => $defaultHeaders['WM_SEC.TIMESTAMP'],
            'query' => $query,
        ];

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getClientId()) || !(empty($this->config->getClientSecret()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getClientId() . ":" . $this->config->getClientSecret());
        }

        // this endpoint requires Bearer authentication (access token)
        $token = $this->config->getAccessToken();
        if ($token) {
            $headers['WM_SEC.ACCESS_TOKEN'] = $token->accessToken;
        }

        $operationHost = $this->config->getHost();
        return new Request(
            $method,
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAllOrdersUsingCursor
     *
     * Get all orders using cursor mark
     *
     * @param  string $statusCodeFilter The status code filter to apply. Valid values will be Created, Acknowledged, Shipped, Cancelled, OnHold, Delivered. (required)
     * @param  string $createdStartDate Start Date for querying all purchase orders after this date. Either both the createdStartDate, createdEndDate must be present in the query params or none present. If passed must be in the format - 'yyyy-MM-dd'T'HH:mm:ss.SSSXXX' (Ex. 2022-01-29T10:53:12.355-09:30 ). Use URI encoded time format. (optional, default to 'NOW-180DAYS')
     * @param  string $createdEndDate End Date for querying all purchase orders after this date. Either both the createdStartDate, createdEndDate must be present in the query params or none present. If passed must be in the format - 'yyyy-MM-dd'T'HH:mm:ss.SSSXXX' (Ex. 2022-03-29T16:43:12.355+05:30 ). Use URI encoded time format. (optional, default to 'NOW')
     * @param  string $limit The number of orders to be returned. Cannot be larger than 100. (optional, default to '10')
     * @param  string $cursorMark The cursor from which next set of records to be retrieved. (optional, default to '*')
     * @param  string $customerOrderId The customer order ID. (optional)
     * @param  string $purchaseOrderId The purchase order ID. (optional)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Walmart\Models\MP\MX\Orders\MxOrderWithCursor|\Walmart\Models\MP\MX\Orders\ErrorResponse|\Walmart\Models\MP\MX\Orders\ErrorResponse
     */
    public function getAllOrdersUsingCursor(
        string $statusCodeFilter,
        ?string $createdStartDate = 'NOW-180DAYS',
        ?string $createdEndDate = 'NOW',
        ?string $limit = '10',
        ?string $cursorMark = '*',
        ?string $customerOrderId = null,
        ?string $purchaseOrderId = null
    ): \Walmart\Models\MP\MX\Orders\MxOrderWithCursor {
        return $this->getAllOrdersUsingCursorWithHttpInfo($statusCodeFilter, $createdStartDate, $createdEndDate, $limit, $cursorMark, $customerOrderId, $purchaseOrderId);
    }

    /**
     * Operation getAllOrdersUsingCursorWithHttpInfo
     *
     * Get all orders using cursor mark
     *
     * @param  string $statusCodeFilter The status code filter to apply. Valid values will be Created, Acknowledged, Shipped, Cancelled, OnHold, Delivered. (required)
     * @param  string $createdStartDate Start Date for querying all purchase orders after this date. Either both the createdStartDate, createdEndDate must be present in the query params or none present. If passed must be in the format - 'yyyy-MM-dd'T'HH:mm:ss.SSSXXX' (Ex. 2022-01-29T10:53:12.355-09:30 ). Use URI encoded time format. (optional, default to 'NOW-180DAYS')
     * @param  string $createdEndDate End Date for querying all purchase orders after this date. Either both the createdStartDate, createdEndDate must be present in the query params or none present. If passed must be in the format - 'yyyy-MM-dd'T'HH:mm:ss.SSSXXX' (Ex. 2022-03-29T16:43:12.355+05:30 ). Use URI encoded time format. (optional, default to 'NOW')
     * @param  string $limit The number of orders to be returned. Cannot be larger than 100. (optional, default to '10')
     * @param  string $cursorMark The cursor from which next set of records to be retrieved. (optional, default to '*')
     * @param  string $customerOrderId The customer order ID. (optional)
     * @param  string $purchaseOrderId The purchase order ID. (optional)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Walmart\Models\MP\MX\Orders\MxOrderWithCursor|\Walmart\Models\MP\MX\Orders\ErrorResponse|\Walmart\Models\MP\MX\Orders\ErrorResponse
     */
    protected function getAllOrdersUsingCursorWithHttpInfo(
        string $statusCodeFilter,
        ?string $createdStartDate = 'NOW-180DAYS',
        ?string $createdEndDate = 'NOW',
        ?string $limit = '10',
        ?string $cursorMark = '*',
        ?string $customerOrderId = null,
        ?string $purchaseOrderId = null,
    ): \Walmart\Models\MP\MX\Orders\MxOrderWithCursor {
        $request = $this->getAllOrdersUsingCursorRequest($statusCodeFilter, $createdStartDate, $createdEndDate, $limit, $cursorMark, $customerOrderId, $purchaseOrderId);
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
                $this->writeDebug($response);
                $this->writeDebug((string) $response->getBody());
            } catch (RequestException $e) {
                $hasResponse = !empty($e->hasResponse());
                $body = (string) ($hasResponse ? $e->getResponse()->getBody() : '[NULL response]');
                $this->writeDebug($e->getResponse());
                $this->writeDebug($body);

                throw new ApiException(
                    "[{$e->getCode()}] {$body}",
                    (int) $e->getCode(),
                    $hasResponse ? $e->getResponse()->getHeaders() : null,
                    $body
                );
            } catch (ConnectException $e) {
                $this->writeDebug($e->getMessage());

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }
            switch ($statusCode) {
                case 200:
                    if ('\Walmart\Models\MP\MX\Orders\MxOrderWithCursor' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        $contentType = $response->getHeader('Content-Type')[0] ?? '';
                        if ('\Walmart\Models\MP\MX\Orders\MxOrderWithCursor' !== 'string') {
                            $content = $contentType === 'application/xml' ? simplexml_load_string($content) : json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, '\Walmart\Models\MP\MX\Orders\MxOrderWithCursor', $response->getHeaders());
                case 400:
                    if ('\Walmart\Models\MP\MX\Orders\ErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        $contentType = $response->getHeader('Content-Type')[0] ?? '';
                        if ('\Walmart\Models\MP\MX\Orders\ErrorResponse' !== 'string') {
                            $content = $contentType === 'application/xml' ? simplexml_load_string($content) : json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, '\Walmart\Models\MP\MX\Orders\ErrorResponse', $response->getHeaders());
                case 500:
                    if ('\Walmart\Models\MP\MX\Orders\ErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        $contentType = $response->getHeader('Content-Type')[0] ?? '';
                        if ('\Walmart\Models\MP\MX\Orders\ErrorResponse' !== 'string') {
                            $content = $contentType === 'application/xml' ? simplexml_load_string($content) : json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, '\Walmart\Models\MP\MX\Orders\ErrorResponse', $response->getHeaders());
            }

            $returnType = '\Walmart\Models\MP\MX\Orders\MxOrderWithCursor';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                $contentType = $response->getHeader('Content-Type')[0] ?? '';
                if ($returnType !== 'string') {
                    $content = $contentType === 'application/xml' ? simplexml_load_string($content) : json_decode($content);
                }
            }

            return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Walmart\Models\MP\MX\Orders\MxOrderWithCursor',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Walmart\Models\MP\MX\Orders\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Walmart\Models\MP\MX\Orders\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }

            $this->writeDebug($e);
            throw $e;
        }
    }

    /**
     * Operation getAllOrdersUsingCursorAsync
     *
     * Get all orders using cursor mark
     *
     * @param  string $statusCodeFilter The status code filter to apply. Valid values will be Created, Acknowledged, Shipped, Cancelled, OnHold, Delivered. (required)
     * @param  string $createdStartDate Start Date for querying all purchase orders after this date. Either both the createdStartDate, createdEndDate must be present in the query params or none present. If passed must be in the format - 'yyyy-MM-dd'T'HH:mm:ss.SSSXXX' (Ex. 2022-01-29T10:53:12.355-09:30 ). Use URI encoded time format. (optional, default to 'NOW-180DAYS')
     * @param  string $createdEndDate End Date for querying all purchase orders after this date. Either both the createdStartDate, createdEndDate must be present in the query params or none present. If passed must be in the format - 'yyyy-MM-dd'T'HH:mm:ss.SSSXXX' (Ex. 2022-03-29T16:43:12.355+05:30 ). Use URI encoded time format. (optional, default to 'NOW')
     * @param  string $limit The number of orders to be returned. Cannot be larger than 100. (optional, default to '10')
     * @param  string $cursorMark The cursor from which next set of records to be retrieved. (optional, default to '*')
     * @param  string $customerOrderId The customer order ID. (optional)
     * @param  string $purchaseOrderId The purchase order ID. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAllOrdersUsingCursorAsync(
        string $statusCodeFilter,
        ?string $createdStartDate = 'NOW-180DAYS',
        ?string $createdEndDate = 'NOW',
        ?string $limit = '10',
        ?string $cursorMark = '*',
        ?string $customerOrderId = null,
        ?string $purchaseOrderId = null
    ): PromiseInterface {
        return $this->getAllOrdersUsingCursorAsyncWithHttpInfo($statusCodeFilter, $createdStartDate, $createdEndDate, $limit, $cursorMark, $customerOrderId, $purchaseOrderId)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAllOrdersUsingCursorAsyncWithHttpInfo
     *
     * Get all orders using cursor mark
     *
     * @param  string $statusCodeFilter The status code filter to apply. Valid values will be Created, Acknowledged, Shipped, Cancelled, OnHold, Delivered. (required)
     * @param  string $createdStartDate Start Date for querying all purchase orders after this date. Either both the createdStartDate, createdEndDate must be present in the query params or none present. If passed must be in the format - 'yyyy-MM-dd'T'HH:mm:ss.SSSXXX' (Ex. 2022-01-29T10:53:12.355-09:30 ). Use URI encoded time format. (optional, default to 'NOW-180DAYS')
     * @param  string $createdEndDate End Date for querying all purchase orders after this date. Either both the createdStartDate, createdEndDate must be present in the query params or none present. If passed must be in the format - 'yyyy-MM-dd'T'HH:mm:ss.SSSXXX' (Ex. 2022-03-29T16:43:12.355+05:30 ). Use URI encoded time format. (optional, default to 'NOW')
     * @param  string $limit The number of orders to be returned. Cannot be larger than 100. (optional, default to '10')
     * @param  string $cursorMark The cursor from which next set of records to be retrieved. (optional, default to '*')
     * @param  string $customerOrderId The customer order ID. (optional)
     * @param  string $purchaseOrderId The purchase order ID. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    protected function getAllOrdersUsingCursorAsyncWithHttpInfo(
        string $statusCodeFilter,
        ?string $createdStartDate = 'NOW-180DAYS',
        ?string $createdEndDate = 'NOW',
        ?string $limit = '10',
        ?string $cursorMark = '*',
        ?string $customerOrderId = null,
        ?string $purchaseOrderId = null,
    ): PromiseInterface {
        $returnType = '\Walmart\Models\MP\MX\Orders\MxOrderWithCursor';
        $request = $this->getAllOrdersUsingCursorRequest($statusCodeFilter, $createdStartDate, $createdEndDate, $limit, $cursorMark, $customerOrderId, $purchaseOrderId);
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $this->writeDebug($response);
                    $this->writeDebug((string) $response->getBody());
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $hasResponse = !empty($response);
                    $body = (string) ($hasResponse ? $response->getBody() : '[NULL response]');
                    $this->writeDebug($response);
                    $statusCode = $hasResponse ? $response->getStatusCode() : $exception->getCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $body,
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAllOrdersUsingCursor'
     *
     * @param  string $statusCodeFilter The status code filter to apply. Valid values will be Created, Acknowledged, Shipped, Cancelled, OnHold, Delivered. (required)
     * @param  string $createdStartDate Start Date for querying all purchase orders after this date. Either both the createdStartDate, createdEndDate must be present in the query params or none present. If passed must be in the format - 'yyyy-MM-dd'T'HH:mm:ss.SSSXXX' (Ex. 2022-01-29T10:53:12.355-09:30 ). Use URI encoded time format. (optional, default to 'NOW-180DAYS')
     * @param  string $createdEndDate End Date for querying all purchase orders after this date. Either both the createdStartDate, createdEndDate must be present in the query params or none present. If passed must be in the format - 'yyyy-MM-dd'T'HH:mm:ss.SSSXXX' (Ex. 2022-03-29T16:43:12.355+05:30 ). Use URI encoded time format. (optional, default to 'NOW')
     * @param  string $limit The number of orders to be returned. Cannot be larger than 100. (optional, default to '10')
     * @param  string $cursorMark The cursor from which next set of records to be retrieved. (optional, default to '*')
     * @param  string $customerOrderId The customer order ID. (optional)
     * @param  string $purchaseOrderId The purchase order ID. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getAllOrdersUsingCursorRequest(
        string $statusCodeFilter,
        ?string $createdStartDate = 'NOW-180DAYS',
        ?string $createdEndDate = 'NOW',
        ?string $limit = '10',
        ?string $cursorMark = '*',
        ?string $customerOrderId = null,
        ?string $purchaseOrderId = null,
    ): Request {
        $contentType = self::contentTypes['getAllOrdersUsingCursor'];

        // verify the required parameter 'statusCodeFilter' is set
        if ($statusCodeFilter === null || (is_array($statusCodeFilter) && count($statusCodeFilter) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $statusCodeFilter when calling getAllOrdersUsingCursor'
            );
        }
        $resourcePath = '/v3/orders/cursor';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $method = 'GET';

        // query params
        $queryParams = array_merge(
            ObjectSerializer::toQueryValue(
                $createdStartDate,
                'createdStartDate', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? [],
            ObjectSerializer::toQueryValue(
                $createdEndDate,
                'createdEndDate', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? [],
            ObjectSerializer::toQueryValue(
                $limit,
                'limit', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? [],
            ObjectSerializer::toQueryValue(
                $cursorMark,
                'cursorMark', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? [],
            ObjectSerializer::toQueryValue(
                $customerOrderId,
                'customerOrderId', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? [],
            ObjectSerializer::toQueryValue(
                $purchaseOrderId,
                'purchaseOrderId', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? [],
            ObjectSerializer::toQueryValue(
                $statusCodeFilter,
                'statusCodeFilter', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                true // required
            ) ?? [],
        );

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = parent::getDefaultHeaders();
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        $query = ObjectSerializer::buildQuery($queryParams);
        $requestInfo = [
            'path' => $resourcePath,
            'method' => $method,
            'timestamp' => $defaultHeaders['WM_SEC.TIMESTAMP'],
            'query' => $query,
        ];

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getClientId()) || !(empty($this->config->getClientSecret()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getClientId() . ":" . $this->config->getClientSecret());
        }

        // this endpoint requires Bearer authentication (access token)
        $token = $this->config->getAccessToken();
        if ($token) {
            $headers['WM_SEC.ACCESS_TOKEN'] = $token->accessToken;
        }

        $operationHost = $this->config->getHost();
        return new Request(
            $method,
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAllWFSOrders
     *
     * Get all WFS orders
     *
     * @param  string $createdStartDate Start Date for querying all purchase orders after this date. Use epoch time format in seconds. (optional)
     * @param  string $createdEndDate End Date for querying all purchase orders after this date. Use epoch time format in seconds. (optional)
     * @param  string $limit The number of orders to be returned. Cannot be larger than 200. (optional, default to '10')
     * @param  string $offset The starting offset of the first order required in the response. (optional, default to '0')
     * @param  string $customerOrderId The customer order ID. (optional, default to '0')
     * @param  string $statusCodeFilter The status code filter to apply. Valid values will be Created, SentForFulfillment, Shipped, Cancelled, Delivered (optional)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Walmart\Models\MP\MX\Orders\WFSOrderResponse
     */
    public function getAllWFSOrders(
        ?string $createdStartDate = null,
        ?string $createdEndDate = null,
        ?string $limit = '10',
        ?string $offset = '0',
        ?string $customerOrderId = '0',
        ?string $statusCodeFilter = null
    ): \Walmart\Models\MP\MX\Orders\WFSOrderResponse {
        return $this->getAllWFSOrdersWithHttpInfo($createdStartDate, $createdEndDate, $limit, $offset, $customerOrderId, $statusCodeFilter);
    }

    /**
     * Operation getAllWFSOrdersWithHttpInfo
     *
     * Get all WFS orders
     *
     * @param  string $createdStartDate Start Date for querying all purchase orders after this date. Use epoch time format in seconds. (optional)
     * @param  string $createdEndDate End Date for querying all purchase orders after this date. Use epoch time format in seconds. (optional)
     * @param  string $limit The number of orders to be returned. Cannot be larger than 200. (optional, default to '10')
     * @param  string $offset The starting offset of the first order required in the response. (optional, default to '0')
     * @param  string $customerOrderId The customer order ID. (optional, default to '0')
     * @param  string $statusCodeFilter The status code filter to apply. Valid values will be Created, SentForFulfillment, Shipped, Cancelled, Delivered (optional)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Walmart\Models\MP\MX\Orders\WFSOrderResponse
     */
    protected function getAllWFSOrdersWithHttpInfo(
        ?string $createdStartDate = null,
        ?string $createdEndDate = null,
        ?string $limit = '10',
        ?string $offset = '0',
        ?string $customerOrderId = '0',
        ?string $statusCodeFilter = null,
    ): \Walmart\Models\MP\MX\Orders\WFSOrderResponse {
        $request = $this->getAllWFSOrdersRequest($createdStartDate, $createdEndDate, $limit, $offset, $customerOrderId, $statusCodeFilter);
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
                $this->writeDebug($response);
                $this->writeDebug((string) $response->getBody());
            } catch (RequestException $e) {
                $hasResponse = !empty($e->hasResponse());
                $body = (string) ($hasResponse ? $e->getResponse()->getBody() : '[NULL response]');
                $this->writeDebug($e->getResponse());
                $this->writeDebug($body);

                throw new ApiException(
                    "[{$e->getCode()}] {$body}",
                    (int) $e->getCode(),
                    $hasResponse ? $e->getResponse()->getHeaders() : null,
                    $body
                );
            } catch (ConnectException $e) {
                $this->writeDebug($e->getMessage());

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }
            switch ($statusCode) {
                case 200:
                    if ('\Walmart\Models\MP\MX\Orders\WFSOrderResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        $contentType = $response->getHeader('Content-Type')[0] ?? '';
                        if ('\Walmart\Models\MP\MX\Orders\WFSOrderResponse' !== 'string') {
                            $content = $contentType === 'application/xml' ? simplexml_load_string($content) : json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, '\Walmart\Models\MP\MX\Orders\WFSOrderResponse', $response->getHeaders());
            }

            $returnType = '\Walmart\Models\MP\MX\Orders\WFSOrderResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                $contentType = $response->getHeader('Content-Type')[0] ?? '';
                if ($returnType !== 'string') {
                    $content = $contentType === 'application/xml' ? simplexml_load_string($content) : json_decode($content);
                }
            }

            return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Walmart\Models\MP\MX\Orders\WFSOrderResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }

            $this->writeDebug($e);
            throw $e;
        }
    }

    /**
     * Operation getAllWFSOrdersAsync
     *
     * Get all WFS orders
     *
     * @param  string $createdStartDate Start Date for querying all purchase orders after this date. Use epoch time format in seconds. (optional)
     * @param  string $createdEndDate End Date for querying all purchase orders after this date. Use epoch time format in seconds. (optional)
     * @param  string $limit The number of orders to be returned. Cannot be larger than 200. (optional, default to '10')
     * @param  string $offset The starting offset of the first order required in the response. (optional, default to '0')
     * @param  string $customerOrderId The customer order ID. (optional, default to '0')
     * @param  string $statusCodeFilter The status code filter to apply. Valid values will be Created, SentForFulfillment, Shipped, Cancelled, Delivered (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAllWFSOrdersAsync(
        ?string $createdStartDate = null,
        ?string $createdEndDate = null,
        ?string $limit = '10',
        ?string $offset = '0',
        ?string $customerOrderId = '0',
        ?string $statusCodeFilter = null
    ): PromiseInterface {
        return $this->getAllWFSOrdersAsyncWithHttpInfo($createdStartDate, $createdEndDate, $limit, $offset, $customerOrderId, $statusCodeFilter)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAllWFSOrdersAsyncWithHttpInfo
     *
     * Get all WFS orders
     *
     * @param  string $createdStartDate Start Date for querying all purchase orders after this date. Use epoch time format in seconds. (optional)
     * @param  string $createdEndDate End Date for querying all purchase orders after this date. Use epoch time format in seconds. (optional)
     * @param  string $limit The number of orders to be returned. Cannot be larger than 200. (optional, default to '10')
     * @param  string $offset The starting offset of the first order required in the response. (optional, default to '0')
     * @param  string $customerOrderId The customer order ID. (optional, default to '0')
     * @param  string $statusCodeFilter The status code filter to apply. Valid values will be Created, SentForFulfillment, Shipped, Cancelled, Delivered (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    protected function getAllWFSOrdersAsyncWithHttpInfo(
        ?string $createdStartDate = null,
        ?string $createdEndDate = null,
        ?string $limit = '10',
        ?string $offset = '0',
        ?string $customerOrderId = '0',
        ?string $statusCodeFilter = null,
    ): PromiseInterface {
        $returnType = '\Walmart\Models\MP\MX\Orders\WFSOrderResponse';
        $request = $this->getAllWFSOrdersRequest($createdStartDate, $createdEndDate, $limit, $offset, $customerOrderId, $statusCodeFilter);
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $this->writeDebug($response);
                    $this->writeDebug((string) $response->getBody());
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $hasResponse = !empty($response);
                    $body = (string) ($hasResponse ? $response->getBody() : '[NULL response]');
                    $this->writeDebug($response);
                    $statusCode = $hasResponse ? $response->getStatusCode() : $exception->getCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $body,
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAllWFSOrders'
     *
     * @param  string $createdStartDate Start Date for querying all purchase orders after this date. Use epoch time format in seconds. (optional)
     * @param  string $createdEndDate End Date for querying all purchase orders after this date. Use epoch time format in seconds. (optional)
     * @param  string $limit The number of orders to be returned. Cannot be larger than 200. (optional, default to '10')
     * @param  string $offset The starting offset of the first order required in the response. (optional, default to '0')
     * @param  string $customerOrderId The customer order ID. (optional, default to '0')
     * @param  string $statusCodeFilter The status code filter to apply. Valid values will be Created, SentForFulfillment, Shipped, Cancelled, Delivered (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getAllWFSOrdersRequest(
        ?string $createdStartDate = null,
        ?string $createdEndDate = null,
        ?string $limit = '10',
        ?string $offset = '0',
        ?string $customerOrderId = '0',
        ?string $statusCodeFilter = null,
    ): Request {
        $contentType = self::contentTypes['getAllWFSOrders'];

        $resourcePath = '/v3/orders/wfsorders';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $method = 'GET';

        // query params
        $queryParams = array_merge(
            ObjectSerializer::toQueryValue(
                $createdStartDate,
                'createdStartDate', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? [],
            ObjectSerializer::toQueryValue(
                $createdEndDate,
                'createdEndDate', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? [],
            ObjectSerializer::toQueryValue(
                $limit,
                'limit', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? [],
            ObjectSerializer::toQueryValue(
                $offset,
                'offset', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? [],
            ObjectSerializer::toQueryValue(
                $customerOrderId,
                'customerOrderId', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? [],
            ObjectSerializer::toQueryValue(
                $statusCodeFilter,
                'statusCodeFilter', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? [],
        );

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = parent::getDefaultHeaders();
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        $query = ObjectSerializer::buildQuery($queryParams);
        $requestInfo = [
            'path' => $resourcePath,
            'method' => $method,
            'timestamp' => $defaultHeaders['WM_SEC.TIMESTAMP'],
            'query' => $query,
        ];

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getClientId()) || !(empty($this->config->getClientSecret()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getClientId() . ":" . $this->config->getClientSecret());
        }

        // this endpoint requires Bearer authentication (access token)
        $token = $this->config->getAccessToken();
        if ($token) {
            $headers['WM_SEC.ACCESS_TOKEN'] = $token->accessToken;
        }

        $operationHost = $this->config->getHost();
        return new Request(
            $method,
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getShippingLabel
     *
     * Get Shipping Label
     *
     * @param  string $trackingNumber trackingNumber (required)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string|\Walmart\Models\MP\MX\Orders\ErrorResponse|\Walmart\Models\MP\MX\Orders\ErrorResponse
     */
    public function getShippingLabel(
        string $trackingNumber
    ): string {
        return $this->getShippingLabelWithHttpInfo($trackingNumber);
    }

    /**
     * Operation getShippingLabelWithHttpInfo
     *
     * Get Shipping Label
     *
     * @param  string $trackingNumber trackingNumber (required)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string|\Walmart\Models\MP\MX\Orders\ErrorResponse|\Walmart\Models\MP\MX\Orders\ErrorResponse
     */
    protected function getShippingLabelWithHttpInfo(
        string $trackingNumber,
    ): string {
        $request = $this->getShippingLabelRequest($trackingNumber);
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
                $this->writeDebug($response);
                $this->writeDebug((string) $response->getBody());
            } catch (RequestException $e) {
                $hasResponse = !empty($e->hasResponse());
                $body = (string) ($hasResponse ? $e->getResponse()->getBody() : '[NULL response]');
                $this->writeDebug($e->getResponse());
                $this->writeDebug($body);

                throw new ApiException(
                    "[{$e->getCode()}] {$body}",
                    (int) $e->getCode(),
                    $hasResponse ? $e->getResponse()->getHeaders() : null,
                    $body
                );
            } catch (ConnectException $e) {
                $this->writeDebug($e->getMessage());

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }
            switch ($statusCode) {
                case 200:
                    if ('string' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        $contentType = $response->getHeader('Content-Type')[0] ?? '';
                        if ('string' !== 'string') {
                            $content = $contentType === 'application/xml' ? simplexml_load_string($content) : json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, 'string', $response->getHeaders());
                case 400:
                    if ('\Walmart\Models\MP\MX\Orders\ErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        $contentType = $response->getHeader('Content-Type')[0] ?? '';
                        if ('\Walmart\Models\MP\MX\Orders\ErrorResponse' !== 'string') {
                            $content = $contentType === 'application/xml' ? simplexml_load_string($content) : json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, '\Walmart\Models\MP\MX\Orders\ErrorResponse', $response->getHeaders());
                case 500:
                    if ('\Walmart\Models\MP\MX\Orders\ErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        $contentType = $response->getHeader('Content-Type')[0] ?? '';
                        if ('\Walmart\Models\MP\MX\Orders\ErrorResponse' !== 'string') {
                            $content = $contentType === 'application/xml' ? simplexml_load_string($content) : json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, '\Walmart\Models\MP\MX\Orders\ErrorResponse', $response->getHeaders());
            }

            $returnType = 'string';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                $contentType = $response->getHeader('Content-Type')[0] ?? '';
                if ($returnType !== 'string') {
                    $content = $contentType === 'application/xml' ? simplexml_load_string($content) : json_decode($content);
                }
            }

            return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Walmart\Models\MP\MX\Orders\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Walmart\Models\MP\MX\Orders\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }

            $this->writeDebug($e);
            throw $e;
        }
    }

    /**
     * Operation getShippingLabelAsync
     *
     * Get Shipping Label
     *
     * @param  string $trackingNumber trackingNumber (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getShippingLabelAsync(
        string $trackingNumber
    ): PromiseInterface {
        return $this->getShippingLabelAsyncWithHttpInfo($trackingNumber)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getShippingLabelAsyncWithHttpInfo
     *
     * Get Shipping Label
     *
     * @param  string $trackingNumber trackingNumber (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    protected function getShippingLabelAsyncWithHttpInfo(
        string $trackingNumber,
    ): PromiseInterface {
        $returnType = 'string';
        $request = $this->getShippingLabelRequest($trackingNumber);
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $this->writeDebug($response);
                    $this->writeDebug((string) $response->getBody());
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $hasResponse = !empty($response);
                    $body = (string) ($hasResponse ? $response->getBody() : '[NULL response]');
                    $this->writeDebug($response);
                    $statusCode = $hasResponse ? $response->getStatusCode() : $exception->getCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $body,
                    );
                }
            );
    }

    /**
     * Create request for operation 'getShippingLabel'
     *
     * @param  string $trackingNumber trackingNumber (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getShippingLabelRequest(
        string $trackingNumber,
    ): Request {
        $contentType = self::contentTypes['getShippingLabel'];

        // verify the required parameter 'trackingNumber' is set
        if ($trackingNumber === null || (is_array($trackingNumber) && count($trackingNumber) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $trackingNumber when calling getShippingLabel'
            );
        }
        $resourcePath = '/v3/orders/label/{trackingNumber}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $method = 'GET';

        // path params
        if ($trackingNumber !== null) {
            $resourcePath = str_replace(
                '{' . 'trackingNumber' . '}',
                ObjectSerializer::toPathValue($trackingNumber),
                $resourcePath
            );
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/octet-stream', 'application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = parent::getDefaultHeaders();
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        $query = ObjectSerializer::buildQuery($queryParams);
        $requestInfo = [
            'path' => $resourcePath,
            'method' => $method,
            'timestamp' => $defaultHeaders['WM_SEC.TIMESTAMP'],
            'query' => $query,
        ];

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getClientId()) || !(empty($this->config->getClientSecret()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getClientId() . ":" . $this->config->getClientSecret());
        }

        // this endpoint requires Bearer authentication (access token)
        $token = $this->config->getAccessToken();
        if ($token) {
            $headers['WM_SEC.ACCESS_TOKEN'] = $token->accessToken;
        }

        $operationHost = $this->config->getHost();
        return new Request(
            $method,
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postBulkShippingLabel
     *
     * Bulk Shipping Label
     *
     * @param  \Walmart\Models\MP\MX\Orders\ShippingLabelRequest $shippingLabelRequest Request body with list of tracking numbers (required)
     * @param  string $fORMAT format in which you want to download bulk labels, expected values are ZIP/ PDF only (optional, default to 'ZIP')
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string|mixed|\Walmart\Models\MP\MX\Orders\ErrorResponse
     */
    public function postBulkShippingLabel(
        \Walmart\Models\MP\MX\Orders\ShippingLabelRequest $shippingLabelRequest,
        ?string $fORMAT = 'ZIP'
    ): string {
        return $this->postBulkShippingLabelWithHttpInfo($shippingLabelRequest, $fORMAT);
    }

    /**
     * Operation postBulkShippingLabelWithHttpInfo
     *
     * Bulk Shipping Label
     *
     * @param  \Walmart\Models\MP\MX\Orders\ShippingLabelRequest $shippingLabelRequest Request body with list of tracking numbers (required)
     * @param  string $fORMAT format in which you want to download bulk labels, expected values are ZIP/ PDF only (optional, default to 'ZIP')
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string|mixed|\Walmart\Models\MP\MX\Orders\ErrorResponse
     */
    protected function postBulkShippingLabelWithHttpInfo(
        \Walmart\Models\MP\MX\Orders\ShippingLabelRequest $shippingLabelRequest,
        ?string $fORMAT = 'ZIP',
    ): string {
        $request = $this->postBulkShippingLabelRequest($shippingLabelRequest, $fORMAT);
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
                $this->writeDebug($response);
                $this->writeDebug((string) $response->getBody());
            } catch (RequestException $e) {
                $hasResponse = !empty($e->hasResponse());
                $body = (string) ($hasResponse ? $e->getResponse()->getBody() : '[NULL response]');
                $this->writeDebug($e->getResponse());
                $this->writeDebug($body);

                throw new ApiException(
                    "[{$e->getCode()}] {$body}",
                    (int) $e->getCode(),
                    $hasResponse ? $e->getResponse()->getHeaders() : null,
                    $body
                );
            } catch (ConnectException $e) {
                $this->writeDebug($e->getMessage());

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }
            switch ($statusCode) {
                case 200:
                    if ('string' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        $contentType = $response->getHeader('Content-Type')[0] ?? '';
                        if ('string' !== 'string') {
                            $content = $contentType === 'application/xml' ? simplexml_load_string($content) : json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, 'string', $response->getHeaders());
                case 400:
                    if ('mixed' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        $contentType = $response->getHeader('Content-Type')[0] ?? '';
                        if ('mixed' !== 'string') {
                            $content = $contentType === 'application/xml' ? simplexml_load_string($content) : json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, 'mixed', $response->getHeaders());
                case 500:
                    if ('\Walmart\Models\MP\MX\Orders\ErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        $contentType = $response->getHeader('Content-Type')[0] ?? '';
                        if ('\Walmart\Models\MP\MX\Orders\ErrorResponse' !== 'string') {
                            $content = $contentType === 'application/xml' ? simplexml_load_string($content) : json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, '\Walmart\Models\MP\MX\Orders\ErrorResponse', $response->getHeaders());
            }

            $returnType = 'string';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                $contentType = $response->getHeader('Content-Type')[0] ?? '';
                if ($returnType !== 'string') {
                    $content = $contentType === 'application/xml' ? simplexml_load_string($content) : json_decode($content);
                }
            }

            return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'mixed',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Walmart\Models\MP\MX\Orders\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }

            $this->writeDebug($e);
            throw $e;
        }
    }

    /**
     * Operation postBulkShippingLabelAsync
     *
     * Bulk Shipping Label
     *
     * @param  \Walmart\Models\MP\MX\Orders\ShippingLabelRequest $shippingLabelRequest Request body with list of tracking numbers (required)
     * @param  string $fORMAT format in which you want to download bulk labels, expected values are ZIP/ PDF only (optional, default to 'ZIP')
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postBulkShippingLabelAsync(
        \Walmart\Models\MP\MX\Orders\ShippingLabelRequest $shippingLabelRequest,
        ?string $fORMAT = 'ZIP'
    ): PromiseInterface {
        return $this->postBulkShippingLabelAsyncWithHttpInfo($shippingLabelRequest, $fORMAT)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postBulkShippingLabelAsyncWithHttpInfo
     *
     * Bulk Shipping Label
     *
     * @param  \Walmart\Models\MP\MX\Orders\ShippingLabelRequest $shippingLabelRequest Request body with list of tracking numbers (required)
     * @param  string $fORMAT format in which you want to download bulk labels, expected values are ZIP/ PDF only (optional, default to 'ZIP')
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    protected function postBulkShippingLabelAsyncWithHttpInfo(
        \Walmart\Models\MP\MX\Orders\ShippingLabelRequest $shippingLabelRequest,
        ?string $fORMAT = 'ZIP',
    ): PromiseInterface {
        $returnType = 'string';
        $request = $this->postBulkShippingLabelRequest($shippingLabelRequest, $fORMAT);
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $this->writeDebug($response);
                    $this->writeDebug((string) $response->getBody());
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $hasResponse = !empty($response);
                    $body = (string) ($hasResponse ? $response->getBody() : '[NULL response]');
                    $this->writeDebug($response);
                    $statusCode = $hasResponse ? $response->getStatusCode() : $exception->getCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $body,
                    );
                }
            );
    }

    /**
     * Create request for operation 'postBulkShippingLabel'
     *
     * @param  \Walmart\Models\MP\MX\Orders\ShippingLabelRequest $shippingLabelRequest Request body with list of tracking numbers (required)
     * @param  string $fORMAT format in which you want to download bulk labels, expected values are ZIP/ PDF only (optional, default to 'ZIP')
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function postBulkShippingLabelRequest(
        \Walmart\Models\MP\MX\Orders\ShippingLabelRequest $shippingLabelRequest,
        ?string $fORMAT = 'ZIP',
    ): Request {
        $contentType = self::contentTypes['postBulkShippingLabel'];

        // verify the required parameter 'shippingLabelRequest' is set
        if ($shippingLabelRequest === null || (is_array($shippingLabelRequest) && count($shippingLabelRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $shippingLabelRequest when calling postBulkShippingLabel'
            );
        }
        $resourcePath = '/v3/orders/labels';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $method = 'POST';

        // header params
        if ($fORMAT !== null) {
            $headerParams['FORMAT'] = ObjectSerializer::toHeaderValue($fORMAT);
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/octet-stream', 'application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = parent::getDefaultHeaders();
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        // for model (json/xml)
        if (isset($shippingLabelRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($shippingLabelRequest));
            } else {
                $httpBody = $shippingLabelRequest;
            }
        } else if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        $query = ObjectSerializer::buildQuery($queryParams);
        $requestInfo = [
            'path' => $resourcePath,
            'method' => $method,
            'timestamp' => $defaultHeaders['WM_SEC.TIMESTAMP'],
            'query' => $query,
        ];

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getClientId()) || !(empty($this->config->getClientSecret()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getClientId() . ":" . $this->config->getClientSecret());
        }

        // this endpoint requires Bearer authentication (access token)
        $token = $this->config->getAccessToken();
        if ($token) {
            $headers['WM_SEC.ACCESS_TOKEN'] = $token->accessToken;
        }

        $operationHost = $this->config->getHost();
        return new Request(
            $method,
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation shippingUpdates
     *
     * Shipping Updates
     *
     * @param  string $purchaseOrderId purchaseOrderId (required)
     * @param  \Walmart\Models\MP\MX\Orders\ShipmentMx $shipmentMx File fields (required)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string|\Walmart\Models\MP\MX\Orders\ErrorResponse|\Walmart\Models\MP\MX\Orders\ErrorResponse
     */
    public function shippingUpdates(
        string $purchaseOrderId,
        \Walmart\Models\MP\MX\Orders\ShipmentMx $shipmentMx
    ): string {
        return $this->shippingUpdatesWithHttpInfo($purchaseOrderId, $shipmentMx);
    }

    /**
     * Operation shippingUpdatesWithHttpInfo
     *
     * Shipping Updates
     *
     * @param  string $purchaseOrderId purchaseOrderId (required)
     * @param  \Walmart\Models\MP\MX\Orders\ShipmentMx $shipmentMx File fields (required)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string|\Walmart\Models\MP\MX\Orders\ErrorResponse|\Walmart\Models\MP\MX\Orders\ErrorResponse
     */
    protected function shippingUpdatesWithHttpInfo(
        string $purchaseOrderId,
        \Walmart\Models\MP\MX\Orders\ShipmentMx $shipmentMx,
    ): string {
        $request = $this->shippingUpdatesRequest($purchaseOrderId, $shipmentMx);
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
                $this->writeDebug($response);
                $this->writeDebug((string) $response->getBody());
            } catch (RequestException $e) {
                $hasResponse = !empty($e->hasResponse());
                $body = (string) ($hasResponse ? $e->getResponse()->getBody() : '[NULL response]');
                $this->writeDebug($e->getResponse());
                $this->writeDebug($body);

                throw new ApiException(
                    "[{$e->getCode()}] {$body}",
                    (int) $e->getCode(),
                    $hasResponse ? $e->getResponse()->getHeaders() : null,
                    $body
                );
            } catch (ConnectException $e) {
                $this->writeDebug($e->getMessage());

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }
            switch ($statusCode) {
                case 202:
                    if ('string' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        $contentType = $response->getHeader('Content-Type')[0] ?? '';
                        if ('string' !== 'string') {
                            $content = $contentType === 'application/xml' ? simplexml_load_string($content) : json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, 'string', $response->getHeaders());
                case 400:
                    if ('\Walmart\Models\MP\MX\Orders\ErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        $contentType = $response->getHeader('Content-Type')[0] ?? '';
                        if ('\Walmart\Models\MP\MX\Orders\ErrorResponse' !== 'string') {
                            $content = $contentType === 'application/xml' ? simplexml_load_string($content) : json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, '\Walmart\Models\MP\MX\Orders\ErrorResponse', $response->getHeaders());
                case 500:
                    if ('\Walmart\Models\MP\MX\Orders\ErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        $contentType = $response->getHeader('Content-Type')[0] ?? '';
                        if ('\Walmart\Models\MP\MX\Orders\ErrorResponse' !== 'string') {
                            $content = $contentType === 'application/xml' ? simplexml_load_string($content) : json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, '\Walmart\Models\MP\MX\Orders\ErrorResponse', $response->getHeaders());
            }

            $returnType = 'string';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                $contentType = $response->getHeader('Content-Type')[0] ?? '';
                if ($returnType !== 'string') {
                    $content = $contentType === 'application/xml' ? simplexml_load_string($content) : json_decode($content);
                }
            }

            return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 202:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Walmart\Models\MP\MX\Orders\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Walmart\Models\MP\MX\Orders\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }

            $this->writeDebug($e);
            throw $e;
        }
    }

    /**
     * Operation shippingUpdatesAsync
     *
     * Shipping Updates
     *
     * @param  string $purchaseOrderId purchaseOrderId (required)
     * @param  \Walmart\Models\MP\MX\Orders\ShipmentMx $shipmentMx File fields (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function shippingUpdatesAsync(
        string $purchaseOrderId,
        \Walmart\Models\MP\MX\Orders\ShipmentMx $shipmentMx
    ): PromiseInterface {
        return $this->shippingUpdatesAsyncWithHttpInfo($purchaseOrderId, $shipmentMx)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation shippingUpdatesAsyncWithHttpInfo
     *
     * Shipping Updates
     *
     * @param  string $purchaseOrderId purchaseOrderId (required)
     * @param  \Walmart\Models\MP\MX\Orders\ShipmentMx $shipmentMx File fields (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    protected function shippingUpdatesAsyncWithHttpInfo(
        string $purchaseOrderId,
        \Walmart\Models\MP\MX\Orders\ShipmentMx $shipmentMx,
    ): PromiseInterface {
        $returnType = 'string';
        $request = $this->shippingUpdatesRequest($purchaseOrderId, $shipmentMx);
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $this->writeDebug($response);
                    $this->writeDebug((string) $response->getBody());
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $hasResponse = !empty($response);
                    $body = (string) ($hasResponse ? $response->getBody() : '[NULL response]');
                    $this->writeDebug($response);
                    $statusCode = $hasResponse ? $response->getStatusCode() : $exception->getCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $body,
                    );
                }
            );
    }

    /**
     * Create request for operation 'shippingUpdates'
     *
     * @param  string $purchaseOrderId purchaseOrderId (required)
     * @param  \Walmart\Models\MP\MX\Orders\ShipmentMx $shipmentMx File fields (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function shippingUpdatesRequest(
        string $purchaseOrderId,
        \Walmart\Models\MP\MX\Orders\ShipmentMx $shipmentMx,
    ): Request {
        $contentType = self::contentTypes['shippingUpdates'];

        // verify the required parameter 'purchaseOrderId' is set
        if ($purchaseOrderId === null || (is_array($purchaseOrderId) && count($purchaseOrderId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $purchaseOrderId when calling shippingUpdates'
            );
        }
        // verify the required parameter 'shipmentMx' is set
        if ($shipmentMx === null || (is_array($shipmentMx) && count($shipmentMx) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $shipmentMx when calling shippingUpdates'
            );
        }
        $resourcePath = '/v3/orders/{purchaseOrderId}/ship';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $method = 'POST';

        // path params
        if ($purchaseOrderId !== null) {
            $resourcePath = str_replace(
                '{' . 'purchaseOrderId' . '}',
                ObjectSerializer::toPathValue($purchaseOrderId),
                $resourcePath
            );
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = parent::getDefaultHeaders();
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        // for model (json/xml)
        if (isset($shipmentMx)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($shipmentMx));
            } else {
                $httpBody = $shipmentMx;
            }
        } else if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        $query = ObjectSerializer::buildQuery($queryParams);
        $requestInfo = [
            'path' => $resourcePath,
            'method' => $method,
            'timestamp' => $defaultHeaders['WM_SEC.TIMESTAMP'],
            'query' => $query,
        ];

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getClientId()) || !(empty($this->config->getClientSecret()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getClientId() . ":" . $this->config->getClientSecret());
        }

        // this endpoint requires Bearer authentication (access token)
        $token = $this->config->getAccessToken();
        if ($token) {
            $headers['WM_SEC.ACCESS_TOKEN'] = $token->accessToken;
        }

        $operationHost = $this->config->getHost();
        return new Request(
            $method,
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }
}

