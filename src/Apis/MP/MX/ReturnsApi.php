<?php

/**
 * ReturnsApi
 * PHP version 7.4
 *
 * @category Class
 * @package  Walmart
 * @author   Jesse Evers
 * @link     https://highsidelabs.co
 */

/**
 * Returns Management
 *
 * This class is auto-generated by the OpenAPI generator v6.6.0 (https://openapi-generator.tech).
 * Do not edit the class manually.
 */

namespace Walmart\Apis\MP\MX;

use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Promise\PromiseInterface;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use Walmart\Apis\BaseApi;
use Walmart\ApiException;
use Walmart\ObjectSerializer;

/**
 * ReturnsApi Class Doc Comment
 *
 * @category Class
 * @package  Walmart
 * @author   Jesse Evers
 * @link     https://highsidelabs.co
 * @email    jesse@highsidelabs.co
 */
class ReturnsApi extends BaseApi
{
    /**
     * @var string[] $contentTypes
     */
    public const contentTypes = [
        'getAllReturnsUsingCursor' => 'application/json',
        'getReturns' => 'application/json',
        'refundOrderLines' => 'application/json',
    ];

    /**
     * Operation getAllReturnsUsingCursor
     *
     * Get all returns with cursor mark
     *
     * @param  string $returnCreationStartDate Start Date for querying all return orders after that date. Either both the returnCreationStartDate, returnCreationEndDate must be present in the query params or none present. If passed must be in the format - 'yyyy-MM-dd'T'HH:mm:ss.SSSXXX' (Ex. 2022-01-29T10:53:12.355-09:30 ). Use URI encoded time format. (optional, default to 'NOW-180DAYS')
     * @param  string $returnCreationEndDate End Date for querying all return orders after that date. Either both the returnCreationStartDate, returnCreationEndDate must be present in the query params or none present. If passed must be in the format - 'yyyy-MM-dd'T'HH:mm:ss.SSSXXX' (Ex. 2022-01-29T10:53:12.355-09:30 ). Use URI encoded time format. (optional, default to 'NOW')
     * @param  string $limit The number of orders to be returned. Cannot be greater than 100. (optional, default to '10')
     * @param  string $cursorMark The cursor from which next set of records to be retrieved. (optional, default to '*')
     * @param  string $customerOrderId (optional)
     * @param  string $returnOrderId The return order ID. (optional)
     * @param  string $statusCodeFilter The status code filter to apply. Valid values will be Initiated, Completed and Cancelled. (optional)
     * @param  string $isWFSEnabled Flag to get WFS returns. Valid value is Y (optional)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Walmart\Models\MP\MX\Returns\GetReturnOrdersResponseWithCursor|\Walmart\Models\MP\MX\Returns\ErrorResponse|\Walmart\Models\MP\MX\Returns\ErrorResponse
     */
    public function getAllReturnsUsingCursor(
        ?string $returnCreationStartDate = 'NOW-180DAYS',
        ?string $returnCreationEndDate = 'NOW',
        ?string $limit = '10',
        ?string $cursorMark = '*',
        ?string $customerOrderId = null,
        ?string $returnOrderId = null,
        ?string $statusCodeFilter = null,
        ?string $isWFSEnabled = null
    ): \Walmart\Models\MP\MX\Returns\GetReturnOrdersResponseWithCursor {
        return $this->getAllReturnsUsingCursorWithHttpInfo($returnCreationStartDate, $returnCreationEndDate, $limit, $cursorMark, $customerOrderId, $returnOrderId, $statusCodeFilter, $isWFSEnabled);
    }

    /**
     * Operation getAllReturnsUsingCursorWithHttpInfo
     *
     * Get all returns with cursor mark
     *
     * @param  string $returnCreationStartDate Start Date for querying all return orders after that date. Either both the returnCreationStartDate, returnCreationEndDate must be present in the query params or none present. If passed must be in the format - 'yyyy-MM-dd'T'HH:mm:ss.SSSXXX' (Ex. 2022-01-29T10:53:12.355-09:30 ). Use URI encoded time format. (optional, default to 'NOW-180DAYS')
     * @param  string $returnCreationEndDate End Date for querying all return orders after that date. Either both the returnCreationStartDate, returnCreationEndDate must be present in the query params or none present. If passed must be in the format - 'yyyy-MM-dd'T'HH:mm:ss.SSSXXX' (Ex. 2022-01-29T10:53:12.355-09:30 ). Use URI encoded time format. (optional, default to 'NOW')
     * @param  string $limit The number of orders to be returned. Cannot be greater than 100. (optional, default to '10')
     * @param  string $cursorMark The cursor from which next set of records to be retrieved. (optional, default to '*')
     * @param  string $customerOrderId (optional)
     * @param  string $returnOrderId The return order ID. (optional)
     * @param  string $statusCodeFilter The status code filter to apply. Valid values will be Initiated, Completed and Cancelled. (optional)
     * @param  string $isWFSEnabled Flag to get WFS returns. Valid value is Y (optional)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Walmart\Models\MP\MX\Returns\GetReturnOrdersResponseWithCursor|\Walmart\Models\MP\MX\Returns\ErrorResponse|\Walmart\Models\MP\MX\Returns\ErrorResponse
     */
    protected function getAllReturnsUsingCursorWithHttpInfo(
        ?string $returnCreationStartDate = 'NOW-180DAYS',
        ?string $returnCreationEndDate = 'NOW',
        ?string $limit = '10',
        ?string $cursorMark = '*',
        ?string $customerOrderId = null,
        ?string $returnOrderId = null,
        ?string $statusCodeFilter = null,
        ?string $isWFSEnabled = null,
    ): \Walmart\Models\MP\MX\Returns\GetReturnOrdersResponseWithCursor {
        $request = $this->getAllReturnsUsingCursorRequest($returnCreationStartDate, $returnCreationEndDate, $limit, $cursorMark, $customerOrderId, $returnOrderId, $statusCodeFilter, $isWFSEnabled);
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
                $this->writeDebug($response);
                $this->writeDebug((string) $response->getBody());
            } catch (RequestException $e) {
                $hasResponse = !empty($e->hasResponse());
                $body = (string) ($hasResponse ? $e->getResponse()->getBody() : '[NULL response]');
                $this->writeDebug($e->getResponse());
                $this->writeDebug($body);

                throw new ApiException(
                    "[{$e->getCode()}] {$body}",
                    (int) $e->getCode(),
                    $hasResponse ? $e->getResponse()->getHeaders() : null,
                    $body
                );
            } catch (ConnectException $e) {
                $this->writeDebug($e->getMessage());

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }
            switch ($statusCode) {
                case 200:
                    if ('\Walmart\Models\MP\MX\Returns\GetReturnOrdersResponseWithCursor' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        $contentType = $response->getHeader('Content-Type')[0] ?? '';
                        if ('\Walmart\Models\MP\MX\Returns\GetReturnOrdersResponseWithCursor' !== 'string') {
                            $content = $contentType === 'application/xml' ? simplexml_load_string($content) : json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, '\Walmart\Models\MP\MX\Returns\GetReturnOrdersResponseWithCursor', $response->getHeaders());
                case 400:
                    if ('\Walmart\Models\MP\MX\Returns\ErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        $contentType = $response->getHeader('Content-Type')[0] ?? '';
                        if ('\Walmart\Models\MP\MX\Returns\ErrorResponse' !== 'string') {
                            $content = $contentType === 'application/xml' ? simplexml_load_string($content) : json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, '\Walmart\Models\MP\MX\Returns\ErrorResponse', $response->getHeaders());
                case 500:
                    if ('\Walmart\Models\MP\MX\Returns\ErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        $contentType = $response->getHeader('Content-Type')[0] ?? '';
                        if ('\Walmart\Models\MP\MX\Returns\ErrorResponse' !== 'string') {
                            $content = $contentType === 'application/xml' ? simplexml_load_string($content) : json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, '\Walmart\Models\MP\MX\Returns\ErrorResponse', $response->getHeaders());
            }

            $returnType = '\Walmart\Models\MP\MX\Returns\GetReturnOrdersResponseWithCursor';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                $contentType = $response->getHeader('Content-Type')[0] ?? '';
                if ($returnType !== 'string') {
                    $content = $contentType === 'application/xml' ? simplexml_load_string($content) : json_decode($content);
                }
            }

            return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Walmart\Models\MP\MX\Returns\GetReturnOrdersResponseWithCursor',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Walmart\Models\MP\MX\Returns\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Walmart\Models\MP\MX\Returns\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }

            $this->writeDebug($e);
            throw $e;
        }
    }

    /**
     * Operation getAllReturnsUsingCursorAsync
     *
     * Get all returns with cursor mark
     *
     * @param  string $returnCreationStartDate Start Date for querying all return orders after that date. Either both the returnCreationStartDate, returnCreationEndDate must be present in the query params or none present. If passed must be in the format - 'yyyy-MM-dd'T'HH:mm:ss.SSSXXX' (Ex. 2022-01-29T10:53:12.355-09:30 ). Use URI encoded time format. (optional, default to 'NOW-180DAYS')
     * @param  string $returnCreationEndDate End Date for querying all return orders after that date. Either both the returnCreationStartDate, returnCreationEndDate must be present in the query params or none present. If passed must be in the format - 'yyyy-MM-dd'T'HH:mm:ss.SSSXXX' (Ex. 2022-01-29T10:53:12.355-09:30 ). Use URI encoded time format. (optional, default to 'NOW')
     * @param  string $limit The number of orders to be returned. Cannot be greater than 100. (optional, default to '10')
     * @param  string $cursorMark The cursor from which next set of records to be retrieved. (optional, default to '*')
     * @param  string $customerOrderId (optional)
     * @param  string $returnOrderId The return order ID. (optional)
     * @param  string $statusCodeFilter The status code filter to apply. Valid values will be Initiated, Completed and Cancelled. (optional)
     * @param  string $isWFSEnabled Flag to get WFS returns. Valid value is Y (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAllReturnsUsingCursorAsync(
        ?string $returnCreationStartDate = 'NOW-180DAYS',
        ?string $returnCreationEndDate = 'NOW',
        ?string $limit = '10',
        ?string $cursorMark = '*',
        ?string $customerOrderId = null,
        ?string $returnOrderId = null,
        ?string $statusCodeFilter = null,
        ?string $isWFSEnabled = null
    ): PromiseInterface {
        return $this->getAllReturnsUsingCursorAsyncWithHttpInfo($returnCreationStartDate, $returnCreationEndDate, $limit, $cursorMark, $customerOrderId, $returnOrderId, $statusCodeFilter, $isWFSEnabled)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAllReturnsUsingCursorAsyncWithHttpInfo
     *
     * Get all returns with cursor mark
     *
     * @param  string $returnCreationStartDate Start Date for querying all return orders after that date. Either both the returnCreationStartDate, returnCreationEndDate must be present in the query params or none present. If passed must be in the format - 'yyyy-MM-dd'T'HH:mm:ss.SSSXXX' (Ex. 2022-01-29T10:53:12.355-09:30 ). Use URI encoded time format. (optional, default to 'NOW-180DAYS')
     * @param  string $returnCreationEndDate End Date for querying all return orders after that date. Either both the returnCreationStartDate, returnCreationEndDate must be present in the query params or none present. If passed must be in the format - 'yyyy-MM-dd'T'HH:mm:ss.SSSXXX' (Ex. 2022-01-29T10:53:12.355-09:30 ). Use URI encoded time format. (optional, default to 'NOW')
     * @param  string $limit The number of orders to be returned. Cannot be greater than 100. (optional, default to '10')
     * @param  string $cursorMark The cursor from which next set of records to be retrieved. (optional, default to '*')
     * @param  string $customerOrderId (optional)
     * @param  string $returnOrderId The return order ID. (optional)
     * @param  string $statusCodeFilter The status code filter to apply. Valid values will be Initiated, Completed and Cancelled. (optional)
     * @param  string $isWFSEnabled Flag to get WFS returns. Valid value is Y (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    protected function getAllReturnsUsingCursorAsyncWithHttpInfo(
        ?string $returnCreationStartDate = 'NOW-180DAYS',
        ?string $returnCreationEndDate = 'NOW',
        ?string $limit = '10',
        ?string $cursorMark = '*',
        ?string $customerOrderId = null,
        ?string $returnOrderId = null,
        ?string $statusCodeFilter = null,
        ?string $isWFSEnabled = null,
    ): PromiseInterface {
        $returnType = '\Walmart\Models\MP\MX\Returns\GetReturnOrdersResponseWithCursor';
        $request = $this->getAllReturnsUsingCursorRequest($returnCreationStartDate, $returnCreationEndDate, $limit, $cursorMark, $customerOrderId, $returnOrderId, $statusCodeFilter, $isWFSEnabled);
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $this->writeDebug($response);
                    $this->writeDebug((string) $response->getBody());
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $hasResponse = !empty($response);
                    $body = (string) ($hasResponse ? $response->getBody() : '[NULL response]');
                    $this->writeDebug($response);
                    $statusCode = $hasResponse ? $response->getStatusCode() : $exception->getCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $body,
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAllReturnsUsingCursor'
     *
     * @param  string $returnCreationStartDate Start Date for querying all return orders after that date. Either both the returnCreationStartDate, returnCreationEndDate must be present in the query params or none present. If passed must be in the format - 'yyyy-MM-dd'T'HH:mm:ss.SSSXXX' (Ex. 2022-01-29T10:53:12.355-09:30 ). Use URI encoded time format. (optional, default to 'NOW-180DAYS')
     * @param  string $returnCreationEndDate End Date for querying all return orders after that date. Either both the returnCreationStartDate, returnCreationEndDate must be present in the query params or none present. If passed must be in the format - 'yyyy-MM-dd'T'HH:mm:ss.SSSXXX' (Ex. 2022-01-29T10:53:12.355-09:30 ). Use URI encoded time format. (optional, default to 'NOW')
     * @param  string $limit The number of orders to be returned. Cannot be greater than 100. (optional, default to '10')
     * @param  string $cursorMark The cursor from which next set of records to be retrieved. (optional, default to '*')
     * @param  string $customerOrderId (optional)
     * @param  string $returnOrderId The return order ID. (optional)
     * @param  string $statusCodeFilter The status code filter to apply. Valid values will be Initiated, Completed and Cancelled. (optional)
     * @param  string $isWFSEnabled Flag to get WFS returns. Valid value is Y (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getAllReturnsUsingCursorRequest(
        ?string $returnCreationStartDate = 'NOW-180DAYS',
        ?string $returnCreationEndDate = 'NOW',
        ?string $limit = '10',
        ?string $cursorMark = '*',
        ?string $customerOrderId = null,
        ?string $returnOrderId = null,
        ?string $statusCodeFilter = null,
        ?string $isWFSEnabled = null,
    ): Request {
        $contentType = self::contentTypes['getAllReturnsUsingCursor'];

        $resourcePath = '/v3/returns/cursor';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $method = 'GET';

        // query params
        $queryParams = array_merge(
            ObjectSerializer::toQueryValue(
                $returnCreationStartDate,
                'returnCreationStartDate', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? [],
            ObjectSerializer::toQueryValue(
                $returnCreationEndDate,
                'returnCreationEndDate', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? [],
            ObjectSerializer::toQueryValue(
                $limit,
                'limit', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? [],
            ObjectSerializer::toQueryValue(
                $cursorMark,
                'cursorMark', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? [],
            ObjectSerializer::toQueryValue(
                $customerOrderId,
                'customerOrderId', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? [],
            ObjectSerializer::toQueryValue(
                $returnOrderId,
                'returnOrderId', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? [],
            ObjectSerializer::toQueryValue(
                $statusCodeFilter,
                'statusCodeFilter', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? [],
            ObjectSerializer::toQueryValue(
                $isWFSEnabled,
                'isWFSEnabled', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? [],
        );

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = parent::getDefaultHeaders();
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        $query = ObjectSerializer::buildQuery($queryParams);
        $requestInfo = [
            'path' => $resourcePath,
            'method' => $method,
            'timestamp' => $defaultHeaders['WM_SEC.TIMESTAMP'],
            'query' => $query,
        ];

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getClientId()) || !(empty($this->config->getClientSecret()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getClientId() . ":" . $this->config->getClientSecret());
        }

        // this endpoint requires Bearer authentication (access token)
        $token = $this->config->getAccessToken();
        if ($token) {
            $headers['WM_SEC.ACCESS_TOKEN'] = $token->accessToken;
        }

        $operationHost = $this->config->getHost();
        return new Request(
            $method,
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getReturns
     *
     * Get Returns
     *
     * @param  string $returnCreationStartDate Start Date for querying all return orders after that date. Either both the returnCreationStartDate, returnCreationEndDate must be present in the query params or none present. Use URI encoded time format. (optional, default to 'NOW-180DAYS')
     * @param  string $returnCreationEndDate End Date for querying all return orders after that date. Either both the returnCreationStartDate, returnCreationEndDate must be present in the query params or none present. Use URI encoded time format. (optional, default to 'NOW')
     * @param  string $limit The number of orders to be returned. Cannot be greater than 100. (optional, default to '10')
     * @param  string $offset The starting offset of the first order required in the response. Cannot be greater than 1000 (optional, default to '0')
     * @param  string $customerOrderId The customer order ID. (optional)
     * @param  string $returnOrderId The return order ID. (optional)
     * @param  string $statusCodeFilter The status code filter to apply. Valid values will be Initiated, Completed and Cancelled. (optional)
     * @param  string $isWFSEnabled Flag to get WFS returns. Valid value is Y (optional)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Walmart\Models\MP\MX\Returns\GetReturnOrdersResponse|\Walmart\Models\MP\MX\Returns\ErrorResponse|\Walmart\Models\MP\MX\Returns\ErrorResponse
     */
    public function getReturns(
        ?string $returnCreationStartDate = 'NOW-180DAYS',
        ?string $returnCreationEndDate = 'NOW',
        ?string $limit = '10',
        ?string $offset = '0',
        ?string $customerOrderId = null,
        ?string $returnOrderId = null,
        ?string $statusCodeFilter = null,
        ?string $isWFSEnabled = null
    ): \Walmart\Models\MP\MX\Returns\GetReturnOrdersResponse {
        return $this->getReturnsWithHttpInfo($returnCreationStartDate, $returnCreationEndDate, $limit, $offset, $customerOrderId, $returnOrderId, $statusCodeFilter, $isWFSEnabled);
    }

    /**
     * Operation getReturnsWithHttpInfo
     *
     * Get Returns
     *
     * @param  string $returnCreationStartDate Start Date for querying all return orders after that date. Either both the returnCreationStartDate, returnCreationEndDate must be present in the query params or none present. Use URI encoded time format. (optional, default to 'NOW-180DAYS')
     * @param  string $returnCreationEndDate End Date for querying all return orders after that date. Either both the returnCreationStartDate, returnCreationEndDate must be present in the query params or none present. Use URI encoded time format. (optional, default to 'NOW')
     * @param  string $limit The number of orders to be returned. Cannot be greater than 100. (optional, default to '10')
     * @param  string $offset The starting offset of the first order required in the response. Cannot be greater than 1000 (optional, default to '0')
     * @param  string $customerOrderId The customer order ID. (optional)
     * @param  string $returnOrderId The return order ID. (optional)
     * @param  string $statusCodeFilter The status code filter to apply. Valid values will be Initiated, Completed and Cancelled. (optional)
     * @param  string $isWFSEnabled Flag to get WFS returns. Valid value is Y (optional)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Walmart\Models\MP\MX\Returns\GetReturnOrdersResponse|\Walmart\Models\MP\MX\Returns\ErrorResponse|\Walmart\Models\MP\MX\Returns\ErrorResponse
     */
    protected function getReturnsWithHttpInfo(
        ?string $returnCreationStartDate = 'NOW-180DAYS',
        ?string $returnCreationEndDate = 'NOW',
        ?string $limit = '10',
        ?string $offset = '0',
        ?string $customerOrderId = null,
        ?string $returnOrderId = null,
        ?string $statusCodeFilter = null,
        ?string $isWFSEnabled = null,
    ): \Walmart\Models\MP\MX\Returns\GetReturnOrdersResponse {
        $request = $this->getReturnsRequest($returnCreationStartDate, $returnCreationEndDate, $limit, $offset, $customerOrderId, $returnOrderId, $statusCodeFilter, $isWFSEnabled);
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
                $this->writeDebug($response);
                $this->writeDebug((string) $response->getBody());
            } catch (RequestException $e) {
                $hasResponse = !empty($e->hasResponse());
                $body = (string) ($hasResponse ? $e->getResponse()->getBody() : '[NULL response]');
                $this->writeDebug($e->getResponse());
                $this->writeDebug($body);

                throw new ApiException(
                    "[{$e->getCode()}] {$body}",
                    (int) $e->getCode(),
                    $hasResponse ? $e->getResponse()->getHeaders() : null,
                    $body
                );
            } catch (ConnectException $e) {
                $this->writeDebug($e->getMessage());

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }
            switch ($statusCode) {
                case 200:
                    if ('\Walmart\Models\MP\MX\Returns\GetReturnOrdersResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        $contentType = $response->getHeader('Content-Type')[0] ?? '';
                        if ('\Walmart\Models\MP\MX\Returns\GetReturnOrdersResponse' !== 'string') {
                            $content = $contentType === 'application/xml' ? simplexml_load_string($content) : json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, '\Walmart\Models\MP\MX\Returns\GetReturnOrdersResponse', $response->getHeaders());
                case 400:
                    if ('\Walmart\Models\MP\MX\Returns\ErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        $contentType = $response->getHeader('Content-Type')[0] ?? '';
                        if ('\Walmart\Models\MP\MX\Returns\ErrorResponse' !== 'string') {
                            $content = $contentType === 'application/xml' ? simplexml_load_string($content) : json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, '\Walmart\Models\MP\MX\Returns\ErrorResponse', $response->getHeaders());
                case 500:
                    if ('\Walmart\Models\MP\MX\Returns\ErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        $contentType = $response->getHeader('Content-Type')[0] ?? '';
                        if ('\Walmart\Models\MP\MX\Returns\ErrorResponse' !== 'string') {
                            $content = $contentType === 'application/xml' ? simplexml_load_string($content) : json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, '\Walmart\Models\MP\MX\Returns\ErrorResponse', $response->getHeaders());
            }

            $returnType = '\Walmart\Models\MP\MX\Returns\GetReturnOrdersResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                $contentType = $response->getHeader('Content-Type')[0] ?? '';
                if ($returnType !== 'string') {
                    $content = $contentType === 'application/xml' ? simplexml_load_string($content) : json_decode($content);
                }
            }

            return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Walmart\Models\MP\MX\Returns\GetReturnOrdersResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Walmart\Models\MP\MX\Returns\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Walmart\Models\MP\MX\Returns\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }

            $this->writeDebug($e);
            throw $e;
        }
    }

    /**
     * Operation getReturnsAsync
     *
     * Get Returns
     *
     * @param  string $returnCreationStartDate Start Date for querying all return orders after that date. Either both the returnCreationStartDate, returnCreationEndDate must be present in the query params or none present. Use URI encoded time format. (optional, default to 'NOW-180DAYS')
     * @param  string $returnCreationEndDate End Date for querying all return orders after that date. Either both the returnCreationStartDate, returnCreationEndDate must be present in the query params or none present. Use URI encoded time format. (optional, default to 'NOW')
     * @param  string $limit The number of orders to be returned. Cannot be greater than 100. (optional, default to '10')
     * @param  string $offset The starting offset of the first order required in the response. Cannot be greater than 1000 (optional, default to '0')
     * @param  string $customerOrderId The customer order ID. (optional)
     * @param  string $returnOrderId The return order ID. (optional)
     * @param  string $statusCodeFilter The status code filter to apply. Valid values will be Initiated, Completed and Cancelled. (optional)
     * @param  string $isWFSEnabled Flag to get WFS returns. Valid value is Y (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getReturnsAsync(
        ?string $returnCreationStartDate = 'NOW-180DAYS',
        ?string $returnCreationEndDate = 'NOW',
        ?string $limit = '10',
        ?string $offset = '0',
        ?string $customerOrderId = null,
        ?string $returnOrderId = null,
        ?string $statusCodeFilter = null,
        ?string $isWFSEnabled = null
    ): PromiseInterface {
        return $this->getReturnsAsyncWithHttpInfo($returnCreationStartDate, $returnCreationEndDate, $limit, $offset, $customerOrderId, $returnOrderId, $statusCodeFilter, $isWFSEnabled)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getReturnsAsyncWithHttpInfo
     *
     * Get Returns
     *
     * @param  string $returnCreationStartDate Start Date for querying all return orders after that date. Either both the returnCreationStartDate, returnCreationEndDate must be present in the query params or none present. Use URI encoded time format. (optional, default to 'NOW-180DAYS')
     * @param  string $returnCreationEndDate End Date for querying all return orders after that date. Either both the returnCreationStartDate, returnCreationEndDate must be present in the query params or none present. Use URI encoded time format. (optional, default to 'NOW')
     * @param  string $limit The number of orders to be returned. Cannot be greater than 100. (optional, default to '10')
     * @param  string $offset The starting offset of the first order required in the response. Cannot be greater than 1000 (optional, default to '0')
     * @param  string $customerOrderId The customer order ID. (optional)
     * @param  string $returnOrderId The return order ID. (optional)
     * @param  string $statusCodeFilter The status code filter to apply. Valid values will be Initiated, Completed and Cancelled. (optional)
     * @param  string $isWFSEnabled Flag to get WFS returns. Valid value is Y (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    protected function getReturnsAsyncWithHttpInfo(
        ?string $returnCreationStartDate = 'NOW-180DAYS',
        ?string $returnCreationEndDate = 'NOW',
        ?string $limit = '10',
        ?string $offset = '0',
        ?string $customerOrderId = null,
        ?string $returnOrderId = null,
        ?string $statusCodeFilter = null,
        ?string $isWFSEnabled = null,
    ): PromiseInterface {
        $returnType = '\Walmart\Models\MP\MX\Returns\GetReturnOrdersResponse';
        $request = $this->getReturnsRequest($returnCreationStartDate, $returnCreationEndDate, $limit, $offset, $customerOrderId, $returnOrderId, $statusCodeFilter, $isWFSEnabled);
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $this->writeDebug($response);
                    $this->writeDebug((string) $response->getBody());
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $hasResponse = !empty($response);
                    $body = (string) ($hasResponse ? $response->getBody() : '[NULL response]');
                    $this->writeDebug($response);
                    $statusCode = $hasResponse ? $response->getStatusCode() : $exception->getCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $body,
                    );
                }
            );
    }

    /**
     * Create request for operation 'getReturns'
     *
     * @param  string $returnCreationStartDate Start Date for querying all return orders after that date. Either both the returnCreationStartDate, returnCreationEndDate must be present in the query params or none present. Use URI encoded time format. (optional, default to 'NOW-180DAYS')
     * @param  string $returnCreationEndDate End Date for querying all return orders after that date. Either both the returnCreationStartDate, returnCreationEndDate must be present in the query params or none present. Use URI encoded time format. (optional, default to 'NOW')
     * @param  string $limit The number of orders to be returned. Cannot be greater than 100. (optional, default to '10')
     * @param  string $offset The starting offset of the first order required in the response. Cannot be greater than 1000 (optional, default to '0')
     * @param  string $customerOrderId The customer order ID. (optional)
     * @param  string $returnOrderId The return order ID. (optional)
     * @param  string $statusCodeFilter The status code filter to apply. Valid values will be Initiated, Completed and Cancelled. (optional)
     * @param  string $isWFSEnabled Flag to get WFS returns. Valid value is Y (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getReturnsRequest(
        ?string $returnCreationStartDate = 'NOW-180DAYS',
        ?string $returnCreationEndDate = 'NOW',
        ?string $limit = '10',
        ?string $offset = '0',
        ?string $customerOrderId = null,
        ?string $returnOrderId = null,
        ?string $statusCodeFilter = null,
        ?string $isWFSEnabled = null,
    ): Request {
        $contentType = self::contentTypes['getReturns'];

        $resourcePath = '/v3/returns';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $method = 'GET';

        // query params
        $queryParams = array_merge(
            ObjectSerializer::toQueryValue(
                $returnCreationStartDate,
                'returnCreationStartDate', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? [],
            ObjectSerializer::toQueryValue(
                $returnCreationEndDate,
                'returnCreationEndDate', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? [],
            ObjectSerializer::toQueryValue(
                $limit,
                'limit', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? [],
            ObjectSerializer::toQueryValue(
                $offset,
                'offset', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? [],
            ObjectSerializer::toQueryValue(
                $customerOrderId,
                'customerOrderId', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? [],
            ObjectSerializer::toQueryValue(
                $returnOrderId,
                'returnOrderId', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? [],
            ObjectSerializer::toQueryValue(
                $statusCodeFilter,
                'statusCodeFilter', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? [],
            ObjectSerializer::toQueryValue(
                $isWFSEnabled,
                'isWFSEnabled', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? [],
        );

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = parent::getDefaultHeaders();
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        $query = ObjectSerializer::buildQuery($queryParams);
        $requestInfo = [
            'path' => $resourcePath,
            'method' => $method,
            'timestamp' => $defaultHeaders['WM_SEC.TIMESTAMP'],
            'query' => $query,
        ];

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getClientId()) || !(empty($this->config->getClientSecret()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getClientId() . ":" . $this->config->getClientSecret());
        }

        // this endpoint requires Bearer authentication (access token)
        $token = $this->config->getAccessToken();
        if ($token) {
            $headers['WM_SEC.ACCESS_TOKEN'] = $token->accessToken;
        }

        $operationHost = $this->config->getHost();
        return new Request(
            $method,
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation refundOrderLines
     *
     * Refund Order Lines
     *
     * @param  string $returnOrderId returnOrderId (required)
     * @param  \Walmart\Models\MP\MX\Returns\OrderRefundRequest $orderRefundRequest OrderRefund request body (required)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string|\Walmart\Models\MP\MX\Returns\ErrorResponse|\Walmart\Models\MP\MX\Returns\ErrorResponse
     */
    public function refundOrderLines(
        string $returnOrderId,
        \Walmart\Models\MP\MX\Returns\OrderRefundRequest $orderRefundRequest
    ): string {
        return $this->refundOrderLinesWithHttpInfo($returnOrderId, $orderRefundRequest);
    }

    /**
     * Operation refundOrderLinesWithHttpInfo
     *
     * Refund Order Lines
     *
     * @param  string $returnOrderId returnOrderId (required)
     * @param  \Walmart\Models\MP\MX\Returns\OrderRefundRequest $orderRefundRequest OrderRefund request body (required)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string|\Walmart\Models\MP\MX\Returns\ErrorResponse|\Walmart\Models\MP\MX\Returns\ErrorResponse
     */
    protected function refundOrderLinesWithHttpInfo(
        string $returnOrderId,
        \Walmart\Models\MP\MX\Returns\OrderRefundRequest $orderRefundRequest,
    ): string {
        $request = $this->refundOrderLinesRequest($returnOrderId, $orderRefundRequest);
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
                $this->writeDebug($response);
                $this->writeDebug((string) $response->getBody());
            } catch (RequestException $e) {
                $hasResponse = !empty($e->hasResponse());
                $body = (string) ($hasResponse ? $e->getResponse()->getBody() : '[NULL response]');
                $this->writeDebug($e->getResponse());
                $this->writeDebug($body);

                throw new ApiException(
                    "[{$e->getCode()}] {$body}",
                    (int) $e->getCode(),
                    $hasResponse ? $e->getResponse()->getHeaders() : null,
                    $body
                );
            } catch (ConnectException $e) {
                $this->writeDebug($e->getMessage());

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }
            switch ($statusCode) {
                case 202:
                    if ('string' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        $contentType = $response->getHeader('Content-Type')[0] ?? '';
                        if ('string' !== 'string') {
                            $content = $contentType === 'application/xml' ? simplexml_load_string($content) : json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, 'string', $response->getHeaders());
                case 400:
                    if ('\Walmart\Models\MP\MX\Returns\ErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        $contentType = $response->getHeader('Content-Type')[0] ?? '';
                        if ('\Walmart\Models\MP\MX\Returns\ErrorResponse' !== 'string') {
                            $content = $contentType === 'application/xml' ? simplexml_load_string($content) : json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, '\Walmart\Models\MP\MX\Returns\ErrorResponse', $response->getHeaders());
                case 500:
                    if ('\Walmart\Models\MP\MX\Returns\ErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        $contentType = $response->getHeader('Content-Type')[0] ?? '';
                        if ('\Walmart\Models\MP\MX\Returns\ErrorResponse' !== 'string') {
                            $content = $contentType === 'application/xml' ? simplexml_load_string($content) : json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, '\Walmart\Models\MP\MX\Returns\ErrorResponse', $response->getHeaders());
            }

            $returnType = 'string';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                $contentType = $response->getHeader('Content-Type')[0] ?? '';
                if ($returnType !== 'string') {
                    $content = $contentType === 'application/xml' ? simplexml_load_string($content) : json_decode($content);
                }
            }

            return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 202:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Walmart\Models\MP\MX\Returns\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Walmart\Models\MP\MX\Returns\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }

            $this->writeDebug($e);
            throw $e;
        }
    }

    /**
     * Operation refundOrderLinesAsync
     *
     * Refund Order Lines
     *
     * @param  string $returnOrderId returnOrderId (required)
     * @param  \Walmart\Models\MP\MX\Returns\OrderRefundRequest $orderRefundRequest OrderRefund request body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function refundOrderLinesAsync(
        string $returnOrderId,
        \Walmart\Models\MP\MX\Returns\OrderRefundRequest $orderRefundRequest
    ): PromiseInterface {
        return $this->refundOrderLinesAsyncWithHttpInfo($returnOrderId, $orderRefundRequest)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation refundOrderLinesAsyncWithHttpInfo
     *
     * Refund Order Lines
     *
     * @param  string $returnOrderId returnOrderId (required)
     * @param  \Walmart\Models\MP\MX\Returns\OrderRefundRequest $orderRefundRequest OrderRefund request body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    protected function refundOrderLinesAsyncWithHttpInfo(
        string $returnOrderId,
        \Walmart\Models\MP\MX\Returns\OrderRefundRequest $orderRefundRequest,
    ): PromiseInterface {
        $returnType = 'string';
        $request = $this->refundOrderLinesRequest($returnOrderId, $orderRefundRequest);
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $this->writeDebug($response);
                    $this->writeDebug((string) $response->getBody());
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $hasResponse = !empty($response);
                    $body = (string) ($hasResponse ? $response->getBody() : '[NULL response]');
                    $this->writeDebug($response);
                    $statusCode = $hasResponse ? $response->getStatusCode() : $exception->getCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $body,
                    );
                }
            );
    }

    /**
     * Create request for operation 'refundOrderLines'
     *
     * @param  string $returnOrderId returnOrderId (required)
     * @param  \Walmart\Models\MP\MX\Returns\OrderRefundRequest $orderRefundRequest OrderRefund request body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function refundOrderLinesRequest(
        string $returnOrderId,
        \Walmart\Models\MP\MX\Returns\OrderRefundRequest $orderRefundRequest,
    ): Request {
        $contentType = self::contentTypes['refundOrderLines'];

        // verify the required parameter 'returnOrderId' is set
        if ($returnOrderId === null || (is_array($returnOrderId) && count($returnOrderId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $returnOrderId when calling refundOrderLines'
            );
        }
        // verify the required parameter 'orderRefundRequest' is set
        if ($orderRefundRequest === null || (is_array($orderRefundRequest) && count($orderRefundRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $orderRefundRequest when calling refundOrderLines'
            );
        }
        $resourcePath = '/v3/returns/{returnOrderId}/refund';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $method = 'POST';

        // path params
        if ($returnOrderId !== null) {
            $resourcePath = str_replace(
                '{' . 'returnOrderId' . '}',
                ObjectSerializer::toPathValue($returnOrderId),
                $resourcePath
            );
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = parent::getDefaultHeaders();
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        // for model (json/xml)
        if (isset($orderRefundRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($orderRefundRequest));
            } else {
                $httpBody = $orderRefundRequest;
            }
        } else if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        $query = ObjectSerializer::buildQuery($queryParams);
        $requestInfo = [
            'path' => $resourcePath,
            'method' => $method,
            'timestamp' => $defaultHeaders['WM_SEC.TIMESTAMP'],
            'query' => $query,
        ];

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getClientId()) || !(empty($this->config->getClientSecret()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getClientId() . ":" . $this->config->getClientSecret());
        }

        // this endpoint requires Bearer authentication (access token)
        $token = $this->config->getAccessToken();
        if ($token) {
            $headers['WM_SEC.ACCESS_TOKEN'] = $token->accessToken;
        }

        $operationHost = $this->config->getHost();
        return new Request(
            $method,
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }
}

