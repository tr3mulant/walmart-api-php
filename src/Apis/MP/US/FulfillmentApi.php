<?php

/**
 * FulfillmentApi
 * PHP version 7.4
 *
 * @category Class
 * @package  Walmart
 * @author   Jesse Evers
 * @link     https://highsidelabs.co
 */

/**
 * Fulfillment Management
 *
 * This class is auto-generated by the OpenAPI generator v6.6.0 (https://openapi-generator.tech).
 * Do not edit the class manually.
 */

namespace Walmart\Apis\MP\US;

use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Promise\PromiseInterface;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use Walmart\Apis\BaseApi;
use Walmart\ApiException;
use Walmart\ObjectSerializer;

/**
 * FulfillmentApi Class Doc Comment
 *
 * @category Class
 * @package  Walmart
 * @author   Jesse Evers
 * @link     https://highsidelabs.co
 * @email    jesse@highsidelabs.co
 */
class FulfillmentApi extends BaseApi
{
    /**
     * @var string[] $contentTypes
     */
    public const contentTypes = [
        'cancelFulfillment' => 'application/json',
        'cancelShipment' => 'application/json',
        'confirmCarrierRateQuote' => 'application/json',
        'convertItemForWfs' => 'multipart/form-data',
        'createCarrierRateQuotes' => 'application/json',
        'createFulfillment' => 'application/json',
        'createInboundShipmentLabel' => 'application/json',
        'createInboundShipmentLabelV2' => 'application/json',
        'createShipment' => 'application/json',
        'getCarrierRateQuote' => 'application/json',
        'getFulfillmentOrdersStatus' => 'application/json',
        'getInboundOrderErrors' => 'application/json',
        'getInboundShipmentItems' => 'application/json',
        'getInboundShipments' => 'application/json',
        'getInventoryHealthReport' => 'application/json',
        'getWFSInventoryLog' => 'application/json',
        'inboundPreview' => 'application/json',
        'printCarrierLabel' => 'application/json',
        'promiseFulfillments' => 'application/json',
        'updateShipmentQuantity' => 'application/json',
        'updateShipmentTrackingDetails' => 'application/json',
        'voidCarrierRateQuote' => 'application/json',
        'wercsFeedback' => 'application/json',
    ];

    /**
     * Operation cancelFulfillment
     *
     * Cancel Customer Order
     *
     * @param  \Walmart\Models\MP\US\Fulfillment\CancelCustomerOrderRequestWrapper $cancelCustomerOrderRequestWrapper Request fields (required)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Walmart\Models\MP\US\Fulfillment\CustomerOrderDetailsResponseWrapperDTO
     */
    public function cancelFulfillment(
        \Walmart\Models\MP\US\Fulfillment\CancelCustomerOrderRequestWrapper $cancelCustomerOrderRequestWrapper
    ): \Walmart\Models\MP\US\Fulfillment\CustomerOrderDetailsResponseWrapperDTO {
        return $this->cancelFulfillmentWithHttpInfo($cancelCustomerOrderRequestWrapper);
    }

    /**
     * Operation cancelFulfillmentWithHttpInfo
     *
     * Cancel Customer Order
     *
     * @param  \Walmart\Models\MP\US\Fulfillment\CancelCustomerOrderRequestWrapper $cancelCustomerOrderRequestWrapper Request fields (required)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Walmart\Models\MP\US\Fulfillment\CustomerOrderDetailsResponseWrapperDTO
     */
    protected function cancelFulfillmentWithHttpInfo(
        \Walmart\Models\MP\US\Fulfillment\CancelCustomerOrderRequestWrapper $cancelCustomerOrderRequestWrapper,
    ): \Walmart\Models\MP\US\Fulfillment\CustomerOrderDetailsResponseWrapperDTO {
        $request = $this->cancelFulfillmentRequest($cancelCustomerOrderRequestWrapper);
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
                $this->writeDebug($response);
                $this->writeDebug((string) $response->getBody());
            } catch (RequestException $e) {
                $hasResponse = !empty($e->hasResponse());
                $body = (string) ($hasResponse ? $e->getResponse()->getBody() : '[NULL response]');
                $this->writeDebug($e->getResponse());
                $this->writeDebug($body);

                throw new ApiException(
                    "[{$e->getCode()}] {$body}",
                    (int) $e->getCode(),
                    $hasResponse ? $e->getResponse()->getHeaders() : null,
                    $body
                );
            } catch (ConnectException $e) {
                $this->writeDebug($e->getMessage());

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }
            switch ($statusCode) {
                case 200:
                    if ('\Walmart\Models\MP\US\Fulfillment\CustomerOrderDetailsResponseWrapperDTO' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        $contentType = $response->getHeader('Content-Type')[0] ?? '';
                        if ('\Walmart\Models\MP\US\Fulfillment\CustomerOrderDetailsResponseWrapperDTO' !== 'string') {
                            $content = $contentType === 'application/xml' ? simplexml_load_string($content) : json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, '\Walmart\Models\MP\US\Fulfillment\CustomerOrderDetailsResponseWrapperDTO', $response->getHeaders());
            }

            $returnType = '\Walmart\Models\MP\US\Fulfillment\CustomerOrderDetailsResponseWrapperDTO';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                $contentType = $response->getHeader('Content-Type')[0] ?? '';
                if ($returnType !== 'string') {
                    $content = $contentType === 'application/xml' ? simplexml_load_string($content) : json_decode($content);
                }
            }

            return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Walmart\Models\MP\US\Fulfillment\CustomerOrderDetailsResponseWrapperDTO',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }

            $this->writeDebug($e);
            throw $e;
        }
    }

    /**
     * Operation cancelFulfillmentAsync
     *
     * Cancel Customer Order
     *
     * @param  \Walmart\Models\MP\US\Fulfillment\CancelCustomerOrderRequestWrapper $cancelCustomerOrderRequestWrapper Request fields (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cancelFulfillmentAsync(
        \Walmart\Models\MP\US\Fulfillment\CancelCustomerOrderRequestWrapper $cancelCustomerOrderRequestWrapper
    ): PromiseInterface {
        return $this->cancelFulfillmentAsyncWithHttpInfo($cancelCustomerOrderRequestWrapper)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cancelFulfillmentAsyncWithHttpInfo
     *
     * Cancel Customer Order
     *
     * @param  \Walmart\Models\MP\US\Fulfillment\CancelCustomerOrderRequestWrapper $cancelCustomerOrderRequestWrapper Request fields (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    protected function cancelFulfillmentAsyncWithHttpInfo(
        \Walmart\Models\MP\US\Fulfillment\CancelCustomerOrderRequestWrapper $cancelCustomerOrderRequestWrapper,
    ): PromiseInterface {
        $returnType = '\Walmart\Models\MP\US\Fulfillment\CustomerOrderDetailsResponseWrapperDTO';
        $request = $this->cancelFulfillmentRequest($cancelCustomerOrderRequestWrapper);
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $this->writeDebug($response);
                    $this->writeDebug((string) $response->getBody());
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $hasResponse = !empty($response);
                    $body = (string) ($hasResponse ? $response->getBody() : '[NULL response]');
                    $this->writeDebug($response);
                    $statusCode = $hasResponse ? $response->getStatusCode() : $exception->getCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $body,
                    );
                }
            );
    }

    /**
     * Create request for operation 'cancelFulfillment'
     *
     * @param  \Walmart\Models\MP\US\Fulfillment\CancelCustomerOrderRequestWrapper $cancelCustomerOrderRequestWrapper Request fields (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function cancelFulfillmentRequest(
        \Walmart\Models\MP\US\Fulfillment\CancelCustomerOrderRequestWrapper $cancelCustomerOrderRequestWrapper,
    ): Request {
        $contentType = self::contentTypes['cancelFulfillment'];

        // verify the required parameter 'cancelCustomerOrderRequestWrapper' is set
        if ($cancelCustomerOrderRequestWrapper === null || (is_array($cancelCustomerOrderRequestWrapper) && count($cancelCustomerOrderRequestWrapper) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $cancelCustomerOrderRequestWrapper when calling cancelFulfillment'
            );
        }
        $resourcePath = '/v3/fulfillment/orders-fulfillments/cancel';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $method = 'POST';

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = parent::getDefaultHeaders();
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        // for model (json/xml)
        if (isset($cancelCustomerOrderRequestWrapper)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($cancelCustomerOrderRequestWrapper));
            } else {
                $httpBody = $cancelCustomerOrderRequestWrapper;
            }
        } else if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        $query = ObjectSerializer::buildQuery($queryParams);
        $requestInfo = [
            'path' => $resourcePath,
            'method' => $method,
            'timestamp' => $defaultHeaders['WM_SEC.TIMESTAMP'],
            'query' => $query,
        ];

        // this endpoint requires Bearer authentication (access token)
        $token = $this->config->getAccessToken();
        if ($token) {
            $headers['WM_SEC.ACCESS_TOKEN'] = $token->accessToken;
        }

        $operationHost = $this->config->getHost();
        return new Request(
            $method,
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cancelShipment
     *
     * Cancel Inbound Shipment
     *
     * @param  string $inboundOrderId Unique ID identifying inbound shipment request (required)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Walmart\Models\MP\US\Fulfillment\ServiceResponse
     */
    public function cancelShipment(
        string $inboundOrderId
    ): \Walmart\Models\MP\US\Fulfillment\ServiceResponse {
        return $this->cancelShipmentWithHttpInfo($inboundOrderId);
    }

    /**
     * Operation cancelShipmentWithHttpInfo
     *
     * Cancel Inbound Shipment
     *
     * @param  string $inboundOrderId Unique ID identifying inbound shipment request (required)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Walmart\Models\MP\US\Fulfillment\ServiceResponse
     */
    protected function cancelShipmentWithHttpInfo(
        string $inboundOrderId,
    ): \Walmart\Models\MP\US\Fulfillment\ServiceResponse {
        $request = $this->cancelShipmentRequest($inboundOrderId);
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
                $this->writeDebug($response);
                $this->writeDebug((string) $response->getBody());
            } catch (RequestException $e) {
                $hasResponse = !empty($e->hasResponse());
                $body = (string) ($hasResponse ? $e->getResponse()->getBody() : '[NULL response]');
                $this->writeDebug($e->getResponse());
                $this->writeDebug($body);

                throw new ApiException(
                    "[{$e->getCode()}] {$body}",
                    (int) $e->getCode(),
                    $hasResponse ? $e->getResponse()->getHeaders() : null,
                    $body
                );
            } catch (ConnectException $e) {
                $this->writeDebug($e->getMessage());

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }
            switch ($statusCode) {
                case 200:
                    if ('\Walmart\Models\MP\US\Fulfillment\ServiceResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        $contentType = $response->getHeader('Content-Type')[0] ?? '';
                        if ('\Walmart\Models\MP\US\Fulfillment\ServiceResponse' !== 'string') {
                            $content = $contentType === 'application/xml' ? simplexml_load_string($content) : json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, '\Walmart\Models\MP\US\Fulfillment\ServiceResponse', $response->getHeaders());
            }

            $returnType = '\Walmart\Models\MP\US\Fulfillment\ServiceResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                $contentType = $response->getHeader('Content-Type')[0] ?? '';
                if ($returnType !== 'string') {
                    $content = $contentType === 'application/xml' ? simplexml_load_string($content) : json_decode($content);
                }
            }

            return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Walmart\Models\MP\US\Fulfillment\ServiceResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }

            $this->writeDebug($e);
            throw $e;
        }
    }

    /**
     * Operation cancelShipmentAsync
     *
     * Cancel Inbound Shipment
     *
     * @param  string $inboundOrderId Unique ID identifying inbound shipment request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cancelShipmentAsync(
        string $inboundOrderId
    ): PromiseInterface {
        return $this->cancelShipmentAsyncWithHttpInfo($inboundOrderId)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cancelShipmentAsyncWithHttpInfo
     *
     * Cancel Inbound Shipment
     *
     * @param  string $inboundOrderId Unique ID identifying inbound shipment request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    protected function cancelShipmentAsyncWithHttpInfo(
        string $inboundOrderId,
    ): PromiseInterface {
        $returnType = '\Walmart\Models\MP\US\Fulfillment\ServiceResponse';
        $request = $this->cancelShipmentRequest($inboundOrderId);
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $this->writeDebug($response);
                    $this->writeDebug((string) $response->getBody());
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $hasResponse = !empty($response);
                    $body = (string) ($hasResponse ? $response->getBody() : '[NULL response]');
                    $this->writeDebug($response);
                    $statusCode = $hasResponse ? $response->getStatusCode() : $exception->getCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $body,
                    );
                }
            );
    }

    /**
     * Create request for operation 'cancelShipment'
     *
     * @param  string $inboundOrderId Unique ID identifying inbound shipment request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function cancelShipmentRequest(
        string $inboundOrderId,
    ): Request {
        $contentType = self::contentTypes['cancelShipment'];

        // verify the required parameter 'inboundOrderId' is set
        if ($inboundOrderId === null || (is_array($inboundOrderId) && count($inboundOrderId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inboundOrderId when calling cancelShipment'
            );
        }
        $resourcePath = '/v3/fulfillment/inbound-shipments/{inboundOrderId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $method = 'DELETE';

        // path params
        if ($inboundOrderId !== null) {
            $resourcePath = str_replace(
                '{' . 'inboundOrderId' . '}',
                ObjectSerializer::toPathValue($inboundOrderId),
                $resourcePath
            );
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = parent::getDefaultHeaders();
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        $query = ObjectSerializer::buildQuery($queryParams);
        $requestInfo = [
            'path' => $resourcePath,
            'method' => $method,
            'timestamp' => $defaultHeaders['WM_SEC.TIMESTAMP'],
            'query' => $query,
        ];

        // this endpoint requires Bearer authentication (access token)
        $token = $this->config->getAccessToken();
        if ($token) {
            $headers['WM_SEC.ACCESS_TOKEN'] = $token->accessToken;
        }

        $operationHost = $this->config->getHost();
        return new Request(
            $method,
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation confirmCarrierRateQuote
     *
     * Confirm Carrier Rate Quote
     *
     * @param  \Walmart\Models\MP\US\Fulfillment\CarrierQuoteConfirmRequestWrapper $carrierQuoteConfirmRequestWrapper Request fields (required)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Walmart\Models\MP\US\Fulfillment\ServiceResponse
     */
    public function confirmCarrierRateQuote(
        \Walmart\Models\MP\US\Fulfillment\CarrierQuoteConfirmRequestWrapper $carrierQuoteConfirmRequestWrapper
    ): \Walmart\Models\MP\US\Fulfillment\ServiceResponse {
        return $this->confirmCarrierRateQuoteWithHttpInfo($carrierQuoteConfirmRequestWrapper);
    }

    /**
     * Operation confirmCarrierRateQuoteWithHttpInfo
     *
     * Confirm Carrier Rate Quote
     *
     * @param  \Walmart\Models\MP\US\Fulfillment\CarrierQuoteConfirmRequestWrapper $carrierQuoteConfirmRequestWrapper Request fields (required)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Walmart\Models\MP\US\Fulfillment\ServiceResponse
     */
    protected function confirmCarrierRateQuoteWithHttpInfo(
        \Walmart\Models\MP\US\Fulfillment\CarrierQuoteConfirmRequestWrapper $carrierQuoteConfirmRequestWrapper,
    ): \Walmart\Models\MP\US\Fulfillment\ServiceResponse {
        $request = $this->confirmCarrierRateQuoteRequest($carrierQuoteConfirmRequestWrapper);
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
                $this->writeDebug($response);
                $this->writeDebug((string) $response->getBody());
            } catch (RequestException $e) {
                $hasResponse = !empty($e->hasResponse());
                $body = (string) ($hasResponse ? $e->getResponse()->getBody() : '[NULL response]');
                $this->writeDebug($e->getResponse());
                $this->writeDebug($body);

                throw new ApiException(
                    "[{$e->getCode()}] {$body}",
                    (int) $e->getCode(),
                    $hasResponse ? $e->getResponse()->getHeaders() : null,
                    $body
                );
            } catch (ConnectException $e) {
                $this->writeDebug($e->getMessage());

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }
            switch ($statusCode) {
                case 200:
                    if ('\Walmart\Models\MP\US\Fulfillment\ServiceResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        $contentType = $response->getHeader('Content-Type')[0] ?? '';
                        if ('\Walmart\Models\MP\US\Fulfillment\ServiceResponse' !== 'string') {
                            $content = $contentType === 'application/xml' ? simplexml_load_string($content) : json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, '\Walmart\Models\MP\US\Fulfillment\ServiceResponse', $response->getHeaders());
            }

            $returnType = '\Walmart\Models\MP\US\Fulfillment\ServiceResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                $contentType = $response->getHeader('Content-Type')[0] ?? '';
                if ($returnType !== 'string') {
                    $content = $contentType === 'application/xml' ? simplexml_load_string($content) : json_decode($content);
                }
            }

            return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Walmart\Models\MP\US\Fulfillment\ServiceResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }

            $this->writeDebug($e);
            throw $e;
        }
    }

    /**
     * Operation confirmCarrierRateQuoteAsync
     *
     * Confirm Carrier Rate Quote
     *
     * @param  \Walmart\Models\MP\US\Fulfillment\CarrierQuoteConfirmRequestWrapper $carrierQuoteConfirmRequestWrapper Request fields (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function confirmCarrierRateQuoteAsync(
        \Walmart\Models\MP\US\Fulfillment\CarrierQuoteConfirmRequestWrapper $carrierQuoteConfirmRequestWrapper
    ): PromiseInterface {
        return $this->confirmCarrierRateQuoteAsyncWithHttpInfo($carrierQuoteConfirmRequestWrapper)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation confirmCarrierRateQuoteAsyncWithHttpInfo
     *
     * Confirm Carrier Rate Quote
     *
     * @param  \Walmart\Models\MP\US\Fulfillment\CarrierQuoteConfirmRequestWrapper $carrierQuoteConfirmRequestWrapper Request fields (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    protected function confirmCarrierRateQuoteAsyncWithHttpInfo(
        \Walmart\Models\MP\US\Fulfillment\CarrierQuoteConfirmRequestWrapper $carrierQuoteConfirmRequestWrapper,
    ): PromiseInterface {
        $returnType = '\Walmart\Models\MP\US\Fulfillment\ServiceResponse';
        $request = $this->confirmCarrierRateQuoteRequest($carrierQuoteConfirmRequestWrapper);
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $this->writeDebug($response);
                    $this->writeDebug((string) $response->getBody());
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $hasResponse = !empty($response);
                    $body = (string) ($hasResponse ? $response->getBody() : '[NULL response]');
                    $this->writeDebug($response);
                    $statusCode = $hasResponse ? $response->getStatusCode() : $exception->getCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $body,
                    );
                }
            );
    }

    /**
     * Create request for operation 'confirmCarrierRateQuote'
     *
     * @param  \Walmart\Models\MP\US\Fulfillment\CarrierQuoteConfirmRequestWrapper $carrierQuoteConfirmRequestWrapper Request fields (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function confirmCarrierRateQuoteRequest(
        \Walmart\Models\MP\US\Fulfillment\CarrierQuoteConfirmRequestWrapper $carrierQuoteConfirmRequestWrapper,
    ): Request {
        $contentType = self::contentTypes['confirmCarrierRateQuote'];

        // verify the required parameter 'carrierQuoteConfirmRequestWrapper' is set
        if ($carrierQuoteConfirmRequestWrapper === null || (is_array($carrierQuoteConfirmRequestWrapper) && count($carrierQuoteConfirmRequestWrapper) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $carrierQuoteConfirmRequestWrapper when calling confirmCarrierRateQuote'
            );
        }
        $resourcePath = '/v3/fulfillment/carrier-rate-quote/confirm';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $method = 'POST';

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = parent::getDefaultHeaders();
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        // for model (json/xml)
        if (isset($carrierQuoteConfirmRequestWrapper)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($carrierQuoteConfirmRequestWrapper));
            } else {
                $httpBody = $carrierQuoteConfirmRequestWrapper;
            }
        } else if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        $query = ObjectSerializer::buildQuery($queryParams);
        $requestInfo = [
            'path' => $resourcePath,
            'method' => $method,
            'timestamp' => $defaultHeaders['WM_SEC.TIMESTAMP'],
            'query' => $query,
        ];

        // this endpoint requires Bearer authentication (access token)
        $token = $this->config->getAccessToken();
        if ($token) {
            $headers['WM_SEC.ACCESS_TOKEN'] = $token->accessToken;
        }

        $operationHost = $this->config->getHost();
        return new Request(
            $method,
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation convertItemForWfs
     *
     * Convert items for WFS
     *
     * @param  string $feedType Includes details of each entity in the feed. Do not set this parameter to true. (required)
     * @param  \SplFileObject $file Feed file to upload (required)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Walmart\Models\MP\US\Fulfillment\FeedId
     */
    public function convertItemForWfs(
        string $feedType,
        \SplFileObject $file
    ): \Walmart\Models\MP\US\Fulfillment\FeedId {
        return $this->convertItemForWfsWithHttpInfo($feedType, $file);
    }

    /**
     * Operation convertItemForWfsWithHttpInfo
     *
     * Convert items for WFS
     *
     * @param  string $feedType Includes details of each entity in the feed. Do not set this parameter to true. (required)
     * @param  \SplFileObject $file Feed file to upload (required)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Walmart\Models\MP\US\Fulfillment\FeedId
     */
    protected function convertItemForWfsWithHttpInfo(
        string $feedType,
        \SplFileObject $file,
    ): \Walmart\Models\MP\US\Fulfillment\FeedId {
        $request = $this->convertItemForWfsRequest($feedType, $file);
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
                $this->writeDebug($response);
                $this->writeDebug((string) $response->getBody());
            } catch (RequestException $e) {
                $hasResponse = !empty($e->hasResponse());
                $body = (string) ($hasResponse ? $e->getResponse()->getBody() : '[NULL response]');
                $this->writeDebug($e->getResponse());
                $this->writeDebug($body);

                throw new ApiException(
                    "[{$e->getCode()}] {$body}",
                    (int) $e->getCode(),
                    $hasResponse ? $e->getResponse()->getHeaders() : null,
                    $body
                );
            } catch (ConnectException $e) {
                $this->writeDebug($e->getMessage());

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }
            switch ($statusCode) {
                case 200:
                    if ('\Walmart\Models\MP\US\Fulfillment\FeedId' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        $contentType = $response->getHeader('Content-Type')[0] ?? '';
                        if ('\Walmart\Models\MP\US\Fulfillment\FeedId' !== 'string') {
                            $content = $contentType === 'application/xml' ? simplexml_load_string($content) : json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, '\Walmart\Models\MP\US\Fulfillment\FeedId', $response->getHeaders());
            }

            $returnType = '\Walmart\Models\MP\US\Fulfillment\FeedId';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                $contentType = $response->getHeader('Content-Type')[0] ?? '';
                if ($returnType !== 'string') {
                    $content = $contentType === 'application/xml' ? simplexml_load_string($content) : json_decode($content);
                }
            }

            return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Walmart\Models\MP\US\Fulfillment\FeedId',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }

            $this->writeDebug($e);
            throw $e;
        }
    }

    /**
     * Operation convertItemForWfsAsync
     *
     * Convert items for WFS
     *
     * @param  string $feedType Includes details of each entity in the feed. Do not set this parameter to true. (required)
     * @param  \SplFileObject $file Feed file to upload (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function convertItemForWfsAsync(
        string $feedType,
        \SplFileObject $file
    ): PromiseInterface {
        return $this->convertItemForWfsAsyncWithHttpInfo($feedType, $file)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation convertItemForWfsAsyncWithHttpInfo
     *
     * Convert items for WFS
     *
     * @param  string $feedType Includes details of each entity in the feed. Do not set this parameter to true. (required)
     * @param  \SplFileObject $file Feed file to upload (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    protected function convertItemForWfsAsyncWithHttpInfo(
        string $feedType,
        \SplFileObject $file,
    ): PromiseInterface {
        $returnType = '\Walmart\Models\MP\US\Fulfillment\FeedId';
        $request = $this->convertItemForWfsRequest($feedType, $file);
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $this->writeDebug($response);
                    $this->writeDebug((string) $response->getBody());
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $hasResponse = !empty($response);
                    $body = (string) ($hasResponse ? $response->getBody() : '[NULL response]');
                    $this->writeDebug($response);
                    $statusCode = $hasResponse ? $response->getStatusCode() : $exception->getCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $body,
                    );
                }
            );
    }

    /**
     * Create request for operation 'convertItemForWfs'
     *
     * @param  string $feedType Includes details of each entity in the feed. Do not set this parameter to true. (required)
     * @param  \SplFileObject $file Feed file to upload (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function convertItemForWfsRequest(
        string $feedType,
        \SplFileObject $file,
    ): Request {
        $contentType = self::contentTypes['convertItemForWfs'];

        // verify the required parameter 'feedType' is set
        if ($feedType === null || (is_array($feedType) && count($feedType) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $feedType when calling convertItemForWfs'
            );
        }
        // verify the required parameter 'file' is set
        if ($file === null || (is_array($file) && count($file) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $file when calling convertItemForWfs'
            );
        }
        $resourcePath = '/v3/feeds';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $method = 'POST';

        // query params
        $queryParams = array_merge(
            ObjectSerializer::toQueryValue(
                $feedType,
                'feedType', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                true // required
            ) ?? [],
        );

        // form params
        if ($file !== null) {
            $multipart = true;
            $formParams['file'] = [];
            $paramFiles = is_array($file) ? $file : [$file];
            foreach ($paramFiles as $paramFile) {
                $formParams['file'][] = \GuzzleHttp\Psr7\Utils::tryFopen(
                    ObjectSerializer::toFormValue($paramFile),
                    'rb'
                );
            }
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = parent::getDefaultHeaders();
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        $query = ObjectSerializer::buildQuery($queryParams);
        $requestInfo = [
            'path' => $resourcePath,
            'method' => $method,
            'timestamp' => $defaultHeaders['WM_SEC.TIMESTAMP'],
            'query' => $query,
        ];

        // this endpoint requires Bearer authentication (access token)
        $token = $this->config->getAccessToken();
        if ($token) {
            $headers['WM_SEC.ACCESS_TOKEN'] = $token->accessToken;
        }

        $operationHost = $this->config->getHost();
        return new Request(
            $method,
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createCarrierRateQuotes
     *
     * Create Carrier Rate Quote
     *
     * @param  \Walmart\Models\MP\US\Fulfillment\CarrierQuoteRequestV2Wrapper $carrierQuoteRequestV2Wrapper Request fields (required)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Walmart\Models\MP\US\Fulfillment\QuoteResponseV2Wrapper
     */
    public function createCarrierRateQuotes(
        \Walmart\Models\MP\US\Fulfillment\CarrierQuoteRequestV2Wrapper $carrierQuoteRequestV2Wrapper
    ): \Walmart\Models\MP\US\Fulfillment\QuoteResponseV2Wrapper {
        return $this->createCarrierRateQuotesWithHttpInfo($carrierQuoteRequestV2Wrapper);
    }

    /**
     * Operation createCarrierRateQuotesWithHttpInfo
     *
     * Create Carrier Rate Quote
     *
     * @param  \Walmart\Models\MP\US\Fulfillment\CarrierQuoteRequestV2Wrapper $carrierQuoteRequestV2Wrapper Request fields (required)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Walmart\Models\MP\US\Fulfillment\QuoteResponseV2Wrapper
     */
    protected function createCarrierRateQuotesWithHttpInfo(
        \Walmart\Models\MP\US\Fulfillment\CarrierQuoteRequestV2Wrapper $carrierQuoteRequestV2Wrapper,
    ): \Walmart\Models\MP\US\Fulfillment\QuoteResponseV2Wrapper {
        $request = $this->createCarrierRateQuotesRequest($carrierQuoteRequestV2Wrapper);
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
                $this->writeDebug($response);
                $this->writeDebug((string) $response->getBody());
            } catch (RequestException $e) {
                $hasResponse = !empty($e->hasResponse());
                $body = (string) ($hasResponse ? $e->getResponse()->getBody() : '[NULL response]');
                $this->writeDebug($e->getResponse());
                $this->writeDebug($body);

                throw new ApiException(
                    "[{$e->getCode()}] {$body}",
                    (int) $e->getCode(),
                    $hasResponse ? $e->getResponse()->getHeaders() : null,
                    $body
                );
            } catch (ConnectException $e) {
                $this->writeDebug($e->getMessage());

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }
            switch ($statusCode) {
                case 200:
                    if ('\Walmart\Models\MP\US\Fulfillment\QuoteResponseV2Wrapper' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        $contentType = $response->getHeader('Content-Type')[0] ?? '';
                        if ('\Walmart\Models\MP\US\Fulfillment\QuoteResponseV2Wrapper' !== 'string') {
                            $content = $contentType === 'application/xml' ? simplexml_load_string($content) : json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, '\Walmart\Models\MP\US\Fulfillment\QuoteResponseV2Wrapper', $response->getHeaders());
            }

            $returnType = '\Walmart\Models\MP\US\Fulfillment\QuoteResponseV2Wrapper';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                $contentType = $response->getHeader('Content-Type')[0] ?? '';
                if ($returnType !== 'string') {
                    $content = $contentType === 'application/xml' ? simplexml_load_string($content) : json_decode($content);
                }
            }

            return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Walmart\Models\MP\US\Fulfillment\QuoteResponseV2Wrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }

            $this->writeDebug($e);
            throw $e;
        }
    }

    /**
     * Operation createCarrierRateQuotesAsync
     *
     * Create Carrier Rate Quote
     *
     * @param  \Walmart\Models\MP\US\Fulfillment\CarrierQuoteRequestV2Wrapper $carrierQuoteRequestV2Wrapper Request fields (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createCarrierRateQuotesAsync(
        \Walmart\Models\MP\US\Fulfillment\CarrierQuoteRequestV2Wrapper $carrierQuoteRequestV2Wrapper
    ): PromiseInterface {
        return $this->createCarrierRateQuotesAsyncWithHttpInfo($carrierQuoteRequestV2Wrapper)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createCarrierRateQuotesAsyncWithHttpInfo
     *
     * Create Carrier Rate Quote
     *
     * @param  \Walmart\Models\MP\US\Fulfillment\CarrierQuoteRequestV2Wrapper $carrierQuoteRequestV2Wrapper Request fields (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    protected function createCarrierRateQuotesAsyncWithHttpInfo(
        \Walmart\Models\MP\US\Fulfillment\CarrierQuoteRequestV2Wrapper $carrierQuoteRequestV2Wrapper,
    ): PromiseInterface {
        $returnType = '\Walmart\Models\MP\US\Fulfillment\QuoteResponseV2Wrapper';
        $request = $this->createCarrierRateQuotesRequest($carrierQuoteRequestV2Wrapper);
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $this->writeDebug($response);
                    $this->writeDebug((string) $response->getBody());
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $hasResponse = !empty($response);
                    $body = (string) ($hasResponse ? $response->getBody() : '[NULL response]');
                    $this->writeDebug($response);
                    $statusCode = $hasResponse ? $response->getStatusCode() : $exception->getCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $body,
                    );
                }
            );
    }

    /**
     * Create request for operation 'createCarrierRateQuotes'
     *
     * @param  \Walmart\Models\MP\US\Fulfillment\CarrierQuoteRequestV2Wrapper $carrierQuoteRequestV2Wrapper Request fields (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createCarrierRateQuotesRequest(
        \Walmart\Models\MP\US\Fulfillment\CarrierQuoteRequestV2Wrapper $carrierQuoteRequestV2Wrapper,
    ): Request {
        $contentType = self::contentTypes['createCarrierRateQuotes'];

        // verify the required parameter 'carrierQuoteRequestV2Wrapper' is set
        if ($carrierQuoteRequestV2Wrapper === null || (is_array($carrierQuoteRequestV2Wrapper) && count($carrierQuoteRequestV2Wrapper) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $carrierQuoteRequestV2Wrapper when calling createCarrierRateQuotes'
            );
        }
        $resourcePath = '/v3/fulfillment/carrier-rate-quotes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $method = 'POST';

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = parent::getDefaultHeaders();
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        // for model (json/xml)
        if (isset($carrierQuoteRequestV2Wrapper)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($carrierQuoteRequestV2Wrapper));
            } else {
                $httpBody = $carrierQuoteRequestV2Wrapper;
            }
        } else if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        $query = ObjectSerializer::buildQuery($queryParams);
        $requestInfo = [
            'path' => $resourcePath,
            'method' => $method,
            'timestamp' => $defaultHeaders['WM_SEC.TIMESTAMP'],
            'query' => $query,
        ];

        // this endpoint requires Bearer authentication (access token)
        $token = $this->config->getAccessToken();
        if ($token) {
            $headers['WM_SEC.ACCESS_TOKEN'] = $token->accessToken;
        }

        $operationHost = $this->config->getHost();
        return new Request(
            $method,
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createFulfillment
     *
     * Create Customer Order
     *
     * @param  \Walmart\Models\MP\US\Fulfillment\CreateCustomerOrderRequestWrapper $createCustomerOrderRequestWrapper Request fields (required)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Walmart\Models\MP\US\Fulfillment\CustomerOrderDetailsResponseWrapperDTO
     */
    public function createFulfillment(
        \Walmart\Models\MP\US\Fulfillment\CreateCustomerOrderRequestWrapper $createCustomerOrderRequestWrapper
    ): \Walmart\Models\MP\US\Fulfillment\CustomerOrderDetailsResponseWrapperDTO {
        return $this->createFulfillmentWithHttpInfo($createCustomerOrderRequestWrapper);
    }

    /**
     * Operation createFulfillmentWithHttpInfo
     *
     * Create Customer Order
     *
     * @param  \Walmart\Models\MP\US\Fulfillment\CreateCustomerOrderRequestWrapper $createCustomerOrderRequestWrapper Request fields (required)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Walmart\Models\MP\US\Fulfillment\CustomerOrderDetailsResponseWrapperDTO
     */
    protected function createFulfillmentWithHttpInfo(
        \Walmart\Models\MP\US\Fulfillment\CreateCustomerOrderRequestWrapper $createCustomerOrderRequestWrapper,
    ): \Walmart\Models\MP\US\Fulfillment\CustomerOrderDetailsResponseWrapperDTO {
        $request = $this->createFulfillmentRequest($createCustomerOrderRequestWrapper);
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
                $this->writeDebug($response);
                $this->writeDebug((string) $response->getBody());
            } catch (RequestException $e) {
                $hasResponse = !empty($e->hasResponse());
                $body = (string) ($hasResponse ? $e->getResponse()->getBody() : '[NULL response]');
                $this->writeDebug($e->getResponse());
                $this->writeDebug($body);

                throw new ApiException(
                    "[{$e->getCode()}] {$body}",
                    (int) $e->getCode(),
                    $hasResponse ? $e->getResponse()->getHeaders() : null,
                    $body
                );
            } catch (ConnectException $e) {
                $this->writeDebug($e->getMessage());

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }
            switch ($statusCode) {
                case 200:
                    if ('\Walmart\Models\MP\US\Fulfillment\CustomerOrderDetailsResponseWrapperDTO' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        $contentType = $response->getHeader('Content-Type')[0] ?? '';
                        if ('\Walmart\Models\MP\US\Fulfillment\CustomerOrderDetailsResponseWrapperDTO' !== 'string') {
                            $content = $contentType === 'application/xml' ? simplexml_load_string($content) : json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, '\Walmart\Models\MP\US\Fulfillment\CustomerOrderDetailsResponseWrapperDTO', $response->getHeaders());
            }

            $returnType = '\Walmart\Models\MP\US\Fulfillment\CustomerOrderDetailsResponseWrapperDTO';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                $contentType = $response->getHeader('Content-Type')[0] ?? '';
                if ($returnType !== 'string') {
                    $content = $contentType === 'application/xml' ? simplexml_load_string($content) : json_decode($content);
                }
            }

            return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Walmart\Models\MP\US\Fulfillment\CustomerOrderDetailsResponseWrapperDTO',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }

            $this->writeDebug($e);
            throw $e;
        }
    }

    /**
     * Operation createFulfillmentAsync
     *
     * Create Customer Order
     *
     * @param  \Walmart\Models\MP\US\Fulfillment\CreateCustomerOrderRequestWrapper $createCustomerOrderRequestWrapper Request fields (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createFulfillmentAsync(
        \Walmart\Models\MP\US\Fulfillment\CreateCustomerOrderRequestWrapper $createCustomerOrderRequestWrapper
    ): PromiseInterface {
        return $this->createFulfillmentAsyncWithHttpInfo($createCustomerOrderRequestWrapper)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createFulfillmentAsyncWithHttpInfo
     *
     * Create Customer Order
     *
     * @param  \Walmart\Models\MP\US\Fulfillment\CreateCustomerOrderRequestWrapper $createCustomerOrderRequestWrapper Request fields (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    protected function createFulfillmentAsyncWithHttpInfo(
        \Walmart\Models\MP\US\Fulfillment\CreateCustomerOrderRequestWrapper $createCustomerOrderRequestWrapper,
    ): PromiseInterface {
        $returnType = '\Walmart\Models\MP\US\Fulfillment\CustomerOrderDetailsResponseWrapperDTO';
        $request = $this->createFulfillmentRequest($createCustomerOrderRequestWrapper);
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $this->writeDebug($response);
                    $this->writeDebug((string) $response->getBody());
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $hasResponse = !empty($response);
                    $body = (string) ($hasResponse ? $response->getBody() : '[NULL response]');
                    $this->writeDebug($response);
                    $statusCode = $hasResponse ? $response->getStatusCode() : $exception->getCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $body,
                    );
                }
            );
    }

    /**
     * Create request for operation 'createFulfillment'
     *
     * @param  \Walmart\Models\MP\US\Fulfillment\CreateCustomerOrderRequestWrapper $createCustomerOrderRequestWrapper Request fields (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createFulfillmentRequest(
        \Walmart\Models\MP\US\Fulfillment\CreateCustomerOrderRequestWrapper $createCustomerOrderRequestWrapper,
    ): Request {
        $contentType = self::contentTypes['createFulfillment'];

        // verify the required parameter 'createCustomerOrderRequestWrapper' is set
        if ($createCustomerOrderRequestWrapper === null || (is_array($createCustomerOrderRequestWrapper) && count($createCustomerOrderRequestWrapper) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $createCustomerOrderRequestWrapper when calling createFulfillment'
            );
        }
        $resourcePath = '/v3/fulfillment/orders-fulfillments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $method = 'POST';

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = parent::getDefaultHeaders();
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        // for model (json/xml)
        if (isset($createCustomerOrderRequestWrapper)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($createCustomerOrderRequestWrapper));
            } else {
                $httpBody = $createCustomerOrderRequestWrapper;
            }
        } else if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        $query = ObjectSerializer::buildQuery($queryParams);
        $requestInfo = [
            'path' => $resourcePath,
            'method' => $method,
            'timestamp' => $defaultHeaders['WM_SEC.TIMESTAMP'],
            'query' => $query,
        ];

        // this endpoint requires Bearer authentication (access token)
        $token = $this->config->getAccessToken();
        if ($token) {
            $headers['WM_SEC.ACCESS_TOKEN'] = $token->accessToken;
        }

        $operationHost = $this->config->getHost();
        return new Request(
            $method,
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createInboundShipmentLabel
     *
     * Create Inbound Shipment label (deprecated)
     *
     * @param  string $shipmentId Unique ID identifying inbound shipment (required)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function createInboundShipmentLabel(
        string $shipmentId
    ): string {
        return $this->createInboundShipmentLabelWithHttpInfo($shipmentId);
    }

    /**
     * Operation createInboundShipmentLabelWithHttpInfo
     *
     * Create Inbound Shipment label (deprecated)
     *
     * @param  string $shipmentId Unique ID identifying inbound shipment (required)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    protected function createInboundShipmentLabelWithHttpInfo(
        string $shipmentId,
    ): string {
        $request = $this->createInboundShipmentLabelRequest($shipmentId);
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
                $this->writeDebug($response);
                $this->writeDebug((string) $response->getBody());
            } catch (RequestException $e) {
                $hasResponse = !empty($e->hasResponse());
                $body = (string) ($hasResponse ? $e->getResponse()->getBody() : '[NULL response]');
                $this->writeDebug($e->getResponse());
                $this->writeDebug($body);

                throw new ApiException(
                    "[{$e->getCode()}] {$body}",
                    (int) $e->getCode(),
                    $hasResponse ? $e->getResponse()->getHeaders() : null,
                    $body
                );
            } catch (ConnectException $e) {
                $this->writeDebug($e->getMessage());

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }
            switch ($statusCode) {
                case 200:
                    if ('string' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        $contentType = $response->getHeader('Content-Type')[0] ?? '';
                        if ('string' !== 'string') {
                            $content = $contentType === 'application/xml' ? simplexml_load_string($content) : json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, 'string', $response->getHeaders());
            }

            $returnType = 'string';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                $contentType = $response->getHeader('Content-Type')[0] ?? '';
                if ($returnType !== 'string') {
                    $content = $contentType === 'application/xml' ? simplexml_load_string($content) : json_decode($content);
                }
            }

            return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }

            $this->writeDebug($e);
            throw $e;
        }
    }

    /**
     * Operation createInboundShipmentLabelAsync
     *
     * Create Inbound Shipment label (deprecated)
     *
     * @param  string $shipmentId Unique ID identifying inbound shipment (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createInboundShipmentLabelAsync(
        string $shipmentId
    ): PromiseInterface {
        return $this->createInboundShipmentLabelAsyncWithHttpInfo($shipmentId)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createInboundShipmentLabelAsyncWithHttpInfo
     *
     * Create Inbound Shipment label (deprecated)
     *
     * @param  string $shipmentId Unique ID identifying inbound shipment (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    protected function createInboundShipmentLabelAsyncWithHttpInfo(
        string $shipmentId,
    ): PromiseInterface {
        $returnType = 'string';
        $request = $this->createInboundShipmentLabelRequest($shipmentId);
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $this->writeDebug($response);
                    $this->writeDebug((string) $response->getBody());
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $hasResponse = !empty($response);
                    $body = (string) ($hasResponse ? $response->getBody() : '[NULL response]');
                    $this->writeDebug($response);
                    $statusCode = $hasResponse ? $response->getStatusCode() : $exception->getCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $body,
                    );
                }
            );
    }

    /**
     * Create request for operation 'createInboundShipmentLabel'
     *
     * @param  string $shipmentId Unique ID identifying inbound shipment (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createInboundShipmentLabelRequest(
        string $shipmentId,
    ): Request {
        $contentType = self::contentTypes['createInboundShipmentLabel'];

        // verify the required parameter 'shipmentId' is set
        if ($shipmentId === null || (is_array($shipmentId) && count($shipmentId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $shipmentId when calling createInboundShipmentLabel'
            );
        }
        $resourcePath = '/v3/fulfillment/label/{shipmentId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $method = 'GET';

        // path params
        if ($shipmentId !== null) {
            $resourcePath = str_replace(
                '{' . 'shipmentId' . '}',
                ObjectSerializer::toPathValue($shipmentId),
                $resourcePath
            );
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/pdf'],
            $contentType,
            $multipart
        );

        $defaultHeaders = parent::getDefaultHeaders();
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        $query = ObjectSerializer::buildQuery($queryParams);
        $requestInfo = [
            'path' => $resourcePath,
            'method' => $method,
            'timestamp' => $defaultHeaders['WM_SEC.TIMESTAMP'],
            'query' => $query,
        ];

        // this endpoint requires Bearer authentication (access token)
        $token = $this->config->getAccessToken();
        if ($token) {
            $headers['WM_SEC.ACCESS_TOKEN'] = $token->accessToken;
        }

        $operationHost = $this->config->getHost();
        return new Request(
            $method,
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createInboundShipmentLabelV2
     *
     * Create Inbound Shipment label
     *
     * @param  \Walmart\Models\MP\US\Fulfillment\LabelV2RequestWrapper $labelV2RequestWrapper Request fields (required)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function createInboundShipmentLabelV2(
        \Walmart\Models\MP\US\Fulfillment\LabelV2RequestWrapper $labelV2RequestWrapper
    ): string {
        return $this->createInboundShipmentLabelV2WithHttpInfo($labelV2RequestWrapper);
    }

    /**
     * Operation createInboundShipmentLabelV2WithHttpInfo
     *
     * Create Inbound Shipment label
     *
     * @param  \Walmart\Models\MP\US\Fulfillment\LabelV2RequestWrapper $labelV2RequestWrapper Request fields (required)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    protected function createInboundShipmentLabelV2WithHttpInfo(
        \Walmart\Models\MP\US\Fulfillment\LabelV2RequestWrapper $labelV2RequestWrapper,
    ): string {
        $request = $this->createInboundShipmentLabelV2Request($labelV2RequestWrapper);
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
                $this->writeDebug($response);
                $this->writeDebug((string) $response->getBody());
            } catch (RequestException $e) {
                $hasResponse = !empty($e->hasResponse());
                $body = (string) ($hasResponse ? $e->getResponse()->getBody() : '[NULL response]');
                $this->writeDebug($e->getResponse());
                $this->writeDebug($body);

                throw new ApiException(
                    "[{$e->getCode()}] {$body}",
                    (int) $e->getCode(),
                    $hasResponse ? $e->getResponse()->getHeaders() : null,
                    $body
                );
            } catch (ConnectException $e) {
                $this->writeDebug($e->getMessage());

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }
            switch ($statusCode) {
                case 200:
                    if ('string' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        $contentType = $response->getHeader('Content-Type')[0] ?? '';
                        if ('string' !== 'string') {
                            $content = $contentType === 'application/xml' ? simplexml_load_string($content) : json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, 'string', $response->getHeaders());
            }

            $returnType = 'string';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                $contentType = $response->getHeader('Content-Type')[0] ?? '';
                if ($returnType !== 'string') {
                    $content = $contentType === 'application/xml' ? simplexml_load_string($content) : json_decode($content);
                }
            }

            return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }

            $this->writeDebug($e);
            throw $e;
        }
    }

    /**
     * Operation createInboundShipmentLabelV2Async
     *
     * Create Inbound Shipment label
     *
     * @param  \Walmart\Models\MP\US\Fulfillment\LabelV2RequestWrapper $labelV2RequestWrapper Request fields (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createInboundShipmentLabelV2Async(
        \Walmart\Models\MP\US\Fulfillment\LabelV2RequestWrapper $labelV2RequestWrapper
    ): PromiseInterface {
        return $this->createInboundShipmentLabelV2AsyncWithHttpInfo($labelV2RequestWrapper)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createInboundShipmentLabelV2AsyncWithHttpInfo
     *
     * Create Inbound Shipment label
     *
     * @param  \Walmart\Models\MP\US\Fulfillment\LabelV2RequestWrapper $labelV2RequestWrapper Request fields (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    protected function createInboundShipmentLabelV2AsyncWithHttpInfo(
        \Walmart\Models\MP\US\Fulfillment\LabelV2RequestWrapper $labelV2RequestWrapper,
    ): PromiseInterface {
        $returnType = 'string';
        $request = $this->createInboundShipmentLabelV2Request($labelV2RequestWrapper);
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $this->writeDebug($response);
                    $this->writeDebug((string) $response->getBody());
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $hasResponse = !empty($response);
                    $body = (string) ($hasResponse ? $response->getBody() : '[NULL response]');
                    $this->writeDebug($response);
                    $statusCode = $hasResponse ? $response->getStatusCode() : $exception->getCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $body,
                    );
                }
            );
    }

    /**
     * Create request for operation 'createInboundShipmentLabelV2'
     *
     * @param  \Walmart\Models\MP\US\Fulfillment\LabelV2RequestWrapper $labelV2RequestWrapper Request fields (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createInboundShipmentLabelV2Request(
        \Walmart\Models\MP\US\Fulfillment\LabelV2RequestWrapper $labelV2RequestWrapper,
    ): Request {
        $contentType = self::contentTypes['createInboundShipmentLabelV2'];

        // verify the required parameter 'labelV2RequestWrapper' is set
        if ($labelV2RequestWrapper === null || (is_array($labelV2RequestWrapper) && count($labelV2RequestWrapper) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $labelV2RequestWrapper when calling createInboundShipmentLabelV2'
            );
        }
        $resourcePath = '/v3/fulfillment/shipment-label';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $method = 'POST';

        $headers = $this->headerSelector->selectHeaders(
            ['application/pdf'],
            $contentType,
            $multipart
        );

        $defaultHeaders = parent::getDefaultHeaders();
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        // for model (json/xml)
        if (isset($labelV2RequestWrapper)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($labelV2RequestWrapper));
            } else {
                $httpBody = $labelV2RequestWrapper;
            }
        } else if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        $query = ObjectSerializer::buildQuery($queryParams);
        $requestInfo = [
            'path' => $resourcePath,
            'method' => $method,
            'timestamp' => $defaultHeaders['WM_SEC.TIMESTAMP'],
            'query' => $query,
        ];

        // this endpoint requires Bearer authentication (access token)
        $token = $this->config->getAccessToken();
        if ($token) {
            $headers['WM_SEC.ACCESS_TOKEN'] = $token->accessToken;
        }

        $operationHost = $this->config->getHost();
        return new Request(
            $method,
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createShipment
     *
     * Create Inbound Shipment
     *
     * @param  \Walmart\Models\MP\US\Fulfillment\InboundShipmentRequestWrapper $inboundShipmentRequestWrapper Request fields (required)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Walmart\Models\MP\US\Fulfillment\InboundShipmentCreateResponseWrapperDTO
     */
    public function createShipment(
        \Walmart\Models\MP\US\Fulfillment\InboundShipmentRequestWrapper $inboundShipmentRequestWrapper
    ): \Walmart\Models\MP\US\Fulfillment\InboundShipmentCreateResponseWrapperDTO {
        return $this->createShipmentWithHttpInfo($inboundShipmentRequestWrapper);
    }

    /**
     * Operation createShipmentWithHttpInfo
     *
     * Create Inbound Shipment
     *
     * @param  \Walmart\Models\MP\US\Fulfillment\InboundShipmentRequestWrapper $inboundShipmentRequestWrapper Request fields (required)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Walmart\Models\MP\US\Fulfillment\InboundShipmentCreateResponseWrapperDTO
     */
    protected function createShipmentWithHttpInfo(
        \Walmart\Models\MP\US\Fulfillment\InboundShipmentRequestWrapper $inboundShipmentRequestWrapper,
    ): \Walmart\Models\MP\US\Fulfillment\InboundShipmentCreateResponseWrapperDTO {
        $request = $this->createShipmentRequest($inboundShipmentRequestWrapper);
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
                $this->writeDebug($response);
                $this->writeDebug((string) $response->getBody());
            } catch (RequestException $e) {
                $hasResponse = !empty($e->hasResponse());
                $body = (string) ($hasResponse ? $e->getResponse()->getBody() : '[NULL response]');
                $this->writeDebug($e->getResponse());
                $this->writeDebug($body);

                throw new ApiException(
                    "[{$e->getCode()}] {$body}",
                    (int) $e->getCode(),
                    $hasResponse ? $e->getResponse()->getHeaders() : null,
                    $body
                );
            } catch (ConnectException $e) {
                $this->writeDebug($e->getMessage());

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }
            switch ($statusCode) {
                case 200:
                    if ('\Walmart\Models\MP\US\Fulfillment\InboundShipmentCreateResponseWrapperDTO' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        $contentType = $response->getHeader('Content-Type')[0] ?? '';
                        if ('\Walmart\Models\MP\US\Fulfillment\InboundShipmentCreateResponseWrapperDTO' !== 'string') {
                            $content = $contentType === 'application/xml' ? simplexml_load_string($content) : json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, '\Walmart\Models\MP\US\Fulfillment\InboundShipmentCreateResponseWrapperDTO', $response->getHeaders());
            }

            $returnType = '\Walmart\Models\MP\US\Fulfillment\InboundShipmentCreateResponseWrapperDTO';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                $contentType = $response->getHeader('Content-Type')[0] ?? '';
                if ($returnType !== 'string') {
                    $content = $contentType === 'application/xml' ? simplexml_load_string($content) : json_decode($content);
                }
            }

            return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Walmart\Models\MP\US\Fulfillment\InboundShipmentCreateResponseWrapperDTO',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }

            $this->writeDebug($e);
            throw $e;
        }
    }

    /**
     * Operation createShipmentAsync
     *
     * Create Inbound Shipment
     *
     * @param  \Walmart\Models\MP\US\Fulfillment\InboundShipmentRequestWrapper $inboundShipmentRequestWrapper Request fields (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createShipmentAsync(
        \Walmart\Models\MP\US\Fulfillment\InboundShipmentRequestWrapper $inboundShipmentRequestWrapper
    ): PromiseInterface {
        return $this->createShipmentAsyncWithHttpInfo($inboundShipmentRequestWrapper)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createShipmentAsyncWithHttpInfo
     *
     * Create Inbound Shipment
     *
     * @param  \Walmart\Models\MP\US\Fulfillment\InboundShipmentRequestWrapper $inboundShipmentRequestWrapper Request fields (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    protected function createShipmentAsyncWithHttpInfo(
        \Walmart\Models\MP\US\Fulfillment\InboundShipmentRequestWrapper $inboundShipmentRequestWrapper,
    ): PromiseInterface {
        $returnType = '\Walmart\Models\MP\US\Fulfillment\InboundShipmentCreateResponseWrapperDTO';
        $request = $this->createShipmentRequest($inboundShipmentRequestWrapper);
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $this->writeDebug($response);
                    $this->writeDebug((string) $response->getBody());
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $hasResponse = !empty($response);
                    $body = (string) ($hasResponse ? $response->getBody() : '[NULL response]');
                    $this->writeDebug($response);
                    $statusCode = $hasResponse ? $response->getStatusCode() : $exception->getCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $body,
                    );
                }
            );
    }

    /**
     * Create request for operation 'createShipment'
     *
     * @param  \Walmart\Models\MP\US\Fulfillment\InboundShipmentRequestWrapper $inboundShipmentRequestWrapper Request fields (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createShipmentRequest(
        \Walmart\Models\MP\US\Fulfillment\InboundShipmentRequestWrapper $inboundShipmentRequestWrapper,
    ): Request {
        $contentType = self::contentTypes['createShipment'];

        // verify the required parameter 'inboundShipmentRequestWrapper' is set
        if ($inboundShipmentRequestWrapper === null || (is_array($inboundShipmentRequestWrapper) && count($inboundShipmentRequestWrapper) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inboundShipmentRequestWrapper when calling createShipment'
            );
        }
        $resourcePath = '/v3/fulfillment/inbound-shipments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $method = 'POST';

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = parent::getDefaultHeaders();
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        // for model (json/xml)
        if (isset($inboundShipmentRequestWrapper)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($inboundShipmentRequestWrapper));
            } else {
                $httpBody = $inboundShipmentRequestWrapper;
            }
        } else if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        $query = ObjectSerializer::buildQuery($queryParams);
        $requestInfo = [
            'path' => $resourcePath,
            'method' => $method,
            'timestamp' => $defaultHeaders['WM_SEC.TIMESTAMP'],
            'query' => $query,
        ];

        // this endpoint requires Bearer authentication (access token)
        $token = $this->config->getAccessToken();
        if ($token) {
            $headers['WM_SEC.ACCESS_TOKEN'] = $token->accessToken;
        }

        $operationHost = $this->config->getHost();
        return new Request(
            $method,
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCarrierRateQuote
     *
     * Get Carrier Rate Quote
     *
     * @param  string $shipmentId Unique ID identifying each shipment. (required)
     * @param  string $mode Shipment type. (required)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Walmart\Models\MP\US\Fulfillment\GetRateQuoteInfoResponseWrapper
     */
    public function getCarrierRateQuote(
        string $shipmentId,
        string $mode
    ): \Walmart\Models\MP\US\Fulfillment\GetRateQuoteInfoResponseWrapper {
        return $this->getCarrierRateQuoteWithHttpInfo($shipmentId, $mode);
    }

    /**
     * Operation getCarrierRateQuoteWithHttpInfo
     *
     * Get Carrier Rate Quote
     *
     * @param  string $shipmentId Unique ID identifying each shipment. (required)
     * @param  string $mode Shipment type. (required)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Walmart\Models\MP\US\Fulfillment\GetRateQuoteInfoResponseWrapper
     */
    protected function getCarrierRateQuoteWithHttpInfo(
        string $shipmentId,
        string $mode,
    ): \Walmart\Models\MP\US\Fulfillment\GetRateQuoteInfoResponseWrapper {
        $request = $this->getCarrierRateQuoteRequest($shipmentId, $mode);
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
                $this->writeDebug($response);
                $this->writeDebug((string) $response->getBody());
            } catch (RequestException $e) {
                $hasResponse = !empty($e->hasResponse());
                $body = (string) ($hasResponse ? $e->getResponse()->getBody() : '[NULL response]');
                $this->writeDebug($e->getResponse());
                $this->writeDebug($body);

                throw new ApiException(
                    "[{$e->getCode()}] {$body}",
                    (int) $e->getCode(),
                    $hasResponse ? $e->getResponse()->getHeaders() : null,
                    $body
                );
            } catch (ConnectException $e) {
                $this->writeDebug($e->getMessage());

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }
            switch ($statusCode) {
                case 200:
                    if ('\Walmart\Models\MP\US\Fulfillment\GetRateQuoteInfoResponseWrapper' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        $contentType = $response->getHeader('Content-Type')[0] ?? '';
                        if ('\Walmart\Models\MP\US\Fulfillment\GetRateQuoteInfoResponseWrapper' !== 'string') {
                            $content = $contentType === 'application/xml' ? simplexml_load_string($content) : json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, '\Walmart\Models\MP\US\Fulfillment\GetRateQuoteInfoResponseWrapper', $response->getHeaders());
            }

            $returnType = '\Walmart\Models\MP\US\Fulfillment\GetRateQuoteInfoResponseWrapper';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                $contentType = $response->getHeader('Content-Type')[0] ?? '';
                if ($returnType !== 'string') {
                    $content = $contentType === 'application/xml' ? simplexml_load_string($content) : json_decode($content);
                }
            }

            return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Walmart\Models\MP\US\Fulfillment\GetRateQuoteInfoResponseWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }

            $this->writeDebug($e);
            throw $e;
        }
    }

    /**
     * Operation getCarrierRateQuoteAsync
     *
     * Get Carrier Rate Quote
     *
     * @param  string $shipmentId Unique ID identifying each shipment. (required)
     * @param  string $mode Shipment type. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCarrierRateQuoteAsync(
        string $shipmentId,
        string $mode
    ): PromiseInterface {
        return $this->getCarrierRateQuoteAsyncWithHttpInfo($shipmentId, $mode)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCarrierRateQuoteAsyncWithHttpInfo
     *
     * Get Carrier Rate Quote
     *
     * @param  string $shipmentId Unique ID identifying each shipment. (required)
     * @param  string $mode Shipment type. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    protected function getCarrierRateQuoteAsyncWithHttpInfo(
        string $shipmentId,
        string $mode,
    ): PromiseInterface {
        $returnType = '\Walmart\Models\MP\US\Fulfillment\GetRateQuoteInfoResponseWrapper';
        $request = $this->getCarrierRateQuoteRequest($shipmentId, $mode);
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $this->writeDebug($response);
                    $this->writeDebug((string) $response->getBody());
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $hasResponse = !empty($response);
                    $body = (string) ($hasResponse ? $response->getBody() : '[NULL response]');
                    $this->writeDebug($response);
                    $statusCode = $hasResponse ? $response->getStatusCode() : $exception->getCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $body,
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCarrierRateQuote'
     *
     * @param  string $shipmentId Unique ID identifying each shipment. (required)
     * @param  string $mode Shipment type. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getCarrierRateQuoteRequest(
        string $shipmentId,
        string $mode,
    ): Request {
        $contentType = self::contentTypes['getCarrierRateQuote'];

        // verify the required parameter 'shipmentId' is set
        if ($shipmentId === null || (is_array($shipmentId) && count($shipmentId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $shipmentId when calling getCarrierRateQuote'
            );
        }
        // verify the required parameter 'mode' is set
        if ($mode === null || (is_array($mode) && count($mode) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $mode when calling getCarrierRateQuote'
            );
        }
        $resourcePath = '/v3/fulfillment/carrier-rate-quotes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $method = 'GET';

        // path params
        if ($shipmentId !== null) {
            $resourcePath = str_replace(
                '{' . 'shipmentId' . '}',
                ObjectSerializer::toPathValue($shipmentId),
                $resourcePath
            );
        }
        if ($mode !== null) {
            $resourcePath = str_replace(
                '{' . 'mode' . '}',
                ObjectSerializer::toPathValue($mode),
                $resourcePath
            );
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = parent::getDefaultHeaders();
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        $query = ObjectSerializer::buildQuery($queryParams);
        $requestInfo = [
            'path' => $resourcePath,
            'method' => $method,
            'timestamp' => $defaultHeaders['WM_SEC.TIMESTAMP'],
            'query' => $query,
        ];

        // this endpoint requires Bearer authentication (access token)
        $token = $this->config->getAccessToken();
        if ($token) {
            $headers['WM_SEC.ACCESS_TOKEN'] = $token->accessToken;
        }

        $operationHost = $this->config->getHost();
        return new Request(
            $method,
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getFulfillmentOrdersStatus
     *
     * Get fulfillment orders status
     *
     * @param  string $orgId Filtering the order based on an orgId. (required)
     * @param  string $limit Limiting the number of records fetched. Valid range is from 1 to 50 inclusive. (required)
     * @param  string $offset Setting an offset to skip records. Valid range is from 0 to 50000 inclusive. (required)
     * @param  string $orderNumber Search the order based on an order number. (optional)
     * @param  string $trackingNumber Search the order based on a tracking number. (optional)
     * @param  string $shipmentNumber Search the order based on a shipment number. (optional)
     * @param  string $fromOrderDate Search the order based on a start date (Date in YYYY-MM-DD format). (optional)
     * @param  string $toOrderDate Search the order based on an endDate date (Date in YYYY-MM-DD format). (optional)
     * @param  string $sortOrder Order of sorting (asc/desc). (optional, default to 'desc')
     * @param  string $sortBy Key on which sorting is done (Supported Attributes: orderDate). (optional)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Walmart\Models\MP\US\Fulfillment\CustomerOrderResponseWrapperDTO
     */
    public function getFulfillmentOrdersStatus(
        string $orgId,
        string $limit,
        string $offset,
        ?string $orderNumber = null,
        ?string $trackingNumber = null,
        ?string $shipmentNumber = null,
        ?string $fromOrderDate = null,
        ?string $toOrderDate = null,
        ?string $sortOrder = 'desc',
        ?string $sortBy = null
    ): \Walmart\Models\MP\US\Fulfillment\CustomerOrderResponseWrapperDTO {
        return $this->getFulfillmentOrdersStatusWithHttpInfo($orgId, $limit, $offset, $orderNumber, $trackingNumber, $shipmentNumber, $fromOrderDate, $toOrderDate, $sortOrder, $sortBy);
    }

    /**
     * Operation getFulfillmentOrdersStatusWithHttpInfo
     *
     * Get fulfillment orders status
     *
     * @param  string $orgId Filtering the order based on an orgId. (required)
     * @param  string $limit Limiting the number of records fetched. Valid range is from 1 to 50 inclusive. (required)
     * @param  string $offset Setting an offset to skip records. Valid range is from 0 to 50000 inclusive. (required)
     * @param  string $orderNumber Search the order based on an order number. (optional)
     * @param  string $trackingNumber Search the order based on a tracking number. (optional)
     * @param  string $shipmentNumber Search the order based on a shipment number. (optional)
     * @param  string $fromOrderDate Search the order based on a start date (Date in YYYY-MM-DD format). (optional)
     * @param  string $toOrderDate Search the order based on an endDate date (Date in YYYY-MM-DD format). (optional)
     * @param  string $sortOrder Order of sorting (asc/desc). (optional, default to 'desc')
     * @param  string $sortBy Key on which sorting is done (Supported Attributes: orderDate). (optional)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Walmart\Models\MP\US\Fulfillment\CustomerOrderResponseWrapperDTO
     */
    protected function getFulfillmentOrdersStatusWithHttpInfo(
        string $orgId,
        string $limit,
        string $offset,
        ?string $orderNumber = null,
        ?string $trackingNumber = null,
        ?string $shipmentNumber = null,
        ?string $fromOrderDate = null,
        ?string $toOrderDate = null,
        ?string $sortOrder = 'desc',
        ?string $sortBy = null,
    ): \Walmart\Models\MP\US\Fulfillment\CustomerOrderResponseWrapperDTO {
        $request = $this->getFulfillmentOrdersStatusRequest($orgId, $limit, $offset, $orderNumber, $trackingNumber, $shipmentNumber, $fromOrderDate, $toOrderDate, $sortOrder, $sortBy);
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
                $this->writeDebug($response);
                $this->writeDebug((string) $response->getBody());
            } catch (RequestException $e) {
                $hasResponse = !empty($e->hasResponse());
                $body = (string) ($hasResponse ? $e->getResponse()->getBody() : '[NULL response]');
                $this->writeDebug($e->getResponse());
                $this->writeDebug($body);

                throw new ApiException(
                    "[{$e->getCode()}] {$body}",
                    (int) $e->getCode(),
                    $hasResponse ? $e->getResponse()->getHeaders() : null,
                    $body
                );
            } catch (ConnectException $e) {
                $this->writeDebug($e->getMessage());

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }
            switch ($statusCode) {
                case 200:
                    if ('\Walmart\Models\MP\US\Fulfillment\CustomerOrderResponseWrapperDTO' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        $contentType = $response->getHeader('Content-Type')[0] ?? '';
                        if ('\Walmart\Models\MP\US\Fulfillment\CustomerOrderResponseWrapperDTO' !== 'string') {
                            $content = $contentType === 'application/xml' ? simplexml_load_string($content) : json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, '\Walmart\Models\MP\US\Fulfillment\CustomerOrderResponseWrapperDTO', $response->getHeaders());
            }

            $returnType = '\Walmart\Models\MP\US\Fulfillment\CustomerOrderResponseWrapperDTO';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                $contentType = $response->getHeader('Content-Type')[0] ?? '';
                if ($returnType !== 'string') {
                    $content = $contentType === 'application/xml' ? simplexml_load_string($content) : json_decode($content);
                }
            }

            return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Walmart\Models\MP\US\Fulfillment\CustomerOrderResponseWrapperDTO',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }

            $this->writeDebug($e);
            throw $e;
        }
    }

    /**
     * Operation getFulfillmentOrdersStatusAsync
     *
     * Get fulfillment orders status
     *
     * @param  string $orgId Filtering the order based on an orgId. (required)
     * @param  string $limit Limiting the number of records fetched. Valid range is from 1 to 50 inclusive. (required)
     * @param  string $offset Setting an offset to skip records. Valid range is from 0 to 50000 inclusive. (required)
     * @param  string $orderNumber Search the order based on an order number. (optional)
     * @param  string $trackingNumber Search the order based on a tracking number. (optional)
     * @param  string $shipmentNumber Search the order based on a shipment number. (optional)
     * @param  string $fromOrderDate Search the order based on a start date (Date in YYYY-MM-DD format). (optional)
     * @param  string $toOrderDate Search the order based on an endDate date (Date in YYYY-MM-DD format). (optional)
     * @param  string $sortOrder Order of sorting (asc/desc). (optional, default to 'desc')
     * @param  string $sortBy Key on which sorting is done (Supported Attributes: orderDate). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFulfillmentOrdersStatusAsync(
        string $orgId,
        string $limit,
        string $offset,
        ?string $orderNumber = null,
        ?string $trackingNumber = null,
        ?string $shipmentNumber = null,
        ?string $fromOrderDate = null,
        ?string $toOrderDate = null,
        ?string $sortOrder = 'desc',
        ?string $sortBy = null
    ): PromiseInterface {
        return $this->getFulfillmentOrdersStatusAsyncWithHttpInfo($orgId, $limit, $offset, $orderNumber, $trackingNumber, $shipmentNumber, $fromOrderDate, $toOrderDate, $sortOrder, $sortBy)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFulfillmentOrdersStatusAsyncWithHttpInfo
     *
     * Get fulfillment orders status
     *
     * @param  string $orgId Filtering the order based on an orgId. (required)
     * @param  string $limit Limiting the number of records fetched. Valid range is from 1 to 50 inclusive. (required)
     * @param  string $offset Setting an offset to skip records. Valid range is from 0 to 50000 inclusive. (required)
     * @param  string $orderNumber Search the order based on an order number. (optional)
     * @param  string $trackingNumber Search the order based on a tracking number. (optional)
     * @param  string $shipmentNumber Search the order based on a shipment number. (optional)
     * @param  string $fromOrderDate Search the order based on a start date (Date in YYYY-MM-DD format). (optional)
     * @param  string $toOrderDate Search the order based on an endDate date (Date in YYYY-MM-DD format). (optional)
     * @param  string $sortOrder Order of sorting (asc/desc). (optional, default to 'desc')
     * @param  string $sortBy Key on which sorting is done (Supported Attributes: orderDate). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    protected function getFulfillmentOrdersStatusAsyncWithHttpInfo(
        string $orgId,
        string $limit,
        string $offset,
        ?string $orderNumber = null,
        ?string $trackingNumber = null,
        ?string $shipmentNumber = null,
        ?string $fromOrderDate = null,
        ?string $toOrderDate = null,
        ?string $sortOrder = 'desc',
        ?string $sortBy = null,
    ): PromiseInterface {
        $returnType = '\Walmart\Models\MP\US\Fulfillment\CustomerOrderResponseWrapperDTO';
        $request = $this->getFulfillmentOrdersStatusRequest($orgId, $limit, $offset, $orderNumber, $trackingNumber, $shipmentNumber, $fromOrderDate, $toOrderDate, $sortOrder, $sortBy);
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $this->writeDebug($response);
                    $this->writeDebug((string) $response->getBody());
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $hasResponse = !empty($response);
                    $body = (string) ($hasResponse ? $response->getBody() : '[NULL response]');
                    $this->writeDebug($response);
                    $statusCode = $hasResponse ? $response->getStatusCode() : $exception->getCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $body,
                    );
                }
            );
    }

    /**
     * Create request for operation 'getFulfillmentOrdersStatus'
     *
     * @param  string $orgId Filtering the order based on an orgId. (required)
     * @param  string $limit Limiting the number of records fetched. Valid range is from 1 to 50 inclusive. (required)
     * @param  string $offset Setting an offset to skip records. Valid range is from 0 to 50000 inclusive. (required)
     * @param  string $orderNumber Search the order based on an order number. (optional)
     * @param  string $trackingNumber Search the order based on a tracking number. (optional)
     * @param  string $shipmentNumber Search the order based on a shipment number. (optional)
     * @param  string $fromOrderDate Search the order based on a start date (Date in YYYY-MM-DD format). (optional)
     * @param  string $toOrderDate Search the order based on an endDate date (Date in YYYY-MM-DD format). (optional)
     * @param  string $sortOrder Order of sorting (asc/desc). (optional, default to 'desc')
     * @param  string $sortBy Key on which sorting is done (Supported Attributes: orderDate). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getFulfillmentOrdersStatusRequest(
        string $orgId,
        string $limit,
        string $offset,
        ?string $orderNumber = null,
        ?string $trackingNumber = null,
        ?string $shipmentNumber = null,
        ?string $fromOrderDate = null,
        ?string $toOrderDate = null,
        ?string $sortOrder = 'desc',
        ?string $sortBy = null,
    ): Request {
        $contentType = self::contentTypes['getFulfillmentOrdersStatus'];

        // verify the required parameter 'orgId' is set
        if ($orgId === null || (is_array($orgId) && count($orgId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $orgId when calling getFulfillmentOrdersStatus'
            );
        }
        // verify the required parameter 'limit' is set
        if ($limit === null || (is_array($limit) && count($limit) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $limit when calling getFulfillmentOrdersStatus'
            );
        }
        // verify the required parameter 'offset' is set
        if ($offset === null || (is_array($offset) && count($offset) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $offset when calling getFulfillmentOrdersStatus'
            );
        }
        $resourcePath = '/v3/fulfillment/orders-fulfillments/status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $method = 'GET';

        // query params
        $queryParams = array_merge(
            ObjectSerializer::toQueryValue(
                $orgId,
                'orgId', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                true // required
            ) ?? [],
            ObjectSerializer::toQueryValue(
                $limit,
                'limit', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                true // required
            ) ?? [],
            ObjectSerializer::toQueryValue(
                $offset,
                'offset', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                true // required
            ) ?? [],
            ObjectSerializer::toQueryValue(
                $orderNumber,
                'orderNumber', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? [],
            ObjectSerializer::toQueryValue(
                $trackingNumber,
                'trackingNumber', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? [],
            ObjectSerializer::toQueryValue(
                $shipmentNumber,
                'shipmentNumber', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? [],
            ObjectSerializer::toQueryValue(
                $fromOrderDate,
                'fromOrderDate', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? [],
            ObjectSerializer::toQueryValue(
                $toOrderDate,
                'toOrderDate', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? [],
            ObjectSerializer::toQueryValue(
                $sortOrder,
                'sortOrder', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? [],
            ObjectSerializer::toQueryValue(
                $sortBy,
                'sortBy', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? [],
        );

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = parent::getDefaultHeaders();
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        $query = ObjectSerializer::buildQuery($queryParams);
        $requestInfo = [
            'path' => $resourcePath,
            'method' => $method,
            'timestamp' => $defaultHeaders['WM_SEC.TIMESTAMP'],
            'query' => $query,
        ];

        // this endpoint requires Bearer authentication (access token)
        $token = $this->config->getAccessToken();
        if ($token) {
            $headers['WM_SEC.ACCESS_TOKEN'] = $token->accessToken;
        }

        $operationHost = $this->config->getHost();
        return new Request(
            $method,
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getInboundOrderErrors
     *
     * Get Inbound Shipment errors
     *
     * @param  string $offset offset is the number of records you wish to skip before selecting records. (optional, default to '0')
     * @param  string $limit The number of Purchase Orders to be returned. (optional, default to '10')
     * @param  string $shipmentId Unique ID identifying each shipment. (optional)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Walmart\Models\MP\US\Fulfillment\InboundShipmentErrorResponseWrapperDTO
     */
    public function getInboundOrderErrors(
        ?string $offset = '0',
        ?string $limit = '10',
        ?string $shipmentId = null
    ): \Walmart\Models\MP\US\Fulfillment\InboundShipmentErrorResponseWrapperDTO {
        return $this->getInboundOrderErrorsWithHttpInfo($offset, $limit, $shipmentId);
    }

    /**
     * Operation getInboundOrderErrorsWithHttpInfo
     *
     * Get Inbound Shipment errors
     *
     * @param  string $offset offset is the number of records you wish to skip before selecting records. (optional, default to '0')
     * @param  string $limit The number of Purchase Orders to be returned. (optional, default to '10')
     * @param  string $shipmentId Unique ID identifying each shipment. (optional)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Walmart\Models\MP\US\Fulfillment\InboundShipmentErrorResponseWrapperDTO
     */
    protected function getInboundOrderErrorsWithHttpInfo(
        ?string $offset = '0',
        ?string $limit = '10',
        ?string $shipmentId = null,
    ): \Walmart\Models\MP\US\Fulfillment\InboundShipmentErrorResponseWrapperDTO {
        $request = $this->getInboundOrderErrorsRequest($offset, $limit, $shipmentId);
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
                $this->writeDebug($response);
                $this->writeDebug((string) $response->getBody());
            } catch (RequestException $e) {
                $hasResponse = !empty($e->hasResponse());
                $body = (string) ($hasResponse ? $e->getResponse()->getBody() : '[NULL response]');
                $this->writeDebug($e->getResponse());
                $this->writeDebug($body);

                throw new ApiException(
                    "[{$e->getCode()}] {$body}",
                    (int) $e->getCode(),
                    $hasResponse ? $e->getResponse()->getHeaders() : null,
                    $body
                );
            } catch (ConnectException $e) {
                $this->writeDebug($e->getMessage());

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }
            switch ($statusCode) {
                case 200:
                    if ('\Walmart\Models\MP\US\Fulfillment\InboundShipmentErrorResponseWrapperDTO' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        $contentType = $response->getHeader('Content-Type')[0] ?? '';
                        if ('\Walmart\Models\MP\US\Fulfillment\InboundShipmentErrorResponseWrapperDTO' !== 'string') {
                            $content = $contentType === 'application/xml' ? simplexml_load_string($content) : json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, '\Walmart\Models\MP\US\Fulfillment\InboundShipmentErrorResponseWrapperDTO', $response->getHeaders());
            }

            $returnType = '\Walmart\Models\MP\US\Fulfillment\InboundShipmentErrorResponseWrapperDTO';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                $contentType = $response->getHeader('Content-Type')[0] ?? '';
                if ($returnType !== 'string') {
                    $content = $contentType === 'application/xml' ? simplexml_load_string($content) : json_decode($content);
                }
            }

            return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Walmart\Models\MP\US\Fulfillment\InboundShipmentErrorResponseWrapperDTO',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }

            $this->writeDebug($e);
            throw $e;
        }
    }

    /**
     * Operation getInboundOrderErrorsAsync
     *
     * Get Inbound Shipment errors
     *
     * @param  string $offset offset is the number of records you wish to skip before selecting records. (optional, default to '0')
     * @param  string $limit The number of Purchase Orders to be returned. (optional, default to '10')
     * @param  string $shipmentId Unique ID identifying each shipment. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getInboundOrderErrorsAsync(
        ?string $offset = '0',
        ?string $limit = '10',
        ?string $shipmentId = null
    ): PromiseInterface {
        return $this->getInboundOrderErrorsAsyncWithHttpInfo($offset, $limit, $shipmentId)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getInboundOrderErrorsAsyncWithHttpInfo
     *
     * Get Inbound Shipment errors
     *
     * @param  string $offset offset is the number of records you wish to skip before selecting records. (optional, default to '0')
     * @param  string $limit The number of Purchase Orders to be returned. (optional, default to '10')
     * @param  string $shipmentId Unique ID identifying each shipment. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    protected function getInboundOrderErrorsAsyncWithHttpInfo(
        ?string $offset = '0',
        ?string $limit = '10',
        ?string $shipmentId = null,
    ): PromiseInterface {
        $returnType = '\Walmart\Models\MP\US\Fulfillment\InboundShipmentErrorResponseWrapperDTO';
        $request = $this->getInboundOrderErrorsRequest($offset, $limit, $shipmentId);
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $this->writeDebug($response);
                    $this->writeDebug((string) $response->getBody());
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $hasResponse = !empty($response);
                    $body = (string) ($hasResponse ? $response->getBody() : '[NULL response]');
                    $this->writeDebug($response);
                    $statusCode = $hasResponse ? $response->getStatusCode() : $exception->getCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $body,
                    );
                }
            );
    }

    /**
     * Create request for operation 'getInboundOrderErrors'
     *
     * @param  string $offset offset is the number of records you wish to skip before selecting records. (optional, default to '0')
     * @param  string $limit The number of Purchase Orders to be returned. (optional, default to '10')
     * @param  string $shipmentId Unique ID identifying each shipment. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getInboundOrderErrorsRequest(
        ?string $offset = '0',
        ?string $limit = '10',
        ?string $shipmentId = null,
    ): Request {
        $contentType = self::contentTypes['getInboundOrderErrors'];

        $resourcePath = '/v3/fulfillment/inbound-shipment-errors';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $method = 'GET';

        // query params
        $queryParams = array_merge(
            ObjectSerializer::toQueryValue(
                $offset,
                'offset', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? [],
            ObjectSerializer::toQueryValue(
                $limit,
                'limit', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? [],
            ObjectSerializer::toQueryValue(
                $shipmentId,
                'shipmentId', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? [],
        );

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = parent::getDefaultHeaders();
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        $query = ObjectSerializer::buildQuery($queryParams);
        $requestInfo = [
            'path' => $resourcePath,
            'method' => $method,
            'timestamp' => $defaultHeaders['WM_SEC.TIMESTAMP'],
            'query' => $query,
        ];

        // this endpoint requires Bearer authentication (access token)
        $token = $this->config->getAccessToken();
        if ($token) {
            $headers['WM_SEC.ACCESS_TOKEN'] = $token->accessToken;
        }

        $operationHost = $this->config->getHost();
        return new Request(
            $method,
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getInboundShipmentItems
     *
     * Get Inbound Shipment Items
     *
     * @param  string $offset offset is the number of records you wish to skip before selecting records. (optional, default to '0')
     * @param  string $limit The number of Purchase Orders to be returned. (optional, default to '10')
     * @param  string $shipmentId Unique ID identifying each shipment. (optional)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Walmart\Models\MP\US\Fulfillment\InboundShipmentErrorResponseWrapperDTO
     */
    public function getInboundShipmentItems(
        ?string $offset = '0',
        ?string $limit = '10',
        ?string $shipmentId = null
    ): \Walmart\Models\MP\US\Fulfillment\InboundShipmentErrorResponseWrapperDTO {
        return $this->getInboundShipmentItemsWithHttpInfo($offset, $limit, $shipmentId);
    }

    /**
     * Operation getInboundShipmentItemsWithHttpInfo
     *
     * Get Inbound Shipment Items
     *
     * @param  string $offset offset is the number of records you wish to skip before selecting records. (optional, default to '0')
     * @param  string $limit The number of Purchase Orders to be returned. (optional, default to '10')
     * @param  string $shipmentId Unique ID identifying each shipment. (optional)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Walmart\Models\MP\US\Fulfillment\InboundShipmentErrorResponseWrapperDTO
     */
    protected function getInboundShipmentItemsWithHttpInfo(
        ?string $offset = '0',
        ?string $limit = '10',
        ?string $shipmentId = null,
    ): \Walmart\Models\MP\US\Fulfillment\InboundShipmentErrorResponseWrapperDTO {
        $request = $this->getInboundShipmentItemsRequest($offset, $limit, $shipmentId);
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
                $this->writeDebug($response);
                $this->writeDebug((string) $response->getBody());
            } catch (RequestException $e) {
                $hasResponse = !empty($e->hasResponse());
                $body = (string) ($hasResponse ? $e->getResponse()->getBody() : '[NULL response]');
                $this->writeDebug($e->getResponse());
                $this->writeDebug($body);

                throw new ApiException(
                    "[{$e->getCode()}] {$body}",
                    (int) $e->getCode(),
                    $hasResponse ? $e->getResponse()->getHeaders() : null,
                    $body
                );
            } catch (ConnectException $e) {
                $this->writeDebug($e->getMessage());

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }
            switch ($statusCode) {
                case 200:
                    if ('\Walmart\Models\MP\US\Fulfillment\InboundShipmentErrorResponseWrapperDTO' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        $contentType = $response->getHeader('Content-Type')[0] ?? '';
                        if ('\Walmart\Models\MP\US\Fulfillment\InboundShipmentErrorResponseWrapperDTO' !== 'string') {
                            $content = $contentType === 'application/xml' ? simplexml_load_string($content) : json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, '\Walmart\Models\MP\US\Fulfillment\InboundShipmentErrorResponseWrapperDTO', $response->getHeaders());
            }

            $returnType = '\Walmart\Models\MP\US\Fulfillment\InboundShipmentErrorResponseWrapperDTO';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                $contentType = $response->getHeader('Content-Type')[0] ?? '';
                if ($returnType !== 'string') {
                    $content = $contentType === 'application/xml' ? simplexml_load_string($content) : json_decode($content);
                }
            }

            return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Walmart\Models\MP\US\Fulfillment\InboundShipmentErrorResponseWrapperDTO',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }

            $this->writeDebug($e);
            throw $e;
        }
    }

    /**
     * Operation getInboundShipmentItemsAsync
     *
     * Get Inbound Shipment Items
     *
     * @param  string $offset offset is the number of records you wish to skip before selecting records. (optional, default to '0')
     * @param  string $limit The number of Purchase Orders to be returned. (optional, default to '10')
     * @param  string $shipmentId Unique ID identifying each shipment. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getInboundShipmentItemsAsync(
        ?string $offset = '0',
        ?string $limit = '10',
        ?string $shipmentId = null
    ): PromiseInterface {
        return $this->getInboundShipmentItemsAsyncWithHttpInfo($offset, $limit, $shipmentId)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getInboundShipmentItemsAsyncWithHttpInfo
     *
     * Get Inbound Shipment Items
     *
     * @param  string $offset offset is the number of records you wish to skip before selecting records. (optional, default to '0')
     * @param  string $limit The number of Purchase Orders to be returned. (optional, default to '10')
     * @param  string $shipmentId Unique ID identifying each shipment. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    protected function getInboundShipmentItemsAsyncWithHttpInfo(
        ?string $offset = '0',
        ?string $limit = '10',
        ?string $shipmentId = null,
    ): PromiseInterface {
        $returnType = '\Walmart\Models\MP\US\Fulfillment\InboundShipmentErrorResponseWrapperDTO';
        $request = $this->getInboundShipmentItemsRequest($offset, $limit, $shipmentId);
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $this->writeDebug($response);
                    $this->writeDebug((string) $response->getBody());
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $hasResponse = !empty($response);
                    $body = (string) ($hasResponse ? $response->getBody() : '[NULL response]');
                    $this->writeDebug($response);
                    $statusCode = $hasResponse ? $response->getStatusCode() : $exception->getCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $body,
                    );
                }
            );
    }

    /**
     * Create request for operation 'getInboundShipmentItems'
     *
     * @param  string $offset offset is the number of records you wish to skip before selecting records. (optional, default to '0')
     * @param  string $limit The number of Purchase Orders to be returned. (optional, default to '10')
     * @param  string $shipmentId Unique ID identifying each shipment. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getInboundShipmentItemsRequest(
        ?string $offset = '0',
        ?string $limit = '10',
        ?string $shipmentId = null,
    ): Request {
        $contentType = self::contentTypes['getInboundShipmentItems'];

        $resourcePath = '/v3/fulfillment/inbound-shipment-items';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $method = 'GET';

        // query params
        $queryParams = array_merge(
            ObjectSerializer::toQueryValue(
                $offset,
                'offset', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? [],
            ObjectSerializer::toQueryValue(
                $limit,
                'limit', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? [],
            ObjectSerializer::toQueryValue(
                $shipmentId,
                'shipmentId', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? [],
        );

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = parent::getDefaultHeaders();
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        $query = ObjectSerializer::buildQuery($queryParams);
        $requestInfo = [
            'path' => $resourcePath,
            'method' => $method,
            'timestamp' => $defaultHeaders['WM_SEC.TIMESTAMP'],
            'query' => $query,
        ];

        // this endpoint requires Bearer authentication (access token)
        $token = $this->config->getAccessToken();
        if ($token) {
            $headers['WM_SEC.ACCESS_TOKEN'] = $token->accessToken;
        }

        $operationHost = $this->config->getHost();
        return new Request(
            $method,
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getInboundShipments
     *
     * Get Shipments
     *
     * @param  string $offset offset is the number of records you wish to skip before selecting records. (optional, default to '0')
     * @param  string $limit The number of Purchase Orders to be returned. (optional, default to '10')
     * @param  string $inboundOrderId Unique ID identifying inbound shipment request. (optional)
     * @param  string $shipmentId Unique ID identifying each shipment. (optional)
     * @param  string $status Current shipment status (optional)
     * @param  string $fromCreateDate Shipment create date starting range (optional)
     * @param  string $toCreateDate Shipment create date starting  end range (optional)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Walmart\Models\MP\US\Fulfillment\InboundShipmentErrorResponseWrapperDTO
     */
    public function getInboundShipments(
        ?string $offset = '0',
        ?string $limit = '10',
        ?string $inboundOrderId = null,
        ?string $shipmentId = null,
        ?string $status = null,
        ?string $fromCreateDate = null,
        ?string $toCreateDate = null
    ): \Walmart\Models\MP\US\Fulfillment\InboundShipmentErrorResponseWrapperDTO {
        return $this->getInboundShipmentsWithHttpInfo($offset, $limit, $inboundOrderId, $shipmentId, $status, $fromCreateDate, $toCreateDate);
    }

    /**
     * Operation getInboundShipmentsWithHttpInfo
     *
     * Get Shipments
     *
     * @param  string $offset offset is the number of records you wish to skip before selecting records. (optional, default to '0')
     * @param  string $limit The number of Purchase Orders to be returned. (optional, default to '10')
     * @param  string $inboundOrderId Unique ID identifying inbound shipment request. (optional)
     * @param  string $shipmentId Unique ID identifying each shipment. (optional)
     * @param  string $status Current shipment status (optional)
     * @param  string $fromCreateDate Shipment create date starting range (optional)
     * @param  string $toCreateDate Shipment create date starting  end range (optional)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Walmart\Models\MP\US\Fulfillment\InboundShipmentErrorResponseWrapperDTO
     */
    protected function getInboundShipmentsWithHttpInfo(
        ?string $offset = '0',
        ?string $limit = '10',
        ?string $inboundOrderId = null,
        ?string $shipmentId = null,
        ?string $status = null,
        ?string $fromCreateDate = null,
        ?string $toCreateDate = null,
    ): \Walmart\Models\MP\US\Fulfillment\InboundShipmentErrorResponseWrapperDTO {
        $request = $this->getInboundShipmentsRequest($offset, $limit, $inboundOrderId, $shipmentId, $status, $fromCreateDate, $toCreateDate);
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
                $this->writeDebug($response);
                $this->writeDebug((string) $response->getBody());
            } catch (RequestException $e) {
                $hasResponse = !empty($e->hasResponse());
                $body = (string) ($hasResponse ? $e->getResponse()->getBody() : '[NULL response]');
                $this->writeDebug($e->getResponse());
                $this->writeDebug($body);

                throw new ApiException(
                    "[{$e->getCode()}] {$body}",
                    (int) $e->getCode(),
                    $hasResponse ? $e->getResponse()->getHeaders() : null,
                    $body
                );
            } catch (ConnectException $e) {
                $this->writeDebug($e->getMessage());

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }
            switch ($statusCode) {
                case 200:
                    if ('\Walmart\Models\MP\US\Fulfillment\InboundShipmentErrorResponseWrapperDTO' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        $contentType = $response->getHeader('Content-Type')[0] ?? '';
                        if ('\Walmart\Models\MP\US\Fulfillment\InboundShipmentErrorResponseWrapperDTO' !== 'string') {
                            $content = $contentType === 'application/xml' ? simplexml_load_string($content) : json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, '\Walmart\Models\MP\US\Fulfillment\InboundShipmentErrorResponseWrapperDTO', $response->getHeaders());
            }

            $returnType = '\Walmart\Models\MP\US\Fulfillment\InboundShipmentErrorResponseWrapperDTO';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                $contentType = $response->getHeader('Content-Type')[0] ?? '';
                if ($returnType !== 'string') {
                    $content = $contentType === 'application/xml' ? simplexml_load_string($content) : json_decode($content);
                }
            }

            return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Walmart\Models\MP\US\Fulfillment\InboundShipmentErrorResponseWrapperDTO',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }

            $this->writeDebug($e);
            throw $e;
        }
    }

    /**
     * Operation getInboundShipmentsAsync
     *
     * Get Shipments
     *
     * @param  string $offset offset is the number of records you wish to skip before selecting records. (optional, default to '0')
     * @param  string $limit The number of Purchase Orders to be returned. (optional, default to '10')
     * @param  string $inboundOrderId Unique ID identifying inbound shipment request. (optional)
     * @param  string $shipmentId Unique ID identifying each shipment. (optional)
     * @param  string $status Current shipment status (optional)
     * @param  string $fromCreateDate Shipment create date starting range (optional)
     * @param  string $toCreateDate Shipment create date starting  end range (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getInboundShipmentsAsync(
        ?string $offset = '0',
        ?string $limit = '10',
        ?string $inboundOrderId = null,
        ?string $shipmentId = null,
        ?string $status = null,
        ?string $fromCreateDate = null,
        ?string $toCreateDate = null
    ): PromiseInterface {
        return $this->getInboundShipmentsAsyncWithHttpInfo($offset, $limit, $inboundOrderId, $shipmentId, $status, $fromCreateDate, $toCreateDate)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getInboundShipmentsAsyncWithHttpInfo
     *
     * Get Shipments
     *
     * @param  string $offset offset is the number of records you wish to skip before selecting records. (optional, default to '0')
     * @param  string $limit The number of Purchase Orders to be returned. (optional, default to '10')
     * @param  string $inboundOrderId Unique ID identifying inbound shipment request. (optional)
     * @param  string $shipmentId Unique ID identifying each shipment. (optional)
     * @param  string $status Current shipment status (optional)
     * @param  string $fromCreateDate Shipment create date starting range (optional)
     * @param  string $toCreateDate Shipment create date starting  end range (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    protected function getInboundShipmentsAsyncWithHttpInfo(
        ?string $offset = '0',
        ?string $limit = '10',
        ?string $inboundOrderId = null,
        ?string $shipmentId = null,
        ?string $status = null,
        ?string $fromCreateDate = null,
        ?string $toCreateDate = null,
    ): PromiseInterface {
        $returnType = '\Walmart\Models\MP\US\Fulfillment\InboundShipmentErrorResponseWrapperDTO';
        $request = $this->getInboundShipmentsRequest($offset, $limit, $inboundOrderId, $shipmentId, $status, $fromCreateDate, $toCreateDate);
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $this->writeDebug($response);
                    $this->writeDebug((string) $response->getBody());
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $hasResponse = !empty($response);
                    $body = (string) ($hasResponse ? $response->getBody() : '[NULL response]');
                    $this->writeDebug($response);
                    $statusCode = $hasResponse ? $response->getStatusCode() : $exception->getCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $body,
                    );
                }
            );
    }

    /**
     * Create request for operation 'getInboundShipments'
     *
     * @param  string $offset offset is the number of records you wish to skip before selecting records. (optional, default to '0')
     * @param  string $limit The number of Purchase Orders to be returned. (optional, default to '10')
     * @param  string $inboundOrderId Unique ID identifying inbound shipment request. (optional)
     * @param  string $shipmentId Unique ID identifying each shipment. (optional)
     * @param  string $status Current shipment status (optional)
     * @param  string $fromCreateDate Shipment create date starting range (optional)
     * @param  string $toCreateDate Shipment create date starting  end range (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getInboundShipmentsRequest(
        ?string $offset = '0',
        ?string $limit = '10',
        ?string $inboundOrderId = null,
        ?string $shipmentId = null,
        ?string $status = null,
        ?string $fromCreateDate = null,
        ?string $toCreateDate = null,
    ): Request {
        $contentType = self::contentTypes['getInboundShipments'];

        $resourcePath = '/v3/fulfillment/inbound-shipments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $method = 'GET';

        // query params
        $queryParams = array_merge(
            ObjectSerializer::toQueryValue(
                $offset,
                'offset', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? [],
            ObjectSerializer::toQueryValue(
                $limit,
                'limit', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? [],
            ObjectSerializer::toQueryValue(
                $inboundOrderId,
                'inboundOrderId', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? [],
            ObjectSerializer::toQueryValue(
                $shipmentId,
                'shipmentId', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? [],
            ObjectSerializer::toQueryValue(
                $status,
                'status', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? [],
            ObjectSerializer::toQueryValue(
                $fromCreateDate,
                'fromCreateDate', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? [],
            ObjectSerializer::toQueryValue(
                $toCreateDate,
                'toCreateDate', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? [],
        );

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = parent::getDefaultHeaders();
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        $query = ObjectSerializer::buildQuery($queryParams);
        $requestInfo = [
            'path' => $resourcePath,
            'method' => $method,
            'timestamp' => $defaultHeaders['WM_SEC.TIMESTAMP'],
            'query' => $query,
        ];

        // this endpoint requires Bearer authentication (access token)
        $token = $this->config->getAccessToken();
        if ($token) {
            $headers['WM_SEC.ACCESS_TOKEN'] = $token->accessToken;
        }

        $operationHost = $this->config->getHost();
        return new Request(
            $method,
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getInventoryHealthReport
     *
     * Get WFS Inventory Health Report
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function getInventoryHealthReport(): string
    {
        return $this->getInventoryHealthReportWithHttpInfo();
    }

    /**
     * Operation getInventoryHealthReportWithHttpInfo
     *
     * Get WFS Inventory Health Report
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    protected function getInventoryHealthReportWithHttpInfo(): string
    {
        $request = $this->getInventoryHealthReportRequest();
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
                $this->writeDebug($response);
                $this->writeDebug((string) $response->getBody());
            } catch (RequestException $e) {
                $hasResponse = !empty($e->hasResponse());
                $body = (string) ($hasResponse ? $e->getResponse()->getBody() : '[NULL response]');
                $this->writeDebug($e->getResponse());
                $this->writeDebug($body);

                throw new ApiException(
                    "[{$e->getCode()}] {$body}",
                    (int) $e->getCode(),
                    $hasResponse ? $e->getResponse()->getHeaders() : null,
                    $body
                );
            } catch (ConnectException $e) {
                $this->writeDebug($e->getMessage());

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }
            switch ($statusCode) {
                case 200:
                    if ('string' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        $contentType = $response->getHeader('Content-Type')[0] ?? '';
                        if ('string' !== 'string') {
                            $content = $contentType === 'application/xml' ? simplexml_load_string($content) : json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, 'string', $response->getHeaders());
            }

            $returnType = 'string';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                $contentType = $response->getHeader('Content-Type')[0] ?? '';
                if ($returnType !== 'string') {
                    $content = $contentType === 'application/xml' ? simplexml_load_string($content) : json_decode($content);
                }
            }

            return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }

            $this->writeDebug($e);
            throw $e;
        }
    }

    /**
     * Operation getInventoryHealthReportAsync
     *
     * Get WFS Inventory Health Report
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getInventoryHealthReportAsync(
    ): PromiseInterface {
        return $this->getInventoryHealthReportAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getInventoryHealthReportAsyncWithHttpInfo
     *
     * Get WFS Inventory Health Report
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    protected function getInventoryHealthReportAsyncWithHttpInfo(): PromiseInterface
    {
        $returnType = 'string';
        $request = $this->getInventoryHealthReportRequest();
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $this->writeDebug($response);
                    $this->writeDebug((string) $response->getBody());
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $hasResponse = !empty($response);
                    $body = (string) ($hasResponse ? $response->getBody() : '[NULL response]');
                    $this->writeDebug($response);
                    $statusCode = $hasResponse ? $response->getStatusCode() : $exception->getCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $body,
                    );
                }
            );
    }

    /**
     * Create request for operation 'getInventoryHealthReport'
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getInventoryHealthReportRequest(): Request
    {
        $contentType = self::contentTypes['getInventoryHealthReport'];

        $resourcePath = '/v3/report/wfs/getInventoryHealthReport';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $method = 'GET';

        $headers = $this->headerSelector->selectHeaders(
            ['application/octet-stream'],
            $contentType,
            $multipart
        );

        $defaultHeaders = parent::getDefaultHeaders();
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        $query = ObjectSerializer::buildQuery($queryParams);
        $requestInfo = [
            'path' => $resourcePath,
            'method' => $method,
            'timestamp' => $defaultHeaders['WM_SEC.TIMESTAMP'],
            'query' => $query,
        ];

        // this endpoint requires Bearer authentication (access token)
        $token = $this->config->getAccessToken();
        if ($token) {
            $headers['WM_SEC.ACCESS_TOKEN'] = $token->accessToken;
        }

        $operationHost = $this->config->getHost();
        return new Request(
            $method,
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getWFSInventoryLog
     *
     * Get Inventory Log for a WFS item
     *
     * @param  string $gtin GTIN. (required)
     * @param  string $shipmentId Shipment Id. (optional)
     * @param  string $transactionType Transaction Type. (optional)
     * @param  string $transactionLocation Transaction Location. (optional)
     * @param  string $startDate Inventory log transaction time starting range (Date in YYYY-MM-DD format). (optional)
     * @param  string $endDate Inventory log transaction time ending range (Date in YYYY-MM-DD format). (optional)
     * @param  string $sortBy Sort By Attribute (Supported Attributes: gtin, changedUnits, transactionReasonCode, transactionType, shipmentId). (optional)
     * @param  string $sortOrder Sort Order (ASC or DESC). (optional)
     * @param  string $offset Offset is the number of records you wish to skip before selecting records. (optional, default to '0')
     * @param  string $limit limit is the number of records to be returned. (optional, default to '50')
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Walmart\Models\MP\US\Fulfillment\InventoryLogResponseWrapper
     */
    public function getWFSInventoryLog(
        string $gtin,
        ?string $shipmentId = null,
        ?string $transactionType = null,
        ?string $transactionLocation = null,
        ?string $startDate = null,
        ?string $endDate = null,
        ?string $sortBy = null,
        ?string $sortOrder = null,
        ?string $offset = '0',
        ?string $limit = '50'
    ): \Walmart\Models\MP\US\Fulfillment\InventoryLogResponseWrapper {
        return $this->getWFSInventoryLogWithHttpInfo($gtin, $shipmentId, $transactionType, $transactionLocation, $startDate, $endDate, $sortBy, $sortOrder, $offset, $limit);
    }

    /**
     * Operation getWFSInventoryLogWithHttpInfo
     *
     * Get Inventory Log for a WFS item
     *
     * @param  string $gtin GTIN. (required)
     * @param  string $shipmentId Shipment Id. (optional)
     * @param  string $transactionType Transaction Type. (optional)
     * @param  string $transactionLocation Transaction Location. (optional)
     * @param  string $startDate Inventory log transaction time starting range (Date in YYYY-MM-DD format). (optional)
     * @param  string $endDate Inventory log transaction time ending range (Date in YYYY-MM-DD format). (optional)
     * @param  string $sortBy Sort By Attribute (Supported Attributes: gtin, changedUnits, transactionReasonCode, transactionType, shipmentId). (optional)
     * @param  string $sortOrder Sort Order (ASC or DESC). (optional)
     * @param  string $offset Offset is the number of records you wish to skip before selecting records. (optional, default to '0')
     * @param  string $limit limit is the number of records to be returned. (optional, default to '50')
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Walmart\Models\MP\US\Fulfillment\InventoryLogResponseWrapper
     */
    protected function getWFSInventoryLogWithHttpInfo(
        string $gtin,
        ?string $shipmentId = null,
        ?string $transactionType = null,
        ?string $transactionLocation = null,
        ?string $startDate = null,
        ?string $endDate = null,
        ?string $sortBy = null,
        ?string $sortOrder = null,
        ?string $offset = '0',
        ?string $limit = '50',
    ): \Walmart\Models\MP\US\Fulfillment\InventoryLogResponseWrapper {
        $request = $this->getWFSInventoryLogRequest($gtin, $shipmentId, $transactionType, $transactionLocation, $startDate, $endDate, $sortBy, $sortOrder, $offset, $limit);
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
                $this->writeDebug($response);
                $this->writeDebug((string) $response->getBody());
            } catch (RequestException $e) {
                $hasResponse = !empty($e->hasResponse());
                $body = (string) ($hasResponse ? $e->getResponse()->getBody() : '[NULL response]');
                $this->writeDebug($e->getResponse());
                $this->writeDebug($body);

                throw new ApiException(
                    "[{$e->getCode()}] {$body}",
                    (int) $e->getCode(),
                    $hasResponse ? $e->getResponse()->getHeaders() : null,
                    $body
                );
            } catch (ConnectException $e) {
                $this->writeDebug($e->getMessage());

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }
            switch ($statusCode) {
                case 200:
                    if ('\Walmart\Models\MP\US\Fulfillment\InventoryLogResponseWrapper' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        $contentType = $response->getHeader('Content-Type')[0] ?? '';
                        if ('\Walmart\Models\MP\US\Fulfillment\InventoryLogResponseWrapper' !== 'string') {
                            $content = $contentType === 'application/xml' ? simplexml_load_string($content) : json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, '\Walmart\Models\MP\US\Fulfillment\InventoryLogResponseWrapper', $response->getHeaders());
            }

            $returnType = '\Walmart\Models\MP\US\Fulfillment\InventoryLogResponseWrapper';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                $contentType = $response->getHeader('Content-Type')[0] ?? '';
                if ($returnType !== 'string') {
                    $content = $contentType === 'application/xml' ? simplexml_load_string($content) : json_decode($content);
                }
            }

            return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Walmart\Models\MP\US\Fulfillment\InventoryLogResponseWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }

            $this->writeDebug($e);
            throw $e;
        }
    }

    /**
     * Operation getWFSInventoryLogAsync
     *
     * Get Inventory Log for a WFS item
     *
     * @param  string $gtin GTIN. (required)
     * @param  string $shipmentId Shipment Id. (optional)
     * @param  string $transactionType Transaction Type. (optional)
     * @param  string $transactionLocation Transaction Location. (optional)
     * @param  string $startDate Inventory log transaction time starting range (Date in YYYY-MM-DD format). (optional)
     * @param  string $endDate Inventory log transaction time ending range (Date in YYYY-MM-DD format). (optional)
     * @param  string $sortBy Sort By Attribute (Supported Attributes: gtin, changedUnits, transactionReasonCode, transactionType, shipmentId). (optional)
     * @param  string $sortOrder Sort Order (ASC or DESC). (optional)
     * @param  string $offset Offset is the number of records you wish to skip before selecting records. (optional, default to '0')
     * @param  string $limit limit is the number of records to be returned. (optional, default to '50')
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getWFSInventoryLogAsync(
        string $gtin,
        ?string $shipmentId = null,
        ?string $transactionType = null,
        ?string $transactionLocation = null,
        ?string $startDate = null,
        ?string $endDate = null,
        ?string $sortBy = null,
        ?string $sortOrder = null,
        ?string $offset = '0',
        ?string $limit = '50'
    ): PromiseInterface {
        return $this->getWFSInventoryLogAsyncWithHttpInfo($gtin, $shipmentId, $transactionType, $transactionLocation, $startDate, $endDate, $sortBy, $sortOrder, $offset, $limit)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getWFSInventoryLogAsyncWithHttpInfo
     *
     * Get Inventory Log for a WFS item
     *
     * @param  string $gtin GTIN. (required)
     * @param  string $shipmentId Shipment Id. (optional)
     * @param  string $transactionType Transaction Type. (optional)
     * @param  string $transactionLocation Transaction Location. (optional)
     * @param  string $startDate Inventory log transaction time starting range (Date in YYYY-MM-DD format). (optional)
     * @param  string $endDate Inventory log transaction time ending range (Date in YYYY-MM-DD format). (optional)
     * @param  string $sortBy Sort By Attribute (Supported Attributes: gtin, changedUnits, transactionReasonCode, transactionType, shipmentId). (optional)
     * @param  string $sortOrder Sort Order (ASC or DESC). (optional)
     * @param  string $offset Offset is the number of records you wish to skip before selecting records. (optional, default to '0')
     * @param  string $limit limit is the number of records to be returned. (optional, default to '50')
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    protected function getWFSInventoryLogAsyncWithHttpInfo(
        string $gtin,
        ?string $shipmentId = null,
        ?string $transactionType = null,
        ?string $transactionLocation = null,
        ?string $startDate = null,
        ?string $endDate = null,
        ?string $sortBy = null,
        ?string $sortOrder = null,
        ?string $offset = '0',
        ?string $limit = '50',
    ): PromiseInterface {
        $returnType = '\Walmart\Models\MP\US\Fulfillment\InventoryLogResponseWrapper';
        $request = $this->getWFSInventoryLogRequest($gtin, $shipmentId, $transactionType, $transactionLocation, $startDate, $endDate, $sortBy, $sortOrder, $offset, $limit);
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $this->writeDebug($response);
                    $this->writeDebug((string) $response->getBody());
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $hasResponse = !empty($response);
                    $body = (string) ($hasResponse ? $response->getBody() : '[NULL response]');
                    $this->writeDebug($response);
                    $statusCode = $hasResponse ? $response->getStatusCode() : $exception->getCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $body,
                    );
                }
            );
    }

    /**
     * Create request for operation 'getWFSInventoryLog'
     *
     * @param  string $gtin GTIN. (required)
     * @param  string $shipmentId Shipment Id. (optional)
     * @param  string $transactionType Transaction Type. (optional)
     * @param  string $transactionLocation Transaction Location. (optional)
     * @param  string $startDate Inventory log transaction time starting range (Date in YYYY-MM-DD format). (optional)
     * @param  string $endDate Inventory log transaction time ending range (Date in YYYY-MM-DD format). (optional)
     * @param  string $sortBy Sort By Attribute (Supported Attributes: gtin, changedUnits, transactionReasonCode, transactionType, shipmentId). (optional)
     * @param  string $sortOrder Sort Order (ASC or DESC). (optional)
     * @param  string $offset Offset is the number of records you wish to skip before selecting records. (optional, default to '0')
     * @param  string $limit limit is the number of records to be returned. (optional, default to '50')
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getWFSInventoryLogRequest(
        string $gtin,
        ?string $shipmentId = null,
        ?string $transactionType = null,
        ?string $transactionLocation = null,
        ?string $startDate = null,
        ?string $endDate = null,
        ?string $sortBy = null,
        ?string $sortOrder = null,
        ?string $offset = '0',
        ?string $limit = '50',
    ): Request {
        $contentType = self::contentTypes['getWFSInventoryLog'];

        // verify the required parameter 'gtin' is set
        if ($gtin === null || (is_array($gtin) && count($gtin) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $gtin when calling getWFSInventoryLog'
            );
        }
        $resourcePath = '/v3/fulfillment/inventory-log';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $method = 'GET';

        // query params
        $queryParams = array_merge(
            ObjectSerializer::toQueryValue(
                $gtin,
                'gtin', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                true // required
            ) ?? [],
            ObjectSerializer::toQueryValue(
                $shipmentId,
                'shipmentId', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? [],
            ObjectSerializer::toQueryValue(
                $transactionType,
                'transactionType', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? [],
            ObjectSerializer::toQueryValue(
                $transactionLocation,
                'transactionLocation', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? [],
            ObjectSerializer::toQueryValue(
                $startDate,
                'startDate', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? [],
            ObjectSerializer::toQueryValue(
                $endDate,
                'endDate', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? [],
            ObjectSerializer::toQueryValue(
                $sortBy,
                'sort_by', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? [],
            ObjectSerializer::toQueryValue(
                $sortOrder,
                'sort_order', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? [],
            ObjectSerializer::toQueryValue(
                $offset,
                'offset', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? [],
            ObjectSerializer::toQueryValue(
                $limit,
                'limit', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? [],
        );

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = parent::getDefaultHeaders();
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        $query = ObjectSerializer::buildQuery($queryParams);
        $requestInfo = [
            'path' => $resourcePath,
            'method' => $method,
            'timestamp' => $defaultHeaders['WM_SEC.TIMESTAMP'],
            'query' => $query,
        ];

        // this endpoint requires Bearer authentication (access token)
        $token = $this->config->getAccessToken();
        if ($token) {
            $headers['WM_SEC.ACCESS_TOKEN'] = $token->accessToken;
        }

        $operationHost = $this->config->getHost();
        return new Request(
            $method,
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation inboundPreview
     *
     * Fetch Inbound Preview
     *
     * @param  \Walmart\Models\MP\US\Fulfillment\InboundPreviewWrapper $inboundPreviewWrapper Request fields (required)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Walmart\Models\MP\US\Fulfillment\InboundPreviewResponseWrapper
     */
    public function inboundPreview(
        \Walmart\Models\MP\US\Fulfillment\InboundPreviewWrapper $inboundPreviewWrapper
    ): \Walmart\Models\MP\US\Fulfillment\InboundPreviewResponseWrapper {
        return $this->inboundPreviewWithHttpInfo($inboundPreviewWrapper);
    }

    /**
     * Operation inboundPreviewWithHttpInfo
     *
     * Fetch Inbound Preview
     *
     * @param  \Walmart\Models\MP\US\Fulfillment\InboundPreviewWrapper $inboundPreviewWrapper Request fields (required)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Walmart\Models\MP\US\Fulfillment\InboundPreviewResponseWrapper
     */
    protected function inboundPreviewWithHttpInfo(
        \Walmart\Models\MP\US\Fulfillment\InboundPreviewWrapper $inboundPreviewWrapper,
    ): \Walmart\Models\MP\US\Fulfillment\InboundPreviewResponseWrapper {
        $request = $this->inboundPreviewRequest($inboundPreviewWrapper);
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
                $this->writeDebug($response);
                $this->writeDebug((string) $response->getBody());
            } catch (RequestException $e) {
                $hasResponse = !empty($e->hasResponse());
                $body = (string) ($hasResponse ? $e->getResponse()->getBody() : '[NULL response]');
                $this->writeDebug($e->getResponse());
                $this->writeDebug($body);

                throw new ApiException(
                    "[{$e->getCode()}] {$body}",
                    (int) $e->getCode(),
                    $hasResponse ? $e->getResponse()->getHeaders() : null,
                    $body
                );
            } catch (ConnectException $e) {
                $this->writeDebug($e->getMessage());

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }
            switch ($statusCode) {
                case 200:
                    if ('\Walmart\Models\MP\US\Fulfillment\InboundPreviewResponseWrapper' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        $contentType = $response->getHeader('Content-Type')[0] ?? '';
                        if ('\Walmart\Models\MP\US\Fulfillment\InboundPreviewResponseWrapper' !== 'string') {
                            $content = $contentType === 'application/xml' ? simplexml_load_string($content) : json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, '\Walmart\Models\MP\US\Fulfillment\InboundPreviewResponseWrapper', $response->getHeaders());
            }

            $returnType = '\Walmart\Models\MP\US\Fulfillment\InboundPreviewResponseWrapper';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                $contentType = $response->getHeader('Content-Type')[0] ?? '';
                if ($returnType !== 'string') {
                    $content = $contentType === 'application/xml' ? simplexml_load_string($content) : json_decode($content);
                }
            }

            return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Walmart\Models\MP\US\Fulfillment\InboundPreviewResponseWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }

            $this->writeDebug($e);
            throw $e;
        }
    }

    /**
     * Operation inboundPreviewAsync
     *
     * Fetch Inbound Preview
     *
     * @param  \Walmart\Models\MP\US\Fulfillment\InboundPreviewWrapper $inboundPreviewWrapper Request fields (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function inboundPreviewAsync(
        \Walmart\Models\MP\US\Fulfillment\InboundPreviewWrapper $inboundPreviewWrapper
    ): PromiseInterface {
        return $this->inboundPreviewAsyncWithHttpInfo($inboundPreviewWrapper)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation inboundPreviewAsyncWithHttpInfo
     *
     * Fetch Inbound Preview
     *
     * @param  \Walmart\Models\MP\US\Fulfillment\InboundPreviewWrapper $inboundPreviewWrapper Request fields (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    protected function inboundPreviewAsyncWithHttpInfo(
        \Walmart\Models\MP\US\Fulfillment\InboundPreviewWrapper $inboundPreviewWrapper,
    ): PromiseInterface {
        $returnType = '\Walmart\Models\MP\US\Fulfillment\InboundPreviewResponseWrapper';
        $request = $this->inboundPreviewRequest($inboundPreviewWrapper);
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $this->writeDebug($response);
                    $this->writeDebug((string) $response->getBody());
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $hasResponse = !empty($response);
                    $body = (string) ($hasResponse ? $response->getBody() : '[NULL response]');
                    $this->writeDebug($response);
                    $statusCode = $hasResponse ? $response->getStatusCode() : $exception->getCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $body,
                    );
                }
            );
    }

    /**
     * Create request for operation 'inboundPreview'
     *
     * @param  \Walmart\Models\MP\US\Fulfillment\InboundPreviewWrapper $inboundPreviewWrapper Request fields (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function inboundPreviewRequest(
        \Walmart\Models\MP\US\Fulfillment\InboundPreviewWrapper $inboundPreviewWrapper,
    ): Request {
        $contentType = self::contentTypes['inboundPreview'];

        // verify the required parameter 'inboundPreviewWrapper' is set
        if ($inboundPreviewWrapper === null || (is_array($inboundPreviewWrapper) && count($inboundPreviewWrapper) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inboundPreviewWrapper when calling inboundPreview'
            );
        }
        $resourcePath = '/v3/fulfillment/inbound-preview';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $method = 'POST';

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = parent::getDefaultHeaders();
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        // for model (json/xml)
        if (isset($inboundPreviewWrapper)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($inboundPreviewWrapper));
            } else {
                $httpBody = $inboundPreviewWrapper;
            }
        } else if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        $query = ObjectSerializer::buildQuery($queryParams);
        $requestInfo = [
            'path' => $resourcePath,
            'method' => $method,
            'timestamp' => $defaultHeaders['WM_SEC.TIMESTAMP'],
            'query' => $query,
        ];

        // this endpoint requires Bearer authentication (access token)
        $token = $this->config->getAccessToken();
        if ($token) {
            $headers['WM_SEC.ACCESS_TOKEN'] = $token->accessToken;
        }

        $operationHost = $this->config->getHost();
        return new Request(
            $method,
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation printCarrierLabel
     *
     * Print Carrier Label
     *
     * @param  string $shipmentId Unique ID identifying each shipment. (required)
     * @param  \Walmart\Models\MP\US\Fulfillment\CarrierLabelRequestWrapper $carrierLabelRequestWrapper (required)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Walmart\Models\MP\US\Fulfillment\ServiceResponse
     */
    public function printCarrierLabel(
        string $shipmentId,
        \Walmart\Models\MP\US\Fulfillment\CarrierLabelRequestWrapper $carrierLabelRequestWrapper
    ): \Walmart\Models\MP\US\Fulfillment\ServiceResponse {
        return $this->printCarrierLabelWithHttpInfo($shipmentId, $carrierLabelRequestWrapper);
    }

    /**
     * Operation printCarrierLabelWithHttpInfo
     *
     * Print Carrier Label
     *
     * @param  string $shipmentId Unique ID identifying each shipment. (required)
     * @param  \Walmart\Models\MP\US\Fulfillment\CarrierLabelRequestWrapper $carrierLabelRequestWrapper (required)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Walmart\Models\MP\US\Fulfillment\ServiceResponse
     */
    protected function printCarrierLabelWithHttpInfo(
        string $shipmentId,
        \Walmart\Models\MP\US\Fulfillment\CarrierLabelRequestWrapper $carrierLabelRequestWrapper,
    ): \Walmart\Models\MP\US\Fulfillment\ServiceResponse {
        $request = $this->printCarrierLabelRequest($shipmentId, $carrierLabelRequestWrapper);
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
                $this->writeDebug($response);
                $this->writeDebug((string) $response->getBody());
            } catch (RequestException $e) {
                $hasResponse = !empty($e->hasResponse());
                $body = (string) ($hasResponse ? $e->getResponse()->getBody() : '[NULL response]');
                $this->writeDebug($e->getResponse());
                $this->writeDebug($body);

                throw new ApiException(
                    "[{$e->getCode()}] {$body}",
                    (int) $e->getCode(),
                    $hasResponse ? $e->getResponse()->getHeaders() : null,
                    $body
                );
            } catch (ConnectException $e) {
                $this->writeDebug($e->getMessage());

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }
            switch ($statusCode) {
                case 200:
                    if ('\Walmart\Models\MP\US\Fulfillment\ServiceResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        $contentType = $response->getHeader('Content-Type')[0] ?? '';
                        if ('\Walmart\Models\MP\US\Fulfillment\ServiceResponse' !== 'string') {
                            $content = $contentType === 'application/xml' ? simplexml_load_string($content) : json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, '\Walmart\Models\MP\US\Fulfillment\ServiceResponse', $response->getHeaders());
            }

            $returnType = '\Walmart\Models\MP\US\Fulfillment\ServiceResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                $contentType = $response->getHeader('Content-Type')[0] ?? '';
                if ($returnType !== 'string') {
                    $content = $contentType === 'application/xml' ? simplexml_load_string($content) : json_decode($content);
                }
            }

            return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Walmart\Models\MP\US\Fulfillment\ServiceResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }

            $this->writeDebug($e);
            throw $e;
        }
    }

    /**
     * Operation printCarrierLabelAsync
     *
     * Print Carrier Label
     *
     * @param  string $shipmentId Unique ID identifying each shipment. (required)
     * @param  \Walmart\Models\MP\US\Fulfillment\CarrierLabelRequestWrapper $carrierLabelRequestWrapper (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function printCarrierLabelAsync(
        string $shipmentId,
        \Walmart\Models\MP\US\Fulfillment\CarrierLabelRequestWrapper $carrierLabelRequestWrapper
    ): PromiseInterface {
        return $this->printCarrierLabelAsyncWithHttpInfo($shipmentId, $carrierLabelRequestWrapper)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation printCarrierLabelAsyncWithHttpInfo
     *
     * Print Carrier Label
     *
     * @param  string $shipmentId Unique ID identifying each shipment. (required)
     * @param  \Walmart\Models\MP\US\Fulfillment\CarrierLabelRequestWrapper $carrierLabelRequestWrapper (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    protected function printCarrierLabelAsyncWithHttpInfo(
        string $shipmentId,
        \Walmart\Models\MP\US\Fulfillment\CarrierLabelRequestWrapper $carrierLabelRequestWrapper,
    ): PromiseInterface {
        $returnType = '\Walmart\Models\MP\US\Fulfillment\ServiceResponse';
        $request = $this->printCarrierLabelRequest($shipmentId, $carrierLabelRequestWrapper);
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $this->writeDebug($response);
                    $this->writeDebug((string) $response->getBody());
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $hasResponse = !empty($response);
                    $body = (string) ($hasResponse ? $response->getBody() : '[NULL response]');
                    $this->writeDebug($response);
                    $statusCode = $hasResponse ? $response->getStatusCode() : $exception->getCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $body,
                    );
                }
            );
    }

    /**
     * Create request for operation 'printCarrierLabel'
     *
     * @param  string $shipmentId Unique ID identifying each shipment. (required)
     * @param  \Walmart\Models\MP\US\Fulfillment\CarrierLabelRequestWrapper $carrierLabelRequestWrapper (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function printCarrierLabelRequest(
        string $shipmentId,
        \Walmart\Models\MP\US\Fulfillment\CarrierLabelRequestWrapper $carrierLabelRequestWrapper,
    ): Request {
        $contentType = self::contentTypes['printCarrierLabel'];

        // verify the required parameter 'shipmentId' is set
        if ($shipmentId === null || (is_array($shipmentId) && count($shipmentId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $shipmentId when calling printCarrierLabel'
            );
        }
        // verify the required parameter 'carrierLabelRequestWrapper' is set
        if ($carrierLabelRequestWrapper === null || (is_array($carrierLabelRequestWrapper) && count($carrierLabelRequestWrapper) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $carrierLabelRequestWrapper when calling printCarrierLabel'
            );
        }
        $resourcePath = '/v3/fulfillment/carrier-label/{shipmentId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $method = 'POST';

        // path params
        if ($shipmentId !== null) {
            $resourcePath = str_replace(
                '{' . 'shipmentId' . '}',
                ObjectSerializer::toPathValue($shipmentId),
                $resourcePath
            );
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/pdf'],
            $contentType,
            $multipart
        );

        $defaultHeaders = parent::getDefaultHeaders();
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        // for model (json/xml)
        if (isset($carrierLabelRequestWrapper)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($carrierLabelRequestWrapper));
            } else {
                $httpBody = $carrierLabelRequestWrapper;
            }
        } else if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        $query = ObjectSerializer::buildQuery($queryParams);
        $requestInfo = [
            'path' => $resourcePath,
            'method' => $method,
            'timestamp' => $defaultHeaders['WM_SEC.TIMESTAMP'],
            'query' => $query,
        ];

        // this endpoint requires Bearer authentication (access token)
        $token = $this->config->getAccessToken();
        if ($token) {
            $headers['WM_SEC.ACCESS_TOKEN'] = $token->accessToken;
        }

        $operationHost = $this->config->getHost();
        return new Request(
            $method,
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation promiseFulfillments
     *
     * Fetch Delivery Promise Details
     *
     * @param  \Walmart\Models\MP\US\Fulfillment\CreateCustomerOrderRequestWrapper $createCustomerOrderRequestWrapper Request fields (required)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Walmart\Models\MP\US\Fulfillment\PromiseOrderResponseWrapper
     */
    public function promiseFulfillments(
        \Walmart\Models\MP\US\Fulfillment\CreateCustomerOrderRequestWrapper $createCustomerOrderRequestWrapper
    ): \Walmart\Models\MP\US\Fulfillment\PromiseOrderResponseWrapper {
        return $this->promiseFulfillmentsWithHttpInfo($createCustomerOrderRequestWrapper);
    }

    /**
     * Operation promiseFulfillmentsWithHttpInfo
     *
     * Fetch Delivery Promise Details
     *
     * @param  \Walmart\Models\MP\US\Fulfillment\CreateCustomerOrderRequestWrapper $createCustomerOrderRequestWrapper Request fields (required)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Walmart\Models\MP\US\Fulfillment\PromiseOrderResponseWrapper
     */
    protected function promiseFulfillmentsWithHttpInfo(
        \Walmart\Models\MP\US\Fulfillment\CreateCustomerOrderRequestWrapper $createCustomerOrderRequestWrapper,
    ): \Walmart\Models\MP\US\Fulfillment\PromiseOrderResponseWrapper {
        $request = $this->promiseFulfillmentsRequest($createCustomerOrderRequestWrapper);
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
                $this->writeDebug($response);
                $this->writeDebug((string) $response->getBody());
            } catch (RequestException $e) {
                $hasResponse = !empty($e->hasResponse());
                $body = (string) ($hasResponse ? $e->getResponse()->getBody() : '[NULL response]');
                $this->writeDebug($e->getResponse());
                $this->writeDebug($body);

                throw new ApiException(
                    "[{$e->getCode()}] {$body}",
                    (int) $e->getCode(),
                    $hasResponse ? $e->getResponse()->getHeaders() : null,
                    $body
                );
            } catch (ConnectException $e) {
                $this->writeDebug($e->getMessage());

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }
            switch ($statusCode) {
                case 200:
                    if ('\Walmart\Models\MP\US\Fulfillment\PromiseOrderResponseWrapper' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        $contentType = $response->getHeader('Content-Type')[0] ?? '';
                        if ('\Walmart\Models\MP\US\Fulfillment\PromiseOrderResponseWrapper' !== 'string') {
                            $content = $contentType === 'application/xml' ? simplexml_load_string($content) : json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, '\Walmart\Models\MP\US\Fulfillment\PromiseOrderResponseWrapper', $response->getHeaders());
            }

            $returnType = '\Walmart\Models\MP\US\Fulfillment\PromiseOrderResponseWrapper';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                $contentType = $response->getHeader('Content-Type')[0] ?? '';
                if ($returnType !== 'string') {
                    $content = $contentType === 'application/xml' ? simplexml_load_string($content) : json_decode($content);
                }
            }

            return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Walmart\Models\MP\US\Fulfillment\PromiseOrderResponseWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }

            $this->writeDebug($e);
            throw $e;
        }
    }

    /**
     * Operation promiseFulfillmentsAsync
     *
     * Fetch Delivery Promise Details
     *
     * @param  \Walmart\Models\MP\US\Fulfillment\CreateCustomerOrderRequestWrapper $createCustomerOrderRequestWrapper Request fields (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function promiseFulfillmentsAsync(
        \Walmart\Models\MP\US\Fulfillment\CreateCustomerOrderRequestWrapper $createCustomerOrderRequestWrapper
    ): PromiseInterface {
        return $this->promiseFulfillmentsAsyncWithHttpInfo($createCustomerOrderRequestWrapper)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation promiseFulfillmentsAsyncWithHttpInfo
     *
     * Fetch Delivery Promise Details
     *
     * @param  \Walmart\Models\MP\US\Fulfillment\CreateCustomerOrderRequestWrapper $createCustomerOrderRequestWrapper Request fields (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    protected function promiseFulfillmentsAsyncWithHttpInfo(
        \Walmart\Models\MP\US\Fulfillment\CreateCustomerOrderRequestWrapper $createCustomerOrderRequestWrapper,
    ): PromiseInterface {
        $returnType = '\Walmart\Models\MP\US\Fulfillment\PromiseOrderResponseWrapper';
        $request = $this->promiseFulfillmentsRequest($createCustomerOrderRequestWrapper);
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $this->writeDebug($response);
                    $this->writeDebug((string) $response->getBody());
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $hasResponse = !empty($response);
                    $body = (string) ($hasResponse ? $response->getBody() : '[NULL response]');
                    $this->writeDebug($response);
                    $statusCode = $hasResponse ? $response->getStatusCode() : $exception->getCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $body,
                    );
                }
            );
    }

    /**
     * Create request for operation 'promiseFulfillments'
     *
     * @param  \Walmart\Models\MP\US\Fulfillment\CreateCustomerOrderRequestWrapper $createCustomerOrderRequestWrapper Request fields (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function promiseFulfillmentsRequest(
        \Walmart\Models\MP\US\Fulfillment\CreateCustomerOrderRequestWrapper $createCustomerOrderRequestWrapper,
    ): Request {
        $contentType = self::contentTypes['promiseFulfillments'];

        // verify the required parameter 'createCustomerOrderRequestWrapper' is set
        if ($createCustomerOrderRequestWrapper === null || (is_array($createCustomerOrderRequestWrapper) && count($createCustomerOrderRequestWrapper) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $createCustomerOrderRequestWrapper when calling promiseFulfillments'
            );
        }
        $resourcePath = '/v3/fulfillment/orders-fulfillments/fetchOrderPromiseOptions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $method = 'POST';

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = parent::getDefaultHeaders();
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        // for model (json/xml)
        if (isset($createCustomerOrderRequestWrapper)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($createCustomerOrderRequestWrapper));
            } else {
                $httpBody = $createCustomerOrderRequestWrapper;
            }
        } else if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        $query = ObjectSerializer::buildQuery($queryParams);
        $requestInfo = [
            'path' => $resourcePath,
            'method' => $method,
            'timestamp' => $defaultHeaders['WM_SEC.TIMESTAMP'],
            'query' => $query,
        ];

        // this endpoint requires Bearer authentication (access token)
        $token = $this->config->getAccessToken();
        if ($token) {
            $headers['WM_SEC.ACCESS_TOKEN'] = $token->accessToken;
        }

        $operationHost = $this->config->getHost();
        return new Request(
            $method,
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateShipmentQuantity
     *
     * Update Shipment Quantities
     *
     * @param  \Walmart\Models\MP\US\Fulfillment\InboundShipmentUpdateQtyWrapper $inboundShipmentUpdateQtyWrapper Request fields (required)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Walmart\Models\MP\US\Fulfillment\ServiceResponse
     */
    public function updateShipmentQuantity(
        \Walmart\Models\MP\US\Fulfillment\InboundShipmentUpdateQtyWrapper $inboundShipmentUpdateQtyWrapper
    ): \Walmart\Models\MP\US\Fulfillment\ServiceResponse {
        return $this->updateShipmentQuantityWithHttpInfo($inboundShipmentUpdateQtyWrapper);
    }

    /**
     * Operation updateShipmentQuantityWithHttpInfo
     *
     * Update Shipment Quantities
     *
     * @param  \Walmart\Models\MP\US\Fulfillment\InboundShipmentUpdateQtyWrapper $inboundShipmentUpdateQtyWrapper Request fields (required)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Walmart\Models\MP\US\Fulfillment\ServiceResponse
     */
    protected function updateShipmentQuantityWithHttpInfo(
        \Walmart\Models\MP\US\Fulfillment\InboundShipmentUpdateQtyWrapper $inboundShipmentUpdateQtyWrapper,
    ): \Walmart\Models\MP\US\Fulfillment\ServiceResponse {
        $request = $this->updateShipmentQuantityRequest($inboundShipmentUpdateQtyWrapper);
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
                $this->writeDebug($response);
                $this->writeDebug((string) $response->getBody());
            } catch (RequestException $e) {
                $hasResponse = !empty($e->hasResponse());
                $body = (string) ($hasResponse ? $e->getResponse()->getBody() : '[NULL response]');
                $this->writeDebug($e->getResponse());
                $this->writeDebug($body);

                throw new ApiException(
                    "[{$e->getCode()}] {$body}",
                    (int) $e->getCode(),
                    $hasResponse ? $e->getResponse()->getHeaders() : null,
                    $body
                );
            } catch (ConnectException $e) {
                $this->writeDebug($e->getMessage());

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }
            switch ($statusCode) {
                case 200:
                    if ('\Walmart\Models\MP\US\Fulfillment\ServiceResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        $contentType = $response->getHeader('Content-Type')[0] ?? '';
                        if ('\Walmart\Models\MP\US\Fulfillment\ServiceResponse' !== 'string') {
                            $content = $contentType === 'application/xml' ? simplexml_load_string($content) : json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, '\Walmart\Models\MP\US\Fulfillment\ServiceResponse', $response->getHeaders());
            }

            $returnType = '\Walmart\Models\MP\US\Fulfillment\ServiceResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                $contentType = $response->getHeader('Content-Type')[0] ?? '';
                if ($returnType !== 'string') {
                    $content = $contentType === 'application/xml' ? simplexml_load_string($content) : json_decode($content);
                }
            }

            return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Walmart\Models\MP\US\Fulfillment\ServiceResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }

            $this->writeDebug($e);
            throw $e;
        }
    }

    /**
     * Operation updateShipmentQuantityAsync
     *
     * Update Shipment Quantities
     *
     * @param  \Walmart\Models\MP\US\Fulfillment\InboundShipmentUpdateQtyWrapper $inboundShipmentUpdateQtyWrapper Request fields (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateShipmentQuantityAsync(
        \Walmart\Models\MP\US\Fulfillment\InboundShipmentUpdateQtyWrapper $inboundShipmentUpdateQtyWrapper
    ): PromiseInterface {
        return $this->updateShipmentQuantityAsyncWithHttpInfo($inboundShipmentUpdateQtyWrapper)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateShipmentQuantityAsyncWithHttpInfo
     *
     * Update Shipment Quantities
     *
     * @param  \Walmart\Models\MP\US\Fulfillment\InboundShipmentUpdateQtyWrapper $inboundShipmentUpdateQtyWrapper Request fields (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    protected function updateShipmentQuantityAsyncWithHttpInfo(
        \Walmart\Models\MP\US\Fulfillment\InboundShipmentUpdateQtyWrapper $inboundShipmentUpdateQtyWrapper,
    ): PromiseInterface {
        $returnType = '\Walmart\Models\MP\US\Fulfillment\ServiceResponse';
        $request = $this->updateShipmentQuantityRequest($inboundShipmentUpdateQtyWrapper);
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $this->writeDebug($response);
                    $this->writeDebug((string) $response->getBody());
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $hasResponse = !empty($response);
                    $body = (string) ($hasResponse ? $response->getBody() : '[NULL response]');
                    $this->writeDebug($response);
                    $statusCode = $hasResponse ? $response->getStatusCode() : $exception->getCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $body,
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateShipmentQuantity'
     *
     * @param  \Walmart\Models\MP\US\Fulfillment\InboundShipmentUpdateQtyWrapper $inboundShipmentUpdateQtyWrapper Request fields (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateShipmentQuantityRequest(
        \Walmart\Models\MP\US\Fulfillment\InboundShipmentUpdateQtyWrapper $inboundShipmentUpdateQtyWrapper,
    ): Request {
        $contentType = self::contentTypes['updateShipmentQuantity'];

        // verify the required parameter 'inboundShipmentUpdateQtyWrapper' is set
        if ($inboundShipmentUpdateQtyWrapper === null || (is_array($inboundShipmentUpdateQtyWrapper) && count($inboundShipmentUpdateQtyWrapper) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inboundShipmentUpdateQtyWrapper when calling updateShipmentQuantity'
            );
        }
        $resourcePath = '/v3/fulfillment/shipment-quantities';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $method = 'PUT';

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = parent::getDefaultHeaders();
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        // for model (json/xml)
        if (isset($inboundShipmentUpdateQtyWrapper)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($inboundShipmentUpdateQtyWrapper));
            } else {
                $httpBody = $inboundShipmentUpdateQtyWrapper;
            }
        } else if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        $query = ObjectSerializer::buildQuery($queryParams);
        $requestInfo = [
            'path' => $resourcePath,
            'method' => $method,
            'timestamp' => $defaultHeaders['WM_SEC.TIMESTAMP'],
            'query' => $query,
        ];

        // this endpoint requires Bearer authentication (access token)
        $token = $this->config->getAccessToken();
        if ($token) {
            $headers['WM_SEC.ACCESS_TOKEN'] = $token->accessToken;
        }

        $operationHost = $this->config->getHost();
        return new Request(
            $method,
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateShipmentTrackingDetails
     *
     * Update Shipment Tracking
     *
     * @param  \Walmart\Models\MP\US\Fulfillment\TrackingInfoWrapper $trackingInfoWrapper Request fields (required)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Walmart\Models\MP\US\Fulfillment\ServiceResponse
     */
    public function updateShipmentTrackingDetails(
        \Walmart\Models\MP\US\Fulfillment\TrackingInfoWrapper $trackingInfoWrapper
    ): \Walmart\Models\MP\US\Fulfillment\ServiceResponse {
        return $this->updateShipmentTrackingDetailsWithHttpInfo($trackingInfoWrapper);
    }

    /**
     * Operation updateShipmentTrackingDetailsWithHttpInfo
     *
     * Update Shipment Tracking
     *
     * @param  \Walmart\Models\MP\US\Fulfillment\TrackingInfoWrapper $trackingInfoWrapper Request fields (required)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Walmart\Models\MP\US\Fulfillment\ServiceResponse
     */
    protected function updateShipmentTrackingDetailsWithHttpInfo(
        \Walmart\Models\MP\US\Fulfillment\TrackingInfoWrapper $trackingInfoWrapper,
    ): \Walmart\Models\MP\US\Fulfillment\ServiceResponse {
        $request = $this->updateShipmentTrackingDetailsRequest($trackingInfoWrapper);
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
                $this->writeDebug($response);
                $this->writeDebug((string) $response->getBody());
            } catch (RequestException $e) {
                $hasResponse = !empty($e->hasResponse());
                $body = (string) ($hasResponse ? $e->getResponse()->getBody() : '[NULL response]');
                $this->writeDebug($e->getResponse());
                $this->writeDebug($body);

                throw new ApiException(
                    "[{$e->getCode()}] {$body}",
                    (int) $e->getCode(),
                    $hasResponse ? $e->getResponse()->getHeaders() : null,
                    $body
                );
            } catch (ConnectException $e) {
                $this->writeDebug($e->getMessage());

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }
            switch ($statusCode) {
                case 200:
                    if ('\Walmart\Models\MP\US\Fulfillment\ServiceResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        $contentType = $response->getHeader('Content-Type')[0] ?? '';
                        if ('\Walmart\Models\MP\US\Fulfillment\ServiceResponse' !== 'string') {
                            $content = $contentType === 'application/xml' ? simplexml_load_string($content) : json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, '\Walmart\Models\MP\US\Fulfillment\ServiceResponse', $response->getHeaders());
            }

            $returnType = '\Walmart\Models\MP\US\Fulfillment\ServiceResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                $contentType = $response->getHeader('Content-Type')[0] ?? '';
                if ($returnType !== 'string') {
                    $content = $contentType === 'application/xml' ? simplexml_load_string($content) : json_decode($content);
                }
            }

            return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Walmart\Models\MP\US\Fulfillment\ServiceResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }

            $this->writeDebug($e);
            throw $e;
        }
    }

    /**
     * Operation updateShipmentTrackingDetailsAsync
     *
     * Update Shipment Tracking
     *
     * @param  \Walmart\Models\MP\US\Fulfillment\TrackingInfoWrapper $trackingInfoWrapper Request fields (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateShipmentTrackingDetailsAsync(
        \Walmart\Models\MP\US\Fulfillment\TrackingInfoWrapper $trackingInfoWrapper
    ): PromiseInterface {
        return $this->updateShipmentTrackingDetailsAsyncWithHttpInfo($trackingInfoWrapper)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateShipmentTrackingDetailsAsyncWithHttpInfo
     *
     * Update Shipment Tracking
     *
     * @param  \Walmart\Models\MP\US\Fulfillment\TrackingInfoWrapper $trackingInfoWrapper Request fields (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    protected function updateShipmentTrackingDetailsAsyncWithHttpInfo(
        \Walmart\Models\MP\US\Fulfillment\TrackingInfoWrapper $trackingInfoWrapper,
    ): PromiseInterface {
        $returnType = '\Walmart\Models\MP\US\Fulfillment\ServiceResponse';
        $request = $this->updateShipmentTrackingDetailsRequest($trackingInfoWrapper);
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $this->writeDebug($response);
                    $this->writeDebug((string) $response->getBody());
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $hasResponse = !empty($response);
                    $body = (string) ($hasResponse ? $response->getBody() : '[NULL response]');
                    $this->writeDebug($response);
                    $statusCode = $hasResponse ? $response->getStatusCode() : $exception->getCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $body,
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateShipmentTrackingDetails'
     *
     * @param  \Walmart\Models\MP\US\Fulfillment\TrackingInfoWrapper $trackingInfoWrapper Request fields (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateShipmentTrackingDetailsRequest(
        \Walmart\Models\MP\US\Fulfillment\TrackingInfoWrapper $trackingInfoWrapper,
    ): Request {
        $contentType = self::contentTypes['updateShipmentTrackingDetails'];

        // verify the required parameter 'trackingInfoWrapper' is set
        if ($trackingInfoWrapper === null || (is_array($trackingInfoWrapper) && count($trackingInfoWrapper) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $trackingInfoWrapper when calling updateShipmentTrackingDetails'
            );
        }
        $resourcePath = '/v3/fulfillment/shipment-tracking';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $method = 'POST';

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = parent::getDefaultHeaders();
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        // for model (json/xml)
        if (isset($trackingInfoWrapper)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($trackingInfoWrapper));
            } else {
                $httpBody = $trackingInfoWrapper;
            }
        } else if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        $query = ObjectSerializer::buildQuery($queryParams);
        $requestInfo = [
            'path' => $resourcePath,
            'method' => $method,
            'timestamp' => $defaultHeaders['WM_SEC.TIMESTAMP'],
            'query' => $query,
        ];

        // this endpoint requires Bearer authentication (access token)
        $token = $this->config->getAccessToken();
        if ($token) {
            $headers['WM_SEC.ACCESS_TOKEN'] = $token->accessToken;
        }

        $operationHost = $this->config->getHost();
        return new Request(
            $method,
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation voidCarrierRateQuote
     *
     * Cancel Carrier Rate Quote
     *
     * @param  string $shipmentId Unique ID identifying each shipment. (required)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Walmart\Models\MP\US\Fulfillment\ServiceResponse
     */
    public function voidCarrierRateQuote(
        string $shipmentId
    ): \Walmart\Models\MP\US\Fulfillment\ServiceResponse {
        return $this->voidCarrierRateQuoteWithHttpInfo($shipmentId);
    }

    /**
     * Operation voidCarrierRateQuoteWithHttpInfo
     *
     * Cancel Carrier Rate Quote
     *
     * @param  string $shipmentId Unique ID identifying each shipment. (required)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Walmart\Models\MP\US\Fulfillment\ServiceResponse
     */
    protected function voidCarrierRateQuoteWithHttpInfo(
        string $shipmentId,
    ): \Walmart\Models\MP\US\Fulfillment\ServiceResponse {
        $request = $this->voidCarrierRateQuoteRequest($shipmentId);
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
                $this->writeDebug($response);
                $this->writeDebug((string) $response->getBody());
            } catch (RequestException $e) {
                $hasResponse = !empty($e->hasResponse());
                $body = (string) ($hasResponse ? $e->getResponse()->getBody() : '[NULL response]');
                $this->writeDebug($e->getResponse());
                $this->writeDebug($body);

                throw new ApiException(
                    "[{$e->getCode()}] {$body}",
                    (int) $e->getCode(),
                    $hasResponse ? $e->getResponse()->getHeaders() : null,
                    $body
                );
            } catch (ConnectException $e) {
                $this->writeDebug($e->getMessage());

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }
            switch ($statusCode) {
                case 200:
                    if ('\Walmart\Models\MP\US\Fulfillment\ServiceResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        $contentType = $response->getHeader('Content-Type')[0] ?? '';
                        if ('\Walmart\Models\MP\US\Fulfillment\ServiceResponse' !== 'string') {
                            $content = $contentType === 'application/xml' ? simplexml_load_string($content) : json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, '\Walmart\Models\MP\US\Fulfillment\ServiceResponse', $response->getHeaders());
            }

            $returnType = '\Walmart\Models\MP\US\Fulfillment\ServiceResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                $contentType = $response->getHeader('Content-Type')[0] ?? '';
                if ($returnType !== 'string') {
                    $content = $contentType === 'application/xml' ? simplexml_load_string($content) : json_decode($content);
                }
            }

            return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Walmart\Models\MP\US\Fulfillment\ServiceResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }

            $this->writeDebug($e);
            throw $e;
        }
    }

    /**
     * Operation voidCarrierRateQuoteAsync
     *
     * Cancel Carrier Rate Quote
     *
     * @param  string $shipmentId Unique ID identifying each shipment. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function voidCarrierRateQuoteAsync(
        string $shipmentId
    ): PromiseInterface {
        return $this->voidCarrierRateQuoteAsyncWithHttpInfo($shipmentId)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation voidCarrierRateQuoteAsyncWithHttpInfo
     *
     * Cancel Carrier Rate Quote
     *
     * @param  string $shipmentId Unique ID identifying each shipment. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    protected function voidCarrierRateQuoteAsyncWithHttpInfo(
        string $shipmentId,
    ): PromiseInterface {
        $returnType = '\Walmart\Models\MP\US\Fulfillment\ServiceResponse';
        $request = $this->voidCarrierRateQuoteRequest($shipmentId);
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $this->writeDebug($response);
                    $this->writeDebug((string) $response->getBody());
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $hasResponse = !empty($response);
                    $body = (string) ($hasResponse ? $response->getBody() : '[NULL response]');
                    $this->writeDebug($response);
                    $statusCode = $hasResponse ? $response->getStatusCode() : $exception->getCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $body,
                    );
                }
            );
    }

    /**
     * Create request for operation 'voidCarrierRateQuote'
     *
     * @param  string $shipmentId Unique ID identifying each shipment. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function voidCarrierRateQuoteRequest(
        string $shipmentId,
    ): Request {
        $contentType = self::contentTypes['voidCarrierRateQuote'];

        // verify the required parameter 'shipmentId' is set
        if ($shipmentId === null || (is_array($shipmentId) && count($shipmentId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $shipmentId when calling voidCarrierRateQuote'
            );
        }
        $resourcePath = '/v3/fulfillment/carrier-rate-quote/{shipmentId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $method = 'DELETE';

        // path params
        if ($shipmentId !== null) {
            $resourcePath = str_replace(
                '{' . 'shipmentId' . '}',
                ObjectSerializer::toPathValue($shipmentId),
                $resourcePath
            );
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = parent::getDefaultHeaders();
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        $query = ObjectSerializer::buildQuery($queryParams);
        $requestInfo = [
            'path' => $resourcePath,
            'method' => $method,
            'timestamp' => $defaultHeaders['WM_SEC.TIMESTAMP'],
            'query' => $query,
        ];

        // this endpoint requires Bearer authentication (access token)
        $token = $this->config->getAccessToken();
        if ($token) {
            $headers['WM_SEC.ACCESS_TOKEN'] = $token->accessToken;
        }

        $operationHost = $this->config->getHost();
        return new Request(
            $method,
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation wercsFeedback
     *
     * Hazmat Items On hold
     *
     * @param  \Walmart\Models\MP\US\Fulfillment\WercsFeedbackRequest $wercsFeedbackRequest Request fields (required)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Walmart\Models\MP\US\Fulfillment\ServiceResponse
     */
    public function wercsFeedback(
        \Walmart\Models\MP\US\Fulfillment\WercsFeedbackRequest $wercsFeedbackRequest
    ): \Walmart\Models\MP\US\Fulfillment\ServiceResponse {
        return $this->wercsFeedbackWithHttpInfo($wercsFeedbackRequest);
    }

    /**
     * Operation wercsFeedbackWithHttpInfo
     *
     * Hazmat Items On hold
     *
     * @param  \Walmart\Models\MP\US\Fulfillment\WercsFeedbackRequest $wercsFeedbackRequest Request fields (required)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Walmart\Models\MP\US\Fulfillment\ServiceResponse
     */
    protected function wercsFeedbackWithHttpInfo(
        \Walmart\Models\MP\US\Fulfillment\WercsFeedbackRequest $wercsFeedbackRequest,
    ): \Walmart\Models\MP\US\Fulfillment\ServiceResponse {
        $request = $this->wercsFeedbackRequest($wercsFeedbackRequest);
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
                $this->writeDebug($response);
                $this->writeDebug((string) $response->getBody());
            } catch (RequestException $e) {
                $hasResponse = !empty($e->hasResponse());
                $body = (string) ($hasResponse ? $e->getResponse()->getBody() : '[NULL response]');
                $this->writeDebug($e->getResponse());
                $this->writeDebug($body);

                throw new ApiException(
                    "[{$e->getCode()}] {$body}",
                    (int) $e->getCode(),
                    $hasResponse ? $e->getResponse()->getHeaders() : null,
                    $body
                );
            } catch (ConnectException $e) {
                $this->writeDebug($e->getMessage());

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }
            switch ($statusCode) {
                case 200:
                    if ('\Walmart\Models\MP\US\Fulfillment\ServiceResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        $contentType = $response->getHeader('Content-Type')[0] ?? '';
                        if ('\Walmart\Models\MP\US\Fulfillment\ServiceResponse' !== 'string') {
                            $content = $contentType === 'application/xml' ? simplexml_load_string($content) : json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, '\Walmart\Models\MP\US\Fulfillment\ServiceResponse', $response->getHeaders());
            }

            $returnType = '\Walmart\Models\MP\US\Fulfillment\ServiceResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                $contentType = $response->getHeader('Content-Type')[0] ?? '';
                if ($returnType !== 'string') {
                    $content = $contentType === 'application/xml' ? simplexml_load_string($content) : json_decode($content);
                }
            }

            return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Walmart\Models\MP\US\Fulfillment\ServiceResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }

            $this->writeDebug($e);
            throw $e;
        }
    }

    /**
     * Operation wercsFeedbackAsync
     *
     * Hazmat Items On hold
     *
     * @param  \Walmart\Models\MP\US\Fulfillment\WercsFeedbackRequest $wercsFeedbackRequest Request fields (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function wercsFeedbackAsync(
        \Walmart\Models\MP\US\Fulfillment\WercsFeedbackRequest $wercsFeedbackRequest
    ): PromiseInterface {
        return $this->wercsFeedbackAsyncWithHttpInfo($wercsFeedbackRequest)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation wercsFeedbackAsyncWithHttpInfo
     *
     * Hazmat Items On hold
     *
     * @param  \Walmart\Models\MP\US\Fulfillment\WercsFeedbackRequest $wercsFeedbackRequest Request fields (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    protected function wercsFeedbackAsyncWithHttpInfo(
        \Walmart\Models\MP\US\Fulfillment\WercsFeedbackRequest $wercsFeedbackRequest,
    ): PromiseInterface {
        $returnType = '\Walmart\Models\MP\US\Fulfillment\ServiceResponse';
        $request = $this->wercsFeedbackRequest($wercsFeedbackRequest);
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $this->writeDebug($response);
                    $this->writeDebug((string) $response->getBody());
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $hasResponse = !empty($response);
                    $body = (string) ($hasResponse ? $response->getBody() : '[NULL response]');
                    $this->writeDebug($response);
                    $statusCode = $hasResponse ? $response->getStatusCode() : $exception->getCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $body,
                    );
                }
            );
    }

    /**
     * Create request for operation 'wercsFeedback'
     *
     * @param  \Walmart\Models\MP\US\Fulfillment\WercsFeedbackRequest $wercsFeedbackRequest Request fields (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function wercsFeedbackRequest(
        \Walmart\Models\MP\US\Fulfillment\WercsFeedbackRequest $wercsFeedbackRequest,
    ): Request {
        $contentType = self::contentTypes['wercsFeedback'];

        // verify the required parameter 'wercsFeedbackRequest' is set
        if ($wercsFeedbackRequest === null || (is_array($wercsFeedbackRequest) && count($wercsFeedbackRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $wercsFeedbackRequest when calling wercsFeedback'
            );
        }
        $resourcePath = '/v3/items/onhold/search';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $method = 'POST';

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = parent::getDefaultHeaders();
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        // for model (json/xml)
        if (isset($wercsFeedbackRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($wercsFeedbackRequest));
            } else {
                $httpBody = $wercsFeedbackRequest;
            }
        } else if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        $query = ObjectSerializer::buildQuery($queryParams);
        $requestInfo = [
            'path' => $resourcePath,
            'method' => $method,
            'timestamp' => $defaultHeaders['WM_SEC.TIMESTAMP'],
            'query' => $query,
        ];

        // this endpoint requires Bearer authentication (access token)
        $token = $this->config->getAccessToken();
        if ($token) {
            $headers['WM_SEC.ACCESS_TOKEN'] = $token->accessToken;
        }

        $operationHost = $this->config->getHost();
        return new Request(
            $method,
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }
}

