<?php

/**
 * DSVInventoryApi
 * PHP version 7.4
 *
 * @category Class
 * @package  Walmart
 * @author   Jesse Evers
 * @link     https://highsidelabs.co
 */

/**
 * Inventory Management
 *
 * This class is auto-generated by the OpenAPI generator v6.6.0 (https://openapi-generator.tech).
 * Do not edit the class manually.
 */

namespace Walmart\Apis\Supplier\US;

use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Promise\PromiseInterface;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use Walmart\Apis\BaseApi;
use Walmart\ApiException;
use Walmart\ObjectSerializer;

/**
 * DSVInventoryApi Class Doc Comment
 *
 * @category Class
 * @package  Walmart
 * @author   Jesse Evers
 * @link     https://highsidelabs.co
 * @email    jesse@highsidelabs.co
 */
class DSVInventoryApi extends BaseApi
{
    /**
     * @var string[] $contentTypes
     */
    public const contentTypes = [
        'getInventoryForAnItem' => 'application/json',
        'getMultiNodeInventoryForSkuAndAllShipnodes' => 'application/json',
        'updateBulkInventory' => 'application/json',
        'updateInventoryForAnItem' => 'application/json',
    ];

    /**
     * Operation getInventoryForAnItem
     *
     * Inventory
     *
     * @param  string $gtin Specifies the global trade item number (GTIN) item identifier.   The global trade item number is a 14-digit number, including the check digit, that is used worldwide and identifies the Each. If the user's number is less than 14 digits, add zeros at the beginning.   Either the `sku` or `gtin` parameter will be required. The user can only submit one. (required)
     * @param  string $shipNode Specifies the distribution facility distributor identifier.    This parameter identifies each facility from which the inventory is requested. The identifier is autogenerated during drop ship vendor (DSV) account creation. Every time users add or update a facility in Supplier Center, a new identifier is generated. (required)
     * @param  string $sku Specifies the stock keeping unit (SKU) item identifier.   This type of identifier is an arbitrary, alphanumeric identifier that is specified by the drop ship vendor (DSV) and used by the vendor in the specification file to refer to each item.   Either the 'sku' or 'gtin' parameter will be required. The user can only submit one.   The following special characters in the stock keeping unit (SKU) require encoding: ':', '/', '?', '#', '[', ']', '@', '!', '$', '&', \"'\", '(', ')', '*', '+', ',', ';', '=', ‘ ’, '{', and '}'. '%' requires encoding if it is part of the stock keeping unit (SKU). Encode spaces with %20. Other characters do not require encoding. (optional)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Walmart\Models\Supplier\US\DSVInventory\InventoryResponse
     */
    public function getInventoryForAnItem(
        string $gtin,
        string $shipNode,
        ?string $sku = null
    ): \Walmart\Models\Supplier\US\DSVInventory\InventoryResponse {
        return $this->getInventoryForAnItemWithHttpInfo($gtin, $shipNode, $sku);
    }

    /**
     * Operation getInventoryForAnItemWithHttpInfo
     *
     * Inventory
     *
     * @param  string $gtin Specifies the global trade item number (GTIN) item identifier.   The global trade item number is a 14-digit number, including the check digit, that is used worldwide and identifies the Each. If the user's number is less than 14 digits, add zeros at the beginning.   Either the `sku` or `gtin` parameter will be required. The user can only submit one. (required)
     * @param  string $shipNode Specifies the distribution facility distributor identifier.    This parameter identifies each facility from which the inventory is requested. The identifier is autogenerated during drop ship vendor (DSV) account creation. Every time users add or update a facility in Supplier Center, a new identifier is generated. (required)
     * @param  string $sku Specifies the stock keeping unit (SKU) item identifier.   This type of identifier is an arbitrary, alphanumeric identifier that is specified by the drop ship vendor (DSV) and used by the vendor in the specification file to refer to each item.   Either the 'sku' or 'gtin' parameter will be required. The user can only submit one.   The following special characters in the stock keeping unit (SKU) require encoding: ':', '/', '?', '#', '[', ']', '@', '!', '$', '&', \"'\", '(', ')', '*', '+', ',', ';', '=', ‘ ’, '{', and '}'. '%' requires encoding if it is part of the stock keeping unit (SKU). Encode spaces with %20. Other characters do not require encoding. (optional)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Walmart\Models\Supplier\US\DSVInventory\InventoryResponse
     */
    protected function getInventoryForAnItemWithHttpInfo(
        string $gtin,
        string $shipNode,
        ?string $sku = null,
    ): \Walmart\Models\Supplier\US\DSVInventory\InventoryResponse {
        $request = $this->getInventoryForAnItemRequest($gtin, $shipNode, $sku);
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
                $this->writeDebug($response);
                $this->writeDebug((string) $response->getBody());
            } catch (RequestException $e) {
                $hasResponse = !empty($e->hasResponse());
                $body = (string) ($hasResponse ? $e->getResponse()->getBody() : '[NULL response]');
                $this->writeDebug($e->getResponse());
                $this->writeDebug($body);

                throw new ApiException(
                    "[{$e->getCode()}] {$body}",
                    (int) $e->getCode(),
                    $hasResponse ? $e->getResponse()->getHeaders() : null,
                    $body
                );
            } catch (ConnectException $e) {
                $this->writeDebug($e->getMessage());

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }
            switch ($statusCode) {
                case 200:
                    if ('\Walmart\Models\Supplier\US\DSVInventory\InventoryResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        $contentType = $response->getHeader('Content-Type')[0] ?? '';
                        if ('\Walmart\Models\Supplier\US\DSVInventory\InventoryResponse' !== 'string') {
                            $content = $contentType === 'application/xml' ? simplexml_load_string($content) : json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, '\Walmart\Models\Supplier\US\DSVInventory\InventoryResponse', $response->getHeaders());
            }

            $returnType = '\Walmart\Models\Supplier\US\DSVInventory\InventoryResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                $contentType = $response->getHeader('Content-Type')[0] ?? '';
                if ($returnType !== 'string') {
                    $content = $contentType === 'application/xml' ? simplexml_load_string($content) : json_decode($content);
                }
            }

            return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Walmart\Models\Supplier\US\DSVInventory\InventoryResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }

            $this->writeDebug($e);
            throw $e;
        }
    }

    /**
     * Operation getInventoryForAnItemAsync
     *
     * Inventory
     *
     * @param  string $gtin Specifies the global trade item number (GTIN) item identifier.   The global trade item number is a 14-digit number, including the check digit, that is used worldwide and identifies the Each. If the user's number is less than 14 digits, add zeros at the beginning.   Either the `sku` or `gtin` parameter will be required. The user can only submit one. (required)
     * @param  string $shipNode Specifies the distribution facility distributor identifier.    This parameter identifies each facility from which the inventory is requested. The identifier is autogenerated during drop ship vendor (DSV) account creation. Every time users add or update a facility in Supplier Center, a new identifier is generated. (required)
     * @param  string $sku Specifies the stock keeping unit (SKU) item identifier.   This type of identifier is an arbitrary, alphanumeric identifier that is specified by the drop ship vendor (DSV) and used by the vendor in the specification file to refer to each item.   Either the 'sku' or 'gtin' parameter will be required. The user can only submit one.   The following special characters in the stock keeping unit (SKU) require encoding: ':', '/', '?', '#', '[', ']', '@', '!', '$', '&', \"'\", '(', ')', '*', '+', ',', ';', '=', ‘ ’, '{', and '}'. '%' requires encoding if it is part of the stock keeping unit (SKU). Encode spaces with %20. Other characters do not require encoding. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getInventoryForAnItemAsync(
        string $gtin,
        string $shipNode,
        ?string $sku = null
    ): PromiseInterface {
        return $this->getInventoryForAnItemAsyncWithHttpInfo($gtin, $shipNode, $sku)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getInventoryForAnItemAsyncWithHttpInfo
     *
     * Inventory
     *
     * @param  string $gtin Specifies the global trade item number (GTIN) item identifier.   The global trade item number is a 14-digit number, including the check digit, that is used worldwide and identifies the Each. If the user's number is less than 14 digits, add zeros at the beginning.   Either the `sku` or `gtin` parameter will be required. The user can only submit one. (required)
     * @param  string $shipNode Specifies the distribution facility distributor identifier.    This parameter identifies each facility from which the inventory is requested. The identifier is autogenerated during drop ship vendor (DSV) account creation. Every time users add or update a facility in Supplier Center, a new identifier is generated. (required)
     * @param  string $sku Specifies the stock keeping unit (SKU) item identifier.   This type of identifier is an arbitrary, alphanumeric identifier that is specified by the drop ship vendor (DSV) and used by the vendor in the specification file to refer to each item.   Either the 'sku' or 'gtin' parameter will be required. The user can only submit one.   The following special characters in the stock keeping unit (SKU) require encoding: ':', '/', '?', '#', '[', ']', '@', '!', '$', '&', \"'\", '(', ')', '*', '+', ',', ';', '=', ‘ ’, '{', and '}'. '%' requires encoding if it is part of the stock keeping unit (SKU). Encode spaces with %20. Other characters do not require encoding. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    protected function getInventoryForAnItemAsyncWithHttpInfo(
        string $gtin,
        string $shipNode,
        ?string $sku = null,
    ): PromiseInterface {
        $returnType = '\Walmart\Models\Supplier\US\DSVInventory\InventoryResponse';
        $request = $this->getInventoryForAnItemRequest($gtin, $shipNode, $sku);
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $this->writeDebug($response);
                    $this->writeDebug((string) $response->getBody());
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $hasResponse = !empty($response);
                    $body = (string) ($hasResponse ? $response->getBody() : '[NULL response]');
                    $this->writeDebug($response);
                    $statusCode = $hasResponse ? $response->getStatusCode() : $exception->getCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $body,
                    );
                }
            );
    }

    /**
     * Create request for operation 'getInventoryForAnItem'
     *
     * @param  string $gtin Specifies the global trade item number (GTIN) item identifier.   The global trade item number is a 14-digit number, including the check digit, that is used worldwide and identifies the Each. If the user's number is less than 14 digits, add zeros at the beginning.   Either the `sku` or `gtin` parameter will be required. The user can only submit one. (required)
     * @param  string $shipNode Specifies the distribution facility distributor identifier.    This parameter identifies each facility from which the inventory is requested. The identifier is autogenerated during drop ship vendor (DSV) account creation. Every time users add or update a facility in Supplier Center, a new identifier is generated. (required)
     * @param  string $sku Specifies the stock keeping unit (SKU) item identifier.   This type of identifier is an arbitrary, alphanumeric identifier that is specified by the drop ship vendor (DSV) and used by the vendor in the specification file to refer to each item.   Either the 'sku' or 'gtin' parameter will be required. The user can only submit one.   The following special characters in the stock keeping unit (SKU) require encoding: ':', '/', '?', '#', '[', ']', '@', '!', '$', '&', \"'\", '(', ')', '*', '+', ',', ';', '=', ‘ ’, '{', and '}'. '%' requires encoding if it is part of the stock keeping unit (SKU). Encode spaces with %20. Other characters do not require encoding. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getInventoryForAnItemRequest(
        string $gtin,
        string $shipNode,
        ?string $sku = null,
    ): Request {
        $contentType = self::contentTypes['getInventoryForAnItem'];

        // verify the required parameter 'gtin' is set
        if ($gtin === null || (is_array($gtin) && count($gtin) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $gtin when calling getInventoryForAnItem'
            );
        }
        // verify the required parameter 'shipNode' is set
        if ($shipNode === null || (is_array($shipNode) && count($shipNode) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $shipNode when calling getInventoryForAnItem'
            );
        }
        $resourcePath = '/v3/inventory';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $method = 'GET';

        // query params
        $queryParams = array_merge(
            ObjectSerializer::toQueryValue(
                $sku,
                'sku', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? [],
            ObjectSerializer::toQueryValue(
                $gtin,
                'gtin', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                true // required
            ) ?? [],
            ObjectSerializer::toQueryValue(
                $shipNode,
                'shipNode', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                true // required
            ) ?? [],
        );

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = parent::getDefaultHeaders();
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        $query = ObjectSerializer::buildQuery($queryParams);
        $requestInfo = [
            'path' => $resourcePath,
            'method' => $method,
            'timestamp' => $defaultHeaders['WM_SEC.TIMESTAMP'],
            'query' => $query,
        ];

        $partnerApiKey = $this->config->getApiKey('partner', $requestInfo);
        if ($partnerApiKey !== null) {
            $headers['WM_PARTNER.ID'] = $partnerApiKey;
        }

        $signatureApiKey = $this->config->getApiKey('signature', $requestInfo);
        if ($signatureApiKey !== null) {
            $headers['WM_SEC.AUTH_SIGNATURE'] = $signatureApiKey;
        }

        $consumerIdApiKey = $this->config->getApiKey('consumerId', $requestInfo);
        if ($consumerIdApiKey !== null) {
            $headers['WM_CONSUMER.ID'] = $consumerIdApiKey;
        }

        // this endpoint requires Bearer authentication (access token)
        $token = $this->config->getAccessToken();
        if ($token) {
            $headers['WM_SEC.ACCESS_TOKEN'] = $token->accessToken;
        }

        $operationHost = $this->config->getHost();
        return new Request(
            $method,
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getMultiNodeInventoryForSkuAndAllShipnodes
     *
     * Single Item Inventory Across Ship Nodes
     *
     * @param  string $id Specifies the value of the stock keeping unit (SKU) or global trade item number (GTIN) item identifier.   This value is provided by the drop ship vendor (DSV) to identify each item. (required)
     * @param  string $productIdType Specifies the type of item ID the user is searching.   Default: sku (required)
     * @param  string $shipNode Specifies the distribution facility distributor identifier.    This parameter identifies each facility from which the inventory is requested. The identifier is autogenerated during drop ship vendor (DSV) account creation. Every time users add or update a facility in Supplier Center, a new identifier is generated. (optional)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Walmart\Models\Supplier\US\DSVInventory\InventoriesDTO
     */
    public function getMultiNodeInventoryForSkuAndAllShipnodes(
        string $id,
        string $productIdType,
        ?string $shipNode = null
    ): \Walmart\Models\Supplier\US\DSVInventory\InventoriesDTO {
        return $this->getMultiNodeInventoryForSkuAndAllShipnodesWithHttpInfo($id, $productIdType, $shipNode);
    }

    /**
     * Operation getMultiNodeInventoryForSkuAndAllShipnodesWithHttpInfo
     *
     * Single Item Inventory Across Ship Nodes
     *
     * @param  string $id Specifies the value of the stock keeping unit (SKU) or global trade item number (GTIN) item identifier.   This value is provided by the drop ship vendor (DSV) to identify each item. (required)
     * @param  string $productIdType Specifies the type of item ID the user is searching.   Default: sku (required)
     * @param  string $shipNode Specifies the distribution facility distributor identifier.    This parameter identifies each facility from which the inventory is requested. The identifier is autogenerated during drop ship vendor (DSV) account creation. Every time users add or update a facility in Supplier Center, a new identifier is generated. (optional)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Walmart\Models\Supplier\US\DSVInventory\InventoriesDTO
     */
    protected function getMultiNodeInventoryForSkuAndAllShipnodesWithHttpInfo(
        string $id,
        string $productIdType,
        ?string $shipNode = null,
    ): \Walmart\Models\Supplier\US\DSVInventory\InventoriesDTO {
        $request = $this->getMultiNodeInventoryForSkuAndAllShipnodesRequest($id, $productIdType, $shipNode);
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
                $this->writeDebug($response);
                $this->writeDebug((string) $response->getBody());
            } catch (RequestException $e) {
                $hasResponse = !empty($e->hasResponse());
                $body = (string) ($hasResponse ? $e->getResponse()->getBody() : '[NULL response]');
                $this->writeDebug($e->getResponse());
                $this->writeDebug($body);

                throw new ApiException(
                    "[{$e->getCode()}] {$body}",
                    (int) $e->getCode(),
                    $hasResponse ? $e->getResponse()->getHeaders() : null,
                    $body
                );
            } catch (ConnectException $e) {
                $this->writeDebug($e->getMessage());

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }
            switch ($statusCode) {
                case 200:
                    if ('\Walmart\Models\Supplier\US\DSVInventory\InventoriesDTO' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        $contentType = $response->getHeader('Content-Type')[0] ?? '';
                        if ('\Walmart\Models\Supplier\US\DSVInventory\InventoriesDTO' !== 'string') {
                            $content = $contentType === 'application/xml' ? simplexml_load_string($content) : json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, '\Walmart\Models\Supplier\US\DSVInventory\InventoriesDTO', $response->getHeaders());
            }

            $returnType = '\Walmart\Models\Supplier\US\DSVInventory\InventoriesDTO';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                $contentType = $response->getHeader('Content-Type')[0] ?? '';
                if ($returnType !== 'string') {
                    $content = $contentType === 'application/xml' ? simplexml_load_string($content) : json_decode($content);
                }
            }

            return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Walmart\Models\Supplier\US\DSVInventory\InventoriesDTO',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }

            $this->writeDebug($e);
            throw $e;
        }
    }

    /**
     * Operation getMultiNodeInventoryForSkuAndAllShipnodesAsync
     *
     * Single Item Inventory Across Ship Nodes
     *
     * @param  string $id Specifies the value of the stock keeping unit (SKU) or global trade item number (GTIN) item identifier.   This value is provided by the drop ship vendor (DSV) to identify each item. (required)
     * @param  string $productIdType Specifies the type of item ID the user is searching.   Default: sku (required)
     * @param  string $shipNode Specifies the distribution facility distributor identifier.    This parameter identifies each facility from which the inventory is requested. The identifier is autogenerated during drop ship vendor (DSV) account creation. Every time users add or update a facility in Supplier Center, a new identifier is generated. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMultiNodeInventoryForSkuAndAllShipnodesAsync(
        string $id,
        string $productIdType,
        ?string $shipNode = null
    ): PromiseInterface {
        return $this->getMultiNodeInventoryForSkuAndAllShipnodesAsyncWithHttpInfo($id, $productIdType, $shipNode)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getMultiNodeInventoryForSkuAndAllShipnodesAsyncWithHttpInfo
     *
     * Single Item Inventory Across Ship Nodes
     *
     * @param  string $id Specifies the value of the stock keeping unit (SKU) or global trade item number (GTIN) item identifier.   This value is provided by the drop ship vendor (DSV) to identify each item. (required)
     * @param  string $productIdType Specifies the type of item ID the user is searching.   Default: sku (required)
     * @param  string $shipNode Specifies the distribution facility distributor identifier.    This parameter identifies each facility from which the inventory is requested. The identifier is autogenerated during drop ship vendor (DSV) account creation. Every time users add or update a facility in Supplier Center, a new identifier is generated. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    protected function getMultiNodeInventoryForSkuAndAllShipnodesAsyncWithHttpInfo(
        string $id,
        string $productIdType,
        ?string $shipNode = null,
    ): PromiseInterface {
        $returnType = '\Walmart\Models\Supplier\US\DSVInventory\InventoriesDTO';
        $request = $this->getMultiNodeInventoryForSkuAndAllShipnodesRequest($id, $productIdType, $shipNode);
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $this->writeDebug($response);
                    $this->writeDebug((string) $response->getBody());
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $hasResponse = !empty($response);
                    $body = (string) ($hasResponse ? $response->getBody() : '[NULL response]');
                    $this->writeDebug($response);
                    $statusCode = $hasResponse ? $response->getStatusCode() : $exception->getCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $body,
                    );
                }
            );
    }

    /**
     * Create request for operation 'getMultiNodeInventoryForSkuAndAllShipnodes'
     *
     * @param  string $id Specifies the value of the stock keeping unit (SKU) or global trade item number (GTIN) item identifier.   This value is provided by the drop ship vendor (DSV) to identify each item. (required)
     * @param  string $productIdType Specifies the type of item ID the user is searching.   Default: sku (required)
     * @param  string $shipNode Specifies the distribution facility distributor identifier.    This parameter identifies each facility from which the inventory is requested. The identifier is autogenerated during drop ship vendor (DSV) account creation. Every time users add or update a facility in Supplier Center, a new identifier is generated. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getMultiNodeInventoryForSkuAndAllShipnodesRequest(
        string $id,
        string $productIdType,
        ?string $shipNode = null,
    ): Request {
        $contentType = self::contentTypes['getMultiNodeInventoryForSkuAndAllShipnodes'];

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getMultiNodeInventoryForSkuAndAllShipnodes'
            );
        }
        // verify the required parameter 'productIdType' is set
        if ($productIdType === null || (is_array($productIdType) && count($productIdType) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $productIdType when calling getMultiNodeInventoryForSkuAndAllShipnodes'
            );
        }
        $resourcePath = '/v3/inventories/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $method = 'GET';

        // query params
        $queryParams = array_merge(
            ObjectSerializer::toQueryValue(
                $shipNode,
                'shipNode', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? [],
            ObjectSerializer::toQueryValue(
                $productIdType,
                'productIdType', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                true // required
            ) ?? [],
        );

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = parent::getDefaultHeaders();
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        $query = ObjectSerializer::buildQuery($queryParams);
        $requestInfo = [
            'path' => $resourcePath,
            'method' => $method,
            'timestamp' => $defaultHeaders['WM_SEC.TIMESTAMP'],
            'query' => $query,
        ];

        $partnerApiKey = $this->config->getApiKey('partner', $requestInfo);
        if ($partnerApiKey !== null) {
            $headers['WM_PARTNER.ID'] = $partnerApiKey;
        }

        $signatureApiKey = $this->config->getApiKey('signature', $requestInfo);
        if ($signatureApiKey !== null) {
            $headers['WM_SEC.AUTH_SIGNATURE'] = $signatureApiKey;
        }

        $consumerIdApiKey = $this->config->getApiKey('consumerId', $requestInfo);
        if ($consumerIdApiKey !== null) {
            $headers['WM_CONSUMER.ID'] = $consumerIdApiKey;
        }

        // this endpoint requires Bearer authentication (access token)
        $token = $this->config->getAccessToken();
        if ($token) {
            $headers['WM_SEC.ACCESS_TOKEN'] = $token->accessToken;
        }

        $operationHost = $this->config->getHost();
        return new Request(
            $method,
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateBulkInventory
     *
     * Bulk Update Inventory
     *
     * @param  string $feedType Specifies the feed type. (required)
     * @param  \Walmart\Models\Supplier\US\DSVInventory\InventoryFeedV2 $inventoryFeedV2 File fields (required)
     * @param  string $shipNode Specifies the distribution facility distributor identifier.    This parameter identifies each facility from which the inventory is requested.   The parameter is required for `Inventory` feed type. It is not required for `DSV_INVENTORY` feed type.   The identifier is autogenerated during drop ship vendor (DSV) account creation. Every time users add or update a facility in Supplier Center, a new identifier is generated. (optional)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Walmart\Models\Supplier\US\DSVInventory\FeedIdInventory
     */
    public function updateBulkInventory(
        string $feedType,
        \Walmart\Models\Supplier\US\DSVInventory\InventoryFeedV2 $inventoryFeedV2,
        ?string $shipNode = null
    ): \Walmart\Models\Supplier\US\DSVInventory\FeedIdInventory {
        return $this->updateBulkInventoryWithHttpInfo($feedType, $inventoryFeedV2, $shipNode);
    }

    /**
     * Operation updateBulkInventoryWithHttpInfo
     *
     * Bulk Update Inventory
     *
     * @param  string $feedType Specifies the feed type. (required)
     * @param  \Walmart\Models\Supplier\US\DSVInventory\InventoryFeedV2 $inventoryFeedV2 File fields (required)
     * @param  string $shipNode Specifies the distribution facility distributor identifier.    This parameter identifies each facility from which the inventory is requested.   The parameter is required for `Inventory` feed type. It is not required for `DSV_INVENTORY` feed type.   The identifier is autogenerated during drop ship vendor (DSV) account creation. Every time users add or update a facility in Supplier Center, a new identifier is generated. (optional)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Walmart\Models\Supplier\US\DSVInventory\FeedIdInventory
     */
    protected function updateBulkInventoryWithHttpInfo(
        string $feedType,
        \Walmart\Models\Supplier\US\DSVInventory\InventoryFeedV2 $inventoryFeedV2,
        ?string $shipNode = null,
    ): \Walmart\Models\Supplier\US\DSVInventory\FeedIdInventory {
        $request = $this->updateBulkInventoryRequest($feedType, $inventoryFeedV2, $shipNode);
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
                $this->writeDebug($response);
                $this->writeDebug((string) $response->getBody());
            } catch (RequestException $e) {
                $hasResponse = !empty($e->hasResponse());
                $body = (string) ($hasResponse ? $e->getResponse()->getBody() : '[NULL response]');
                $this->writeDebug($e->getResponse());
                $this->writeDebug($body);

                throw new ApiException(
                    "[{$e->getCode()}] {$body}",
                    (int) $e->getCode(),
                    $hasResponse ? $e->getResponse()->getHeaders() : null,
                    $body
                );
            } catch (ConnectException $e) {
                $this->writeDebug($e->getMessage());

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }
            switch ($statusCode) {
                case 200:
                    if ('\Walmart\Models\Supplier\US\DSVInventory\FeedIdInventory' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        $contentType = $response->getHeader('Content-Type')[0] ?? '';
                        if ('\Walmart\Models\Supplier\US\DSVInventory\FeedIdInventory' !== 'string') {
                            $content = $contentType === 'application/xml' ? simplexml_load_string($content) : json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, '\Walmart\Models\Supplier\US\DSVInventory\FeedIdInventory', $response->getHeaders());
            }

            $returnType = '\Walmart\Models\Supplier\US\DSVInventory\FeedIdInventory';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                $contentType = $response->getHeader('Content-Type')[0] ?? '';
                if ($returnType !== 'string') {
                    $content = $contentType === 'application/xml' ? simplexml_load_string($content) : json_decode($content);
                }
            }

            return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Walmart\Models\Supplier\US\DSVInventory\FeedIdInventory',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }

            $this->writeDebug($e);
            throw $e;
        }
    }

    /**
     * Operation updateBulkInventoryAsync
     *
     * Bulk Update Inventory
     *
     * @param  string $feedType Specifies the feed type. (required)
     * @param  \Walmart\Models\Supplier\US\DSVInventory\InventoryFeedV2 $inventoryFeedV2 File fields (required)
     * @param  string $shipNode Specifies the distribution facility distributor identifier.    This parameter identifies each facility from which the inventory is requested.   The parameter is required for `Inventory` feed type. It is not required for `DSV_INVENTORY` feed type.   The identifier is autogenerated during drop ship vendor (DSV) account creation. Every time users add or update a facility in Supplier Center, a new identifier is generated. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateBulkInventoryAsync(
        string $feedType,
        \Walmart\Models\Supplier\US\DSVInventory\InventoryFeedV2 $inventoryFeedV2,
        ?string $shipNode = null
    ): PromiseInterface {
        return $this->updateBulkInventoryAsyncWithHttpInfo($feedType, $inventoryFeedV2, $shipNode)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateBulkInventoryAsyncWithHttpInfo
     *
     * Bulk Update Inventory
     *
     * @param  string $feedType Specifies the feed type. (required)
     * @param  \Walmart\Models\Supplier\US\DSVInventory\InventoryFeedV2 $inventoryFeedV2 File fields (required)
     * @param  string $shipNode Specifies the distribution facility distributor identifier.    This parameter identifies each facility from which the inventory is requested.   The parameter is required for `Inventory` feed type. It is not required for `DSV_INVENTORY` feed type.   The identifier is autogenerated during drop ship vendor (DSV) account creation. Every time users add or update a facility in Supplier Center, a new identifier is generated. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    protected function updateBulkInventoryAsyncWithHttpInfo(
        string $feedType,
        \Walmart\Models\Supplier\US\DSVInventory\InventoryFeedV2 $inventoryFeedV2,
        ?string $shipNode = null,
    ): PromiseInterface {
        $returnType = '\Walmart\Models\Supplier\US\DSVInventory\FeedIdInventory';
        $request = $this->updateBulkInventoryRequest($feedType, $inventoryFeedV2, $shipNode);
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $this->writeDebug($response);
                    $this->writeDebug((string) $response->getBody());
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $hasResponse = !empty($response);
                    $body = (string) ($hasResponse ? $response->getBody() : '[NULL response]');
                    $this->writeDebug($response);
                    $statusCode = $hasResponse ? $response->getStatusCode() : $exception->getCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $body,
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateBulkInventory'
     *
     * @param  string $feedType Specifies the feed type. (required)
     * @param  \Walmart\Models\Supplier\US\DSVInventory\InventoryFeedV2 $inventoryFeedV2 File fields (required)
     * @param  string $shipNode Specifies the distribution facility distributor identifier.    This parameter identifies each facility from which the inventory is requested.   The parameter is required for `Inventory` feed type. It is not required for `DSV_INVENTORY` feed type.   The identifier is autogenerated during drop ship vendor (DSV) account creation. Every time users add or update a facility in Supplier Center, a new identifier is generated. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateBulkInventoryRequest(
        string $feedType,
        \Walmart\Models\Supplier\US\DSVInventory\InventoryFeedV2 $inventoryFeedV2,
        ?string $shipNode = null,
    ): Request {
        $contentType = self::contentTypes['updateBulkInventory'];

        // verify the required parameter 'feedType' is set
        if ($feedType === null || (is_array($feedType) && count($feedType) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $feedType when calling updateBulkInventory'
            );
        }
        // verify the required parameter 'inventoryFeedV2' is set
        if ($inventoryFeedV2 === null || (is_array($inventoryFeedV2) && count($inventoryFeedV2) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inventoryFeedV2 when calling updateBulkInventory'
            );
        }
        $resourcePath = '/v3/feeds';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $method = 'POST';

        // query params
        $queryParams = array_merge(
            ObjectSerializer::toQueryValue(
                $feedType,
                'feedType', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                true // required
            ) ?? [],
            ObjectSerializer::toQueryValue(
                $shipNode,
                'shipNode', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                false // required
            ) ?? [],
        );

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = parent::getDefaultHeaders();
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        // for model (json/xml)
        if (isset($inventoryFeedV2)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($inventoryFeedV2));
            } else {
                $httpBody = $inventoryFeedV2;
            }
        } else if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        $query = ObjectSerializer::buildQuery($queryParams);
        $requestInfo = [
            'path' => $resourcePath,
            'method' => $method,
            'timestamp' => $defaultHeaders['WM_SEC.TIMESTAMP'],
            'query' => $query,
        ];

        $partnerApiKey = $this->config->getApiKey('partner', $requestInfo);
        if ($partnerApiKey !== null) {
            $headers['WM_PARTNER.ID'] = $partnerApiKey;
        }

        $signatureApiKey = $this->config->getApiKey('signature', $requestInfo);
        if ($signatureApiKey !== null) {
            $headers['WM_SEC.AUTH_SIGNATURE'] = $signatureApiKey;
        }

        $consumerIdApiKey = $this->config->getApiKey('consumerId', $requestInfo);
        if ($consumerIdApiKey !== null) {
            $headers['WM_CONSUMER.ID'] = $consumerIdApiKey;
        }

        // this endpoint requires Bearer authentication (access token)
        $token = $this->config->getAccessToken();
        if ($token) {
            $headers['WM_SEC.ACCESS_TOKEN'] = $token->accessToken;
        }

        $operationHost = $this->config->getHost();
        return new Request(
            $method,
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateInventoryForAnItem
     *
     * Update Inventory
     *
     * @param  string $shipNode Specifies the distribution facility distributor identifier.    This parameter identifies each facility from which the inventory is requested. The identifier is autogenerated during drop ship vendor (DSV) account creation. Every time users add or update a facility in Supplier Center, a new identifier is generated. (required)
     * @param  \Walmart\Models\Supplier\US\DSVInventory\Inventory $inventory File fields (required)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Walmart\Models\Supplier\US\DSVInventory\InventoryResponse
     */
    public function updateInventoryForAnItem(
        string $shipNode,
        \Walmart\Models\Supplier\US\DSVInventory\Inventory $inventory
    ): \Walmart\Models\Supplier\US\DSVInventory\InventoryResponse {
        return $this->updateInventoryForAnItemWithHttpInfo($shipNode, $inventory);
    }

    /**
     * Operation updateInventoryForAnItemWithHttpInfo
     *
     * Update Inventory
     *
     * @param  string $shipNode Specifies the distribution facility distributor identifier.    This parameter identifies each facility from which the inventory is requested. The identifier is autogenerated during drop ship vendor (DSV) account creation. Every time users add or update a facility in Supplier Center, a new identifier is generated. (required)
     * @param  \Walmart\Models\Supplier\US\DSVInventory\Inventory $inventory File fields (required)
     *
     * @throws \Walmart\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Walmart\Models\Supplier\US\DSVInventory\InventoryResponse
     */
    protected function updateInventoryForAnItemWithHttpInfo(
        string $shipNode,
        \Walmart\Models\Supplier\US\DSVInventory\Inventory $inventory,
    ): \Walmart\Models\Supplier\US\DSVInventory\InventoryResponse {
        $request = $this->updateInventoryForAnItemRequest($shipNode, $inventory);
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
                $this->writeDebug($response);
                $this->writeDebug((string) $response->getBody());
            } catch (RequestException $e) {
                $hasResponse = !empty($e->hasResponse());
                $body = (string) ($hasResponse ? $e->getResponse()->getBody() : '[NULL response]');
                $this->writeDebug($e->getResponse());
                $this->writeDebug($body);

                throw new ApiException(
                    "[{$e->getCode()}] {$body}",
                    (int) $e->getCode(),
                    $hasResponse ? $e->getResponse()->getHeaders() : null,
                    $body
                );
            } catch (ConnectException $e) {
                $this->writeDebug($e->getMessage());

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }
            switch ($statusCode) {
                case 200:
                    if ('\Walmart\Models\Supplier\US\DSVInventory\InventoryResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        $contentType = $response->getHeader('Content-Type')[0] ?? '';
                        if ('\Walmart\Models\Supplier\US\DSVInventory\InventoryResponse' !== 'string') {
                            $content = $contentType === 'application/xml' ? simplexml_load_string($content) : json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, '\Walmart\Models\Supplier\US\DSVInventory\InventoryResponse', $response->getHeaders());
            }

            $returnType = '\Walmart\Models\Supplier\US\DSVInventory\InventoryResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                $contentType = $response->getHeader('Content-Type')[0] ?? '';
                if ($returnType !== 'string') {
                    $content = $contentType === 'application/xml' ? simplexml_load_string($content) : json_decode($content);
                }
            }

            return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Walmart\Models\Supplier\US\DSVInventory\InventoryResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }

            $this->writeDebug($e);
            throw $e;
        }
    }

    /**
     * Operation updateInventoryForAnItemAsync
     *
     * Update Inventory
     *
     * @param  string $shipNode Specifies the distribution facility distributor identifier.    This parameter identifies each facility from which the inventory is requested. The identifier is autogenerated during drop ship vendor (DSV) account creation. Every time users add or update a facility in Supplier Center, a new identifier is generated. (required)
     * @param  \Walmart\Models\Supplier\US\DSVInventory\Inventory $inventory File fields (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateInventoryForAnItemAsync(
        string $shipNode,
        \Walmart\Models\Supplier\US\DSVInventory\Inventory $inventory
    ): PromiseInterface {
        return $this->updateInventoryForAnItemAsyncWithHttpInfo($shipNode, $inventory)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateInventoryForAnItemAsyncWithHttpInfo
     *
     * Update Inventory
     *
     * @param  string $shipNode Specifies the distribution facility distributor identifier.    This parameter identifies each facility from which the inventory is requested. The identifier is autogenerated during drop ship vendor (DSV) account creation. Every time users add or update a facility in Supplier Center, a new identifier is generated. (required)
     * @param  \Walmart\Models\Supplier\US\DSVInventory\Inventory $inventory File fields (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    protected function updateInventoryForAnItemAsyncWithHttpInfo(
        string $shipNode,
        \Walmart\Models\Supplier\US\DSVInventory\Inventory $inventory,
    ): PromiseInterface {
        $returnType = '\Walmart\Models\Supplier\US\DSVInventory\InventoryResponse';
        $request = $this->updateInventoryForAnItemRequest($shipNode, $inventory);
        $this->writeDebug($request);
        $this->writeDebug((string) $request->getBody());

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $this->writeDebug($response);
                    $this->writeDebug((string) $response->getBody());
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return ObjectSerializer::deserialize($content, $returnType, $response->getHeaders());
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $hasResponse = !empty($response);
                    $body = (string) ($hasResponse ? $response->getBody() : '[NULL response]');
                    $this->writeDebug($response);
                    $statusCode = $hasResponse ? $response->getStatusCode() : $exception->getCode();

                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $body,
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateInventoryForAnItem'
     *
     * @param  string $shipNode Specifies the distribution facility distributor identifier.    This parameter identifies each facility from which the inventory is requested. The identifier is autogenerated during drop ship vendor (DSV) account creation. Every time users add or update a facility in Supplier Center, a new identifier is generated. (required)
     * @param  \Walmart\Models\Supplier\US\DSVInventory\Inventory $inventory File fields (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateInventoryForAnItemRequest(
        string $shipNode,
        \Walmart\Models\Supplier\US\DSVInventory\Inventory $inventory,
    ): Request {
        $contentType = self::contentTypes['updateInventoryForAnItem'];

        // verify the required parameter 'shipNode' is set
        if ($shipNode === null || (is_array($shipNode) && count($shipNode) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $shipNode when calling updateInventoryForAnItem'
            );
        }
        // verify the required parameter 'inventory' is set
        if ($inventory === null || (is_array($inventory) && count($inventory) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inventory when calling updateInventoryForAnItem'
            );
        }
        $resourcePath = '/v3/inventory';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;
        $method = 'PUT';

        // query params
        $queryParams = array_merge(
            ObjectSerializer::toQueryValue(
                $shipNode,
                'shipNode', // param base name
                'string', // openApiType
                'form', // style
                true, // explode
                true // required
            ) ?? [],
        );

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        $defaultHeaders = parent::getDefaultHeaders();
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }
        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        // for model (json/xml)
        if (isset($inventory)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($inventory));
            } else {
                $httpBody = $inventory;
            }
        } else if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);
            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        $query = ObjectSerializer::buildQuery($queryParams);
        $requestInfo = [
            'path' => $resourcePath,
            'method' => $method,
            'timestamp' => $defaultHeaders['WM_SEC.TIMESTAMP'],
            'query' => $query,
        ];

        $partnerApiKey = $this->config->getApiKey('partner', $requestInfo);
        if ($partnerApiKey !== null) {
            $headers['WM_PARTNER.ID'] = $partnerApiKey;
        }

        $signatureApiKey = $this->config->getApiKey('signature', $requestInfo);
        if ($signatureApiKey !== null) {
            $headers['WM_SEC.AUTH_SIGNATURE'] = $signatureApiKey;
        }

        $consumerIdApiKey = $this->config->getApiKey('consumerId', $requestInfo);
        if ($consumerIdApiKey !== null) {
            $headers['WM_CONSUMER.ID'] = $consumerIdApiKey;
        }

        // this endpoint requires Bearer authentication (access token)
        $token = $this->config->getAccessToken();
        if ($token) {
            $headers['WM_SEC.ACCESS_TOKEN'] = $token->accessToken;
        }

        $operationHost = $this->config->getHost();
        return new Request(
            $method,
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }
}

